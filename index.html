<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Big Lake Fishing Log</title>
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="favicon.ico">
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="apple-touch-icon" href="icon-192.svg">
  <style>
    :root { --bg:#0e131b; --card:#151b26; --ink:#e8eefb; --muted:#9fb0c8; --accent:#52a7ff; --accent-2:#2ed0a2; --danger:#ff6b6b; --warning:#ffd166; --good:#06d6a0; --shadow:rgba(0,0,0,.35); --radius:18px; }
    html, body { height:100%; } body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,sans-serif; background:var(--bg); color:var(--ink); }
    .wrap { max-width: 880px; margin:0 auto; padding: 8px; }
    header { position: sticky; top:0; z-index: 20; background: linear-gradient(180deg, rgba(14,19,27,0.98), rgba(14,19,27,0.86)); backdrop-filter: blur(6px); border-bottom: 1px solid #1f2a3a; }
    .bar { display:flex; gap:8px; align-items:center; padding: 10px 8px; } .title { font-weight:700; letter-spacing:.3px; font-size:22px; }
    .tabs { display:flex; gap:8px; overflow:auto; padding: 6px 8px 12px; }
    .tab-btn { flex:1; text-align:center; border:1px solid #26364c; background:#111622; color:var(--muted); padding:16px 0; border-radius:16px; font-weight:700; font-size:18px; }
    .tab-btn.active { color:#fff; border-color: var(--accent); box-shadow: 0 0 0 2px rgba(82,167,255,.15) inset; }
    .card { background:var(--card); border:1px solid #243349; border-radius: var(--radius); box-shadow: 0 8px 24px var(--shadow); padding:18px; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 18px; } @media(min-width:720px){ .grid.cols-2{ grid-template-columns: 1fr 1fr; } .grid.cols-3{ grid-template-columns: repeat(3,1fr);} }
  /* prevent grid items from forcing horizontal overflow on small phones */
  .grid > div { min-width:0; }
    label { display:block; font-size: 16px; color: var(--muted); margin-bottom:8px; font-weight:600; } input, select, textarea, button { width:100%; box-sizing:border-box; border-radius:16px; border:1.5px solid #2a3b54; background:#0c111a; color:#fff; padding:18px; font-size:20px; margin-bottom:8px; }
    select { padding-right:24px; } textarea { min-height:100px; }
    .row { display:flex; gap:14px; } .row > * { flex:1; } .chip { display:inline-flex; align-items:center; gap:8px; background:#0c111a; border:1.5px dashed #2f3f57; padding:12px 14px; border-radius:999px; font-size:16px; color:var(--muted); }
    .muted { color:var(--muted); font-size:16px; } .hint { font-size:15px; color:#8cabd8; margin-top:8px; }
    .btn { background:linear-gradient(180deg,#0e7eed,#0a5fc1); border:none; font-weight:800; letter-spacing:.3px; cursor:pointer; font-size:20px; padding:18px 0; border-radius:16px; }
    .btn.secondary { background:#0c111a; border:1.5px solid #2b3e59; color:#cfe3ff; } .btn.good { background:linear-gradient(180deg,#14bd8d,#0da77a); }
    .btn.warn { background:linear-gradient(180deg,#ffb703,#f77f00); } .btn.danger { background:linear-gradient(180deg,#ff4d4d,#bf2e2e); }
    table { width:100%; border-collapse: collapse; } th, td { padding:16px; border-bottom:1.5px solid #223145; text-align:left; font-size:18px; }
    th { color:#b8cdf1; font-weight:800; font-size:18px; position: sticky; top:0; background:#162133; z-index:1; } tr:hover td { background:#121b2b; }
    .pill { padding:8px 14px; border-radius:9999px; font-size:16px; display:inline-block; } .pill.badge { background:#0c111a; border:1.5px solid #2f3f57; color:#b9c9e3; }
    .spacer { height:16px; } .section-title { font-weight:900; letter-spacing:.4px; font-size:24px; } .footer { color:var(--muted); text-align:center; font-size:16px; padding:18px 0 32px; }
    .hide { display:none !important; }
    .thumb { width:90px; height:90px; object-fit:cover; border-radius:14px; border:1.5px solid #2a3b54; }
    .thumb-row { display:flex; gap:14px; align-items:center; }
    .lightbox { position:fixed; inset:0; background:rgba(0,0,0,.85); display:flex; align-items:center; justify-content:center; padding:20px; z-index:9999; }
    .lightbox img { max-width:95vw; max-height:85vh; border-radius:18px; box-shadow:0 10px 30px rgba(0,0,0,.6); }
    .lightbox .close { position:absolute; top:14px; right:14px; }
  .invalid { border-color: var(--danger)!important; }
  .badge-count { background:var(--accent); color:#fff; font-size:16px; padding:4px 10px; border-radius:999px; margin-left:10px; line-height:1; }
  .quick-hidden { display:none !important; }
  .prefs-row { display:flex; gap:16px; flex-wrap:wrap; }
  .switch { position:relative; display:inline-flex; align-items:center; gap:8px; font-size:18px; cursor:pointer; }
  .switch input { width:auto; accent-color: var(--accent); }
  #analytics { font-size:16px; line-height:1.5; }
  #analytics h4 { margin:10px 0 4px; font-size:18px; letter-spacing:.5px; text-transform:uppercase; color:var(--muted); }
  .spark { display:inline-block; background:var(--accent); height:14px; margin-right:4px; border-radius:4px; }
  #toast { position:fixed; left:50%; transform:translateX(-50%); bottom:24px; background:#142032; color:#fff; padding:16px 24px; border:1.5px solid #21405c; border-radius:18px; box-shadow:0 6px 16px rgba(0,0,0,.4); display:none; z-index:99999; font-size:18px; }
  #toast button { width:auto; padding:10px 16px; margin-left:14px; font-size:18px; }
  /* Mobile-specific layout tweaks for smaller phones (iPhone) */
  @media(max-width:420px){
    input, select, textarea, button { padding:12px; font-size:16px; border-radius:12px; }
    .tab-btn { font-size:16px; padding:12px 8px; border-radius:14px; }
    .grid.cols-2, .grid.cols-3 { grid-template-columns: 1fr !important; }
    .row { flex-direction:column; }
    .card { padding:14px; }
    .section-title { font-size:20px; }
    .tabs { gap:6px; padding:6px 6px 8px; }
    #toast { font-size:16px; padding:12px 18px; bottom:18px; }
  }
  /* iPhone 15 Pro specific (approx CSS device width 393px) */
  @media(max-width:400px){
    input, select, textarea, button { padding:10px; font-size:15px; border-radius:10px; }
    .tab-btn { font-size:15px; padding:10px 8px; }
    .section-title { font-size:18px; }
    .card { padding:12px; }
    /* avoid inputs causing horizontal overflow */
    input, select, textarea { max-width:100%; box-sizing:border-box; }
  }
  /* global safety to avoid horizontal scrolling caused by shadows/rounded inputs */
  html,body{ overflow-x:hidden; }
  /* highlight for auto-filled fields */
  .auto-filled { outline: 2px solid var(--accent-2); box-shadow: 0 10px 30px rgba(46,208,162,0.12); transition: box-shadow .35s, outline .35s; }
  </style>
</head>
<body>
  <header>
    <div class="bar">
      <div style="flex:1">
        <div class="title">Big Lake Fishing Log</div>
        
      </div>
      <button class="btn secondary" id="addToHome" title="How to add to Home Screen">Add to Home</button>
    </div>
    <div class="tabs" role="tablist">
      <button class="tab-btn active" data-tab="setup">Trip Setup</button>
  <button class="tab-btn" data-tab="log">Catch Log <span id="logCountBadge" class="badge-count" style="display:none">0</span></button>
      <button class="tab-btn" data-tab="review">Review & Export</button>
      <button class="tab-btn" data-tab="settings">Settings</button>
    </div>
  </header>
  <main class="wrap">
    <section id="tab-setup" class="grid">
      <div class="card">
        <div class="section-title">Trip header</div>
        <div class="grid cols-2">
          <div><label for="tripDate">Date</label><input id="tripDate" type="date" /></div>
          <div><label for="startTime">Start time</label><input id="startTime" type="time" /></div>
          <div><label for="port">Port / Area</label><input id="port" placeholder="e.g., St. Joseph, 80-160 FOW" /></div>
          <div><label for="boat">Boat</label><input id="boat" placeholder="Boat name" /></div>
          <div><label for="crew">Crew</label><input id="crew" placeholder="Who’s aboard" /></div>
          <div><label for="hours">Planned hours</label><input id="hours" type="number" inputmode="decimal" placeholder="e.g., 5" /></div>
        </div>
        <div class="grid cols-3">
          <div><label for="airTemp">Air temp (°F)</label><input id="airTemp" type="number" inputmode="decimal" /></div>
          <div><label for="surfaceTemp">Surface temp (°F)</label><input id="surfaceTemp" type="number" inputmode="decimal" /></div>
          <div><label for="wind">Wind (dir/speed)</label><input id="wind" placeholder="e.g., WNW 10" /></div>
          <div><label for="waves">Waves (ft)</label><input id="waves" type="number" inputmode="decimal" /></div>
          <div><label for="clouds">Cloud cover</label><select id="clouds"></select></div>
        </div>
        <div class="row" style="margin-top:10px">
          <button class="btn" id="fetchConditions" type="button">Catch Conditions (GPS)</button>
          <button class="btn secondary" id="downloadConditions" type="button">Download</button>
          <button class="btn warn" id="manualOverride" type="button">Manual Override</button>
        </div>
        <div style="margin-top:8px">
          <div class="muted">Tip: Tap <b>Download</b> or <b>Catch Conditions</b> before you leave to download latest conditions. Last cached: <span id="conditionsCached">—</span></div>
          <div class="muted">Nearest station: <span id="conditionsStation">—</span></div>
          <div id="marineSource" class="muted">Source: —</div>
        </div>
        <div class="hint">Tip: You can edit dropdown options under <b>Settings → Lists</b>.</div>
      </div>
      <div class="card">
        <div class="section-title">Save / load trip</div>
        <div class="grid cols-2">
          <button class="btn good" id="saveTrip">Save header</button>
          <button class="btn secondary" id="newTrip">New trip</button>
        </div>
        <div class="spacer"></div>
        <label for="tripSelect">Current trip</label>
        <select id="tripSelect"></select>
      </div>
    </section>
    <section id="tab-log" class="grid hide">
      <div class="card">
        <div class="section-title">Log a catch / bite</div>
        <div class="grid cols-3">
          <div><label for="time">Time</label><input id="time" type="time" /></div>
          <div><label for="platform">Platform</label><select id="platform"></select></div>
          <div><label for="trollDir">Troll direction</label><select id="trollDir"></select></div>
        </div>
        <div class="grid cols-3">
          <div><label for="waterDepth">Water depth (ft)</label><input id="waterDepth" type="number" inputmode="numeric" /></div>
          <div class="cond cond-rigger hide"><label for="ballDepth">Ball depth (ft)</label><input id="ballDepth" type="number" inputmode="numeric" /></div>
          <div class="cond cond-rigger hide"><label for="ballWeight">Rigger ball weight (lb)</label><input id="ballWeight" type="number" inputmode="decimal" /></div>
          <div class="cond cond-dipsy hide"><label for="dipsySize">Dipsy size</label><input id="dipsySize" placeholder="#0/#1/#2/#3" /></div>
          <div class="cond cond-dipsy hide"><label for="dipsySetting">Dipsy setting</label><input id="dipsySetting" placeholder="e.g., 1.5" /></div>
          <div class="cond cond-copper hide"><label for="copperLen">Copper length (ft)</label><input id="copperLen" type="number" inputmode="numeric" /></div>
          <div class="cond cond-leadcore hide"><label for="leadcoreColors">Leadcore (colors)</label><input id="leadcoreColors" placeholder="e.g., 5c/7c" /></div>
          <div><label for="targetDepth">Target depth (ft)</label><input id="targetDepth" type="number" inputmode="numeric" /></div>
          <div><label for="lineOut">Line out (ft)</label><input id="lineOut" type="number" inputmode="numeric" /></div>
        </div>
        <div class="grid cols-3">
          <div><label for="lineType">Line type</label><select id="lineType"></select></div>
          <div><label for="lineStrength">Line strength (lb)</label><input id="lineStrength" type="number" inputmode="numeric" /></div>
          <div><label for="leaderLen">Leader length (ft)</label><input id="leaderLen" type="number" inputmode="numeric" /></div>
        </div>
        <div class="grid cols-3">
          <div><label for="lureType">Lure type</label><select id="lureType"></select></div>
          <div><label for="lureBrand">Brand / model</label><input id="lureBrand" placeholder="e.g., Moonshine RV, J-plug" /></div>
          <div><label for="lureSize">Size</label><input id="lureSize" placeholder="e.g., mag, standard, 4" /></div>
          <div><label for="lureColor">Color / pattern</label><input id="lureColor" placeholder="e.g., NBK, UV blue/green, glow" /></div>
          <div><label for="attractor">Attractor / flasher</label><input id="attractor" placeholder="e.g., 8&quot; white crush" /></div>
          <div><label for="flyMeat">Fly / meat color</label><input id="flyMeat" placeholder="e.g., blue fly, green meat" /></div>
        </div>
        <div class="grid cols-3">
          <div><label for="speedBall">Speed @ ball (mph)</label><input id="speedBall" type="number" inputmode="decimal" /></div>
          <div><label for="sog">SOG (mph)</label><input id="sog" type="number" inputmode="decimal" /></div>
          <div><label for="strikeDepthSeen">Strike depth seen (ft)</label><input id="strikeDepthSeen" type="number" inputmode="numeric" /></div>
        </div>
        <div class="grid cols-3">
          <div><label for="species">Species</label><select id="species"></select></div>
          <div><label for="lengthIn">Length (in)</label><input id="lengthIn" type="number" inputmode="decimal" /></div>
          <div><label for="weightLb">Weight (lb)</label><input id="weightLb" type="number" inputmode="decimal" /></div>
          <div><label for="keptRel">Kept / Released</label><select id="keptRel"><option value="">—</option><option>Kept</option><option>Released</option></select></div>
          <div><label for="landedYN">Landed</label><select id="landedYN"><option value="">—</option><option>Y</option><option>N</option></select></div>
          <div><label for="hookLoc">Hook location</label><select id="hookLoc"></select></div>
        </div>
        <div class="grid cols-2">
          <div>
            <label for="gps">GPS (lat, lon)</label>
            <input id="gps" placeholder="e.g., 42.10, -86.50" />
            <div class="row">
              <button class="btn secondary" id="getGps">Get location</button>
              <button class="btn secondary" id="nowBtn">Now</button>
            </div>
            <div class="hint">Note: Geolocation may require HTTPS and user permission. If blocked, enter manually.</div>
          </div>
          <div><label for="notes">Notes</label><textarea id="notes" placeholder="Strike details, direction change, color tweaks, etc."></textarea></div>
        </div>
        <div class="card" style="background:#0f1723; border-style:dashed;">
          <div class="section-title">Photo (fish or lure)</div>
          <input id="photoInput" type="file" accept="image/*" capture="environment" />
          <div class="hint">Tip: On iPhone/Android this opens the camera. We compress before saving to keep storage light.</div>
          <div class="thumb-row">
            <img id="photoPreview" class="thumb hide" alt="preview"/>
            <button class="btn secondary" id="clearPhoto" type="button">Remove photo</button>
          </div>
        </div>
        <div class="row">
          <button class="btn good" id="addEntry">Save entry</button>
          <button class="btn secondary" id="resetForm">Reset form</button>
          <button class="btn secondary" id="dupLast" type="button">Duplicate last</button>
          <button class="btn secondary" id="cancelEdit" type="button" style="display:none">Cancel edit</button>
          <button class="btn warn" id="forceSave" type="button" style="display:none">Force save</button>
          <button class="btn secondary" id="quickToggle" type="button" title="Toggle Quick Log mode">Quick Mode: Off</button>
        </div>
      </div>
      <div class="card">
        <div class="section-title">Session entries</div>
        <div style="overflow:auto; max-height: 45vh;">
          <table id="entriesTable">
            <thead>
              <tr><th>Time</th><th>Platf.</th><th>Photo</th><th>Lure</th><th>Depths</th><th>Dir/Speed</th><th>Species</th><th>WL</th><th></th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </section>
    <section id="tab-review" class="grid hide">
      <div class="card">
        <div class="section-title">Trip summary</div>
        <div id="summary" class="muted">(Fill in Trip Setup and add entries to see a summary.)</div>
      </div>
      <div class="card">
        <div class="section-title">Analytics</div>
        <div id="analytics" class="muted">(Data appears after entries.)</div>
      </div>
      <div class="card">
        <div class="section-title">Export / backup</div>
        <div class="grid cols-1">
          <div style="display:flex;gap:12px">
            <button class="btn" id="exportCsv">Export catches (CSV)</button>
            <button class="btn secondary" id="pushToSheet">Push to Google Sheet</button>
            <button class="btn secondary" id="pushFullTrip">Push full trip (rows)</button>
          </div>
        </div>
        <div class="hint">Note: CSV export is the simplest way to back up your log. Upload the file to Google Drive manually if you want a cloud backup.</div>
      </div>
      <div class="card">
        <div class="section-title">Manage data</div>
        <div class="grid cols-2">
          <button class="btn danger" id="clearTrip">Clear current trip</button>
          <button class="btn danger" id="clearAll">Clear ALL trips</button>
          <button class="btn danger" id="deleteTrip" style="grid-column:span 2">Delete trip</button>
        </div>
        <div class="hint">Clearing is permanent on this device. Export first if you want a backup.</div>
      </div>
    </section>
    <section id="tab-settings" class="grid hide">
      <div class="card">
        <div class="section-title">Lists</div>
        <div class="grid cols-2">
          <div><label for="listPlatform">Platform options (one per line)</label><textarea id="listPlatform"></textarea></div>
          <div><label for="listLineType">Line types</label><textarea id="listLineType"></textarea></div>
          <div><label for="listLureType">Lure types</label><textarea id="listLureType"></textarea></div>
          <div><label for="listSpecies">Species</label><textarea id="listSpecies"></textarea></div>
          <div><label for="listTrollDir">Troll directions</label><textarea id="listTrollDir"></textarea></div>
          <div><label for="listClouds">Cloud cover</label><textarea id="listClouds"></textarea></div>
          <div><label for="listHookLoc">Hook locations</label><textarea id="listHookLoc"></textarea></div>
        </div>
        <div class="row">
          <button class="btn good" id="saveLists">Save lists</button>
          <button class="btn secondary" id="restoreDefaults">Restore defaults</button>
        </div>
      </div>
      <div class="card">
        <div class="section-title">About</div>
        <div class="muted">All data is stored locally on this device. Text data uses <b>localStorage</b>; photos use <b>IndexedDB</b> to avoid size limits. Export CSV/JSON/Album after each trip to back up.</div>
      </div>
      <div class="card">
        <div class="section-title">Preferences</div>
        <div class="prefs-row">
          <label class="switch"><input type="checkbox" id="prefQuickDefault"/> Quick mode by default</label>
          <label class="switch"><input type="checkbox" id="prefSticky" checked/> Sticky lure fields</label>
        </div>
        <div style="margin-top:12px">
          <label for="marineJsonUrl">Optional: Marine data JSON URL (public)</label>
          <input id="marineJsonUrl" placeholder="https://example.com/marine.json" />
          <div class="hint">If you host a simple JSON file with fields { sstC: <Celsius>, waveM: <meters> } we will fetch it (useful at the dock before heading out).</div>
        </div>
        <div style="margin-top:12px">
          <label for="stationJsonTemplate">Optional: Station JSON template (public)</label>
          <input id="stationJsonTemplate" placeholder="https://yourhost.example/stations/{station}.json or raw GitHub URL" />
          <div class="hint">You can paste a GitHub Pages or raw URL template. Use <code>{station}</code> to substitute station id. Example: <code>https://raw.githubusercontent.com/elliottdanielp/big_lake_fishing_log/main/sample-ndbc.json</code></div>
        </div>
        <div style="margin-top:12px">
          <label for="sheetWebAppUrl">Optional: Google Sheet Web App URL</label>
          <input id="sheetWebAppUrl" placeholder="https://script.google.com/macros/s/....../exec" />
          <div class="hint">Paste the Web App URL from Apps Script (deploy as Web app). We'll POST a single summary row when you tap Push to Google Sheet.</div>
        </div>
        <div style="margin-top:6px">
          <label for="sheetSecret">Optional: Sheet secret (short token)</label>
          <input id="sheetSecret" placeholder="shared-secret-for-posts" />
          <div class="hint">A short secret that the Apps Script validates to prevent accidental writes. Keep private.</div>
        </div>
        <div class="row" style="margin-top:10px">
          <button class="btn good" id="savePrefs" type="button">Save preferences</button>
          <button class="btn secondary" id="testStationJson" type="button">Test station JSON</button>
          <button class="btn secondary" id="debugStationJson" type="button">Debug station (raw)</button>
        </div>
        <div class="hint">Sticky keeps lure fields after saving. Quick mode hides advanced fields for speed.</div>
      </div>
    </section>
  </main>
  <div class="footer">© You. Fish hard, log smart.</div>
  <div id="lightbox" class="lightbox hide" role="dialog" aria-modal="true">
    <img id="lightboxImg" alt="photo" />
    <button class="btn secondary close" id="lightboxClose">Close</button>
  </div>
  <div id="toast"></div>
  <script>
  // Ensure all event listeners are attached after DOM is loaded
  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => Array.from(document.querySelectorAll(sel));
  const uid = () => Math.random().toString(36).slice(2) + Date.now().toString(36);
  // Helper for older browsers: attach event only if element exists (avoids optional-chaining syntax)
  function attach(selector, evt, handler) { const el = document.querySelector(selector); if (el) el.addEventListener(evt, handler); }
  const onReady = (fn) => { if (document.readyState === 'loading') window.addEventListener('DOMContentLoaded', fn); else fn(); };
  onReady(() => {
      // Manual override button clears and enables all weather fields for manual entry
  attach('#manualOverride', 'click', () => {
        ['airTemp','surfaceTemp','wind','waves','clouds'].forEach(id => {
          const el = document.getElementById(id);
          if (el) {
            el.value = '';
            el.disabled = false;
          }
        });
        toast('Weather fields cleared for manual entry');
      });
      // All other event listeners below (move all listeners inside this block)
  attach('#fetchConditions', 'click', async () => {
        // Minimal local-only implementation: attempt geolocation then mark conditions cached.
        try {
          if (!('geolocation' in navigator)) {
            toast('Geolocation unavailable');
            return;
          }
          navigator.geolocation.getCurrentPosition(async pos => {
            const { latitude, longitude } = pos.coords;
            // store coords in the header for reference and populate GPS field on the catch form
            const cur = currentTripId();
            const lat = Number(latitude).toFixed(5);
            const lon = Number(longitude).toFixed(5);
            if (cur && state.trips[cur]) {
              state.trips[cur].header = state.trips[cur].header || {};
              state.trips[cur].header.lastLat = lat;
              state.trips[cur].header.lastLon = lon;
              state.trips[cur].header.lastFetchedAt = Date.now();
              save();
            }
            const el = document.getElementById('conditionsCached');
            if (el) el.textContent = new Date().toLocaleString() + ' • ' + lat + ', ' + lon;
            // also prefill the GPS input in the catch form so new entries inherit the location
            const gpsInput = document.getElementById('gps');
            if (gpsInput && !gpsInput.value) gpsInput.value = lat + ', ' + lon;
            // Fetch weather via Open-Meteo to populate airTemp, wind and clouds (best-effort)
            try{
              const wm = await fetchOpenMeteo(latitude, longitude);
              if(wm && typeof wm.tempC === 'number'){
                // convert to °F for the UI
                const f = Math.round((wm.tempC * 9/5) + 32);
                const airEl = document.getElementById('airTemp');
                if(airEl) airEl.value = f;
                // store
                if(cur && state.trips[cur]) state.trips[cur].header.airTemp = String(f);
              }
              if(wm && typeof wm.windKmh === 'number'){
                const mph = Math.round(wm.windKmh / 1.609);
                const dir = (typeof wm.windDeg==='number') ? degToCompass(wm.windDeg) : '';
                const wstr = dir ? `${dir} ${mph} mph` : `${mph} mph`;
                const windEl = document.getElementById('wind');
                if(windEl) windEl.value = wstr;
                if(cur && state.trips[cur]) state.trips[cur].header.wind = wstr;
              }
              if(wm && typeof wm.cloudPct === 'number'){
                // map cloud % to nearest option in #clouds select if possible
                const cloudsEl = document.getElementById('clouds');
                if(cloudsEl){
                  const pct = wm.cloudPct;
                  // simple mapping: 0-10 Clear, 11-50 Partly, 51-100 Overcast
                  let opt = '';
                  if(pct<=10) opt = 'Clear'; else if(pct<=50) opt = 'Partly'; else opt = 'Overcast';
                  // pick matching option if present
                  const found = Array.from(cloudsEl.options).find(o=>o.text.toLowerCase().startsWith(opt.toLowerCase()));
                  if(found) cloudsEl.value = found.value || found.text;
                }
                if(cur && state.trips[cur]) state.trips[cur].header.clouds = String(wm.cloudPct);
              }
              // attempt to fetch marine / surface data (sea surface temp, waves)
              try{
                // compute nearest station if we have a stations list
                let nearest = null;
                try{
                  const stations = window.__stations || [];
                  if(stations.length){
                    const toR = n => n * Math.PI / 180;
                    const hav = (a,b)=>{ const R=6371; const dLat=toR(b.lat-a.lat); const dLon=toR(b.lon-a.lon); const la=toR(a.lat), lb=toR(b.lat); const h = Math.sin(dLat/2)**2 + Math.cos(la)*Math.cos(lb)*Math.sin(dLon/2)**2; return 2*R*Math.asin(Math.sqrt(h)); };
                    let best=null, bestD=Infinity; stations.forEach(s=>{ const d = hav({lat: latitude, lon: longitude}, {lat:s.lat, lon:s.lon}); if(d<bestD){ bestD=d; best=s; } }); if(best) nearest = Object.assign({}, best, {distKm: bestD});
                  }
                }catch(e){ console.warn('stations lookup failed', e); }
                if(nearest){ 
                  const cs = document.getElementById('conditionsStation'); 
                  if(cs) cs.textContent = nearest.name + ' • ' + (nearest.distKm? nearest.distKm.toFixed(1)+' km':''); 
                  // Auto-fill Port/Area from nearest station if port field empty
                  try{
                    const portEl = document.getElementById('port');
                    if(portEl && !portEl.value){
                      const portVal = nearest.name + (nearest.distKm? (' • '+nearest.distKm.toFixed(1)+' km') : '');
                      portEl.value = portVal;
                      if(cur && state.trips[cur]) state.trips[cur].header.port = portVal;
                    }
                    // Auto-fill date and start time if empty
                    const dateEl = document.getElementById('tripDate');
                    const timeEl = document.getElementById('startTime');
                    const now = new Date();
                    if(dateEl && !dateEl.value){ const localDate = now.getFullYear() + '-' + String(now.getMonth()+1).padStart(2,'0') + '-' + String(now.getDate()).padStart(2,'0'); dateEl.value = localDate; if(cur && state.trips[cur]) state.trips[cur].header.date = localDate; }
                    if(timeEl && !timeEl.value){ const t = now.toTimeString().slice(0,5); timeEl.value = t; if(cur && state.trips[cur]) state.trips[cur].header.startTime = t; }
                    // persist the header after auto-filling
                    save();
                  }catch(e){ console.warn('auto-fill port/date failed', e); }
                }

                // try station-specific JSON template if configured
                let marine = null;
                try{
                  const tpl = (state.settings && state.settings.stationJsonTemplate) ? String(state.settings.stationJsonTemplate).trim() : '';
                  if(tpl && nearest){
                    const url = tpl.replace('{station}', encodeURIComponent(nearest.id)).replace('{lat}', encodeURIComponent(latitude)).replace('{lon}', encodeURIComponent(longitude));
                    try{
                      const r = await fetch(url, { cache: 'no-store' });
                      if(r.ok){
                        const js = await r.json();
                        const s = js && (js.sstC ?? js.surfaceTempC ?? js.sst ?? null);
                        const wv = js && (js.waveM ?? js.significant_wave_height ?? js.wave ?? null);
                        if(s!==null || wv!==null){ marine = { sstC: s===null?null:Number(s), waveM: wv===null?null:Number(wv) }; }
                      } else { console.warn('station template HTTP', r.status); }
                    }catch(e){ console.warn('station template fetch failed', e); }
                  }
                }catch(e){ console.warn('station template handling failed', e); }

                // fallback to default marine fetch if we didn't get a station JSON
                if(!marine){
                  marine = await fetchMarineNearest(latitude, longitude);
                }

                if(marine){
                  if(typeof marine.sstC === 'number'){
                    const sstF = Math.round((marine.sstC * 9/5) + 32);
                    const sEl = document.getElementById('surfaceTemp');
                    if(sEl) sEl.value = sstF;
                    if(cur && state.trips[cur]) state.trips[cur].header.surfaceTemp = String(sstF);
                  }
                  if(typeof marine.waveM === 'number'){
                    const waveFt = (marine.waveM * 3.28084).toFixed(1);
                    const wEl = document.getElementById('waves');
                    if(wEl) wEl.value = waveFt;
                    if(cur && state.trips[cur]) state.trips[cur].header.waves = String(waveFt);
                  }
                  // persist source metadata, snapshot for undo, show human timestamp and highlight fields
                  try{
                    const ms = document.getElementById('marineSource');
                    const stationId = (marine && marine.station) ? String(marine.station) : (nearest && nearest.id ? String(nearest.id) : '');
                    const src = stationId ? `buoy ${stationId}` : 'autofill';
                    if(cur && state.trips[cur]){
                      // snapshot previous header for undo
                      pendingMarineUndo = { id: cur, prevHeader: Object.assign({}, state.trips[cur].header || {}) };
                      state.trips[cur].header.marineSource = src;
                      state.trips[cur].header.marineFetchedAt = Date.now();
                      if(stationId) state.trips[cur].header.marineStation = stationId;
                    }
                    if(ms){
                      const d = new Date(state.trips[cur].header.marineFetchedAt);
                      ms.textContent = 'Source: Auto-filled from ' + src + ' • ' + d.toLocaleString();
                    }
                    // highlight the auto-filled fields briefly
                    try{ const sEl = document.getElementById('surfaceTemp'); const wEl = document.getElementById('waves'); if(sEl){ sEl.classList.add('auto-filled'); setTimeout(()=>sEl.classList.remove('auto-filled'), 3000); } if(wEl){ wEl.classList.add('auto-filled'); setTimeout(()=>wEl.classList.remove('auto-filled'), 3000); } }catch(e){}
                    // show undo in toast
                    toast('Conditions cached (local) — values auto-filled. <button class="btn secondary" id="undoMarineBtn">Undo</button>', true);
                    setTimeout(hideToast, 8000);
                    // wire undo button once shown
                    setTimeout(()=>{ const b = document.getElementById('undoMarineBtn'); if(b) b.addEventListener('click', ()=>{ if(pendingMarineUndo && pendingMarineUndo.id){ const id = pendingMarineUndo.id; state.trips[id].header = pendingMarineUndo.prevHeader || {}; save(); loadHeaderIntoForm(); const ms2 = document.getElementById('marineSource'); if(ms2) ms2.textContent = 'Source: —'; pendingMarineUndo = null; toast('Auto-fill undone'); setTimeout(hideToast, 1600); } }); }, 50);
                  }catch(e){ console.warn('failed to persist marine source', e); }
                }
              }catch(e){ console.warn('marine fetch error', e); }
              save();
            }catch(err){
              console.warn('Weather fetch failed', err);
            }
            toast('Conditions cached (local)');
            // auto-hide the toast quickly so it doesn't obscure form fields on small screens
            setTimeout(hideToast, 1600);
          }, err => {
            toast('Could not get location: ' + (err && err.message));
            setTimeout(hideToast, 2000);
          }, { enableHighAccuracy: true, timeout: 8000, maximumAge: 10000 });
        } catch (err) { console.warn('fetchConditions error', err); toast('Failed to fetch conditions'); }
      });
  attach('#saveTrip', 'click', saveHeader);
  attach('#newTrip', 'click', () => {
        // ...existing code...
      });
  attach('#tripSelect', 'change', () => {
        // ...existing code...
      });
  attach('#platform', 'change', () => {
        // ...existing code...
      });
  attach('#nowBtn', 'click', setNow);
  attach('#getGps', 'click', () => {
        // ...existing code...
      });
  attach('#saveLists', 'click', textareaToLists);
  attach('#restoreDefaults', 'click', () => {
        // ...existing code...
      });
  attach('#addEntry', 'click', () => addOrUpdateEntry(false));
  attach('#forceSave', 'click', () => addOrUpdateEntry(true));
  attach('#cancelEdit', 'click', () => { setEditing(false); clearCatchForm(false); });
  attach('#dupLast', 'click', () => {
        const t=state.trips[currentTripId()];
        if(!t||!t.entries.length) return toast('No previous entry');
        const last=t.entries[t.entries.length-1];
        loadEntryIntoForm(last, true);
        editingEntryId=null;
        setNow();
        setEditing(false);
      });
  attach('#resetForm', 'click', clearCatchForm);
  attach('#clearPhoto', 'click', () => {
        // ...existing code...
      });
  // lightbox handlers (guarded)
  const lbCloseBtn = $('#lightboxClose');
  if (lbCloseBtn) lbCloseBtn.addEventListener('click', () => { const lb = $('#lightbox'); if (lb) lb.classList.add('hide'); });
  const lightboxEl = $('#lightbox');
  if (lightboxEl) lightboxEl.addEventListener('click', (e) => { if (e.target && e.target.id === 'lightbox') { lightboxEl.classList.add('hide'); } });
      attach('#exportCsv', 'click', exportCsv);

      // Tab switching for top nav
      // Primary tab handlers: add both per-button and delegated handler for robustness
      $$('.tab-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const tab = btn.dataset.tab || 'setup';
          // set active class
          $$('.tab-btn').forEach(b => b.classList.toggle('active', b === btn));
          // hide/show sections
          ['setup','log','review','settings'].forEach(name => {
            const el = document.getElementById('tab-' + name);
            if (!el) return;
            if (name === tab) el.classList.remove('hide'); else el.classList.add('hide');
          });
          // when switching to review or log, re-render
          if (tab === 'review') { renderSummary(); renderAnalytics(); }
          if (tab === 'log') { renderEntries(); }
          
        });
      });
      // Delegated handler: catches clicks on inner elements/text
      attach('.tabs', 'click', (e) => {
        const btn = (e.target && e.target.closest) ? e.target.closest('.tab-btn') : null;
        if (!btn) return;
        const tab = btn.dataset.tab || 'setup';
        $$('.tab-btn').forEach(b => b.classList.toggle('active', b === btn));
        ['setup','log','review','settings'].forEach(name => {
          const el = document.getElementById('tab-' + name);
          if (!el) return;
          if (name === tab) el.classList.remove('hide'); else el.classList.add('hide');
        });
        if (tab === 'review') { renderSummary(); renderAnalytics(); }
        if (tab === 'log') { renderEntries(); }
        
      });

      // Add any other button listeners here as needed
    });
    function degToCompass(num) {
      const val = Math.floor((num / 22.5) + 0.5);
      const arr = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
      return arr[(val % 16)];
    }
    // Fetch current weather from Open-Meteo (no API key). Returns an object or throws.
    async function fetchOpenMeteo(lat, lon){
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}&current_weather=true&hourly=cloudcover&timezone=auto`;
      const r = await fetch(url, {cache: 'no-store'});
      if(!r.ok) throw new Error('Weather API HTTP '+r.status);
      const js = await r.json();
      // current_weather: temperature (°C), windspeed (km/h), winddirection (deg)
      const cw = js.current_weather || {};
      const tempC = cw.temperature;
      const windKmh = cw.windspeed;
      const windDeg = cw.winddirection;
      // attempt to derive cloud cover from nearest hourly point
      let cloudPct = null;
      if(js.hourly && Array.isArray(js.hourly.time) && Array.isArray(js.hourly.cloudcover)){
        const times = js.hourly.time.map(t=>new Date(t).getTime());
        const now = Date.now();
        // find nearest index
        let bestIdx = 0, bestDiff = Infinity;
        for(let i=0;i<times.length;i++){ const d = Math.abs(times[i]-now); if(d<bestDiff){ bestDiff=d; bestIdx=i; } }
        cloudPct = Number(js.hourly.cloudcover[bestIdx]);
      }
      return { tempC, windKmh, windDeg, cloudPct };
    }

    // Placeholder for marine/surface data API for Lake Michigan (Holland <-> Muskegon area).
    // Real marine data (surface temp, waves) typically comes from NOAA/GLERL/NDBC/ERDDAP and may need different endpoints.
    // This placeholder returns null and is intended to be replaced with a proper API call later.
    async function fetchMarineNearest(lat, lon){
      // 1) If the user supplied a public JSON URL in Settings, try it first.
      //    Accepts either a tiny JSON like { sstC: 4.2, waveM: 0.6 }
      //    or a full Open-Meteo marine response (hourly.time + hourly.sea_surface_temperature etc.).
      try{
        const mj = (state && state.settings && state.settings.marineJsonUrl) ? String(state.settings.marineJsonUrl).trim() : '';
        // ALSO: if user configured a station JSON template (worker), prefer calling it with prefer=ocean-spec
        const tpl = (state && state.settings && state.settings.stationJsonTemplate) ? String(state.settings.stationJsonTemplate).trim() : '';
        if(tpl){
          try{
            // If we have a stations list, compute nearest id (best-effort). Otherwise the calling code may have provided nearest id via template placeholders.
            let stationId = '';
            try{
              const stations = window.__stations || [];
              if(stations.length){
                // simple haversine nearest
                const toR = n => n * Math.PI / 180;
                const hav = (a,b)=>{ const R=6371; const dLat=toR(b.lat-a.lat); const dLon=toR(b.lon-a.lon); const la=toR(a.lat), lb=toR(b.lat); const h = Math.sin(dLat/2)**2 + Math.cos(la)*Math.cos(lb)*Math.sin(dLon/2)**2; return 2*R*Math.asin(Math.sqrt(h)); };
                let best=null, bestD=Infinity; stations.forEach(s=>{ const d = hav({lat: lat, lon: lon}, {lat:s.lat, lon:s.lon}); if(d<bestD){ bestD=d; best=s; } }); if(best) stationId = best.id || '';
              }
            }catch(e){ console.warn('nearest station lookup failed', e); }
            // build URL by substituting {station},{lat},{lon}
            let url = tpl.replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
            if(stationId) url = url.replace('{station}', encodeURIComponent(stationId));
            // request prefer=ocean-spec so worker composes SST from .ocean and WVHT from .spec
            const debugSuffix = url.includes('?') ? '&' : '?';
            const prefUrl = url + debugSuffix + 'prefer=ocean-spec';
            const r = await fetch(prefUrl, { cache: 'no-store' });
            if(r.ok){
              const js = await r.json();
              // Accept tiny shapes or composed fields
              const maybeSst = js && (js.sstC ?? js.surfaceTempC ?? js.sst ?? null);
              const maybeWave = js && (js.waveM ?? js.significant_wave_height ?? js.wave ?? null);
              if(maybeSst !== undefined || maybeWave !== undefined){
                const s = (maybeSst===null||maybeSst===undefined)? null : Number(maybeSst);
                const w = (maybeWave===null||maybeWave===undefined)? null : Number(maybeWave);
                return { sstC: s, waveM: w };
              }
            } else {
              console.warn('station template prefer fetch failed', r.status, prefUrl);
            }
          }catch(e){ console.warn('station template prefer fetch error', e); }
        }
        if(mj){
          try{
            // allow simple placeholders {lat} and {lon} in the URL
            let url = mj.replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
            const r = await fetch(url, { cache: 'no-store' });
            if(r.ok){
              const js = await r.json();
              // tiny JSON shape
              const maybeSst = js && (js.sstC ?? js.surfaceTempC ?? js.sst ?? js.sea_surface_temperature);
              const maybeWave = js && (js.waveM ?? js.significant_wave_height ?? js.waveM ?? js.wave ?? js.significant_wave_height_meters);
              if(maybeSst !== undefined || maybeWave !== undefined){
                const s = (maybeSst===null||maybeSst===undefined)? null : Number(maybeSst);
                const w = (maybeWave===null||maybeWave===undefined)? null : Number(maybeWave);
                return { sstC: s, waveM: w };
              }
              // try to parse full Open-Meteo marine response
              if(js && js.hourly && Array.isArray(js.hourly.time)){
                const times = js.hourly.time.map(t=>new Date(t).getTime());
                const now = Date.now();
                let bestIdx = 0, bestDiff = Infinity;
                for(let i=0;i<times.length;i++){ const d = Math.abs(times[i]-now); if(d<bestDiff){ bestDiff=d; bestIdx=i; } }
                const sst = (js.hourly.sea_surface_temperature && js.hourly.sea_surface_temperature[bestIdx]!==undefined) ? Number(js.hourly.sea_surface_temperature[bestIdx]) : null;
                const wave = (js.hourly.significant_wave_height && js.hourly.significant_wave_height[bestIdx]!==undefined) ? Number(js.hourly.significant_wave_height[bestIdx]) : null;
                return { sstC: sst, waveM: wave };
              }
              // if we reach here, the JSON didn't match expected shapes
              console.warn('marineJsonUrl returned JSON but no recognizable fields');
            } else {
              console.warn('marineJsonUrl HTTP', r.status);
            }
          }catch(e){ console.warn('Failed to fetch/parse marineJsonUrl', e); }
        }
      }catch(e){ console.warn('marineJsonUrl handling failed', e); }

      // 2) Fallback: Open-Meteo Marine API (public, no key) — returns sea surface temperature and significant wave height (hourly)
      try{
        const m = await fetchOpenMeteoMarine(lat, lon);
        return m; // { sstC, waveM }
      }catch(err){
        console.warn('Marine fallback failed', err);
        return null;
      }
    }

    // Query Open-Meteo's Marine API (no key). Returns { sstC, waveM } or throws.
    async function fetchOpenMeteoMarine(lat, lon){
      // hourly=sea_surface_temperature,significant_wave_height
      // If a proxy is configured (to bypass CORS or add station logic), use it
      const proxy = (window && window.MARINE_PROXY_URL) ? window.MARINE_PROXY_URL.replace(/\/$/, '') : null;
      let res;
      if(proxy){
        const url = `${proxy}/api/marine?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}`;
        res = await fetch(url, { cache: 'no-store' });
      } else {
        const url = `https://marine-api.open-meteo.com/v1/marine?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}&hourly=sea_surface_temperature,significant_wave_height&timezone=auto`;
        res = await fetch(url, { cache: 'no-store' });
      }
      if(!res.ok) throw new Error('Marine API HTTP '+res.status);
      const js = await res.json();
      // pick nearest hourly value
      let sst = null, wave = null;
      if(js && js.hourly && Array.isArray(js.hourly.time)){
        const times = js.hourly.time.map(t=>new Date(t).getTime());
        const now = Date.now();
        let bestIdx = 0, bestDiff = Infinity;
        for(let i=0;i<times.length;i++){ const d = Math.abs(times[i]-now); if(d<bestDiff){ bestDiff=d; bestIdx=i; } }
        if(js.hourly.sea_surface_temperature && js.hourly.sea_surface_temperature[bestIdx] !== undefined) sst = Number(js.hourly.sea_surface_temperature[bestIdx]);
        if(js.hourly.significant_wave_height && js.hourly.significant_wave_height[bestIdx] !== undefined) wave = Number(js.hourly.significant_wave_height[bestIdx]);
      }
      return { sstC: sst, waveM: wave };
    }
  const LS_KEY = 'blfl.state.v2';
  let state = load() || { trips: {}, lists: defaults(), dataVersion:3, settings:{quickMode:false, sticky:true} };
  let pendingMarineUndo = null;
    function defaults(){ return { Platform:["Downrigger","Dipsy","Copper","Leadcore","Planer","Flatline"], LineType:["Wire","Braid","Mono","Fluorocarbon","Copper","Leadcore"], LureType:["Spoon","Plug","Flasher/Fly","Meat Rig","Spin-n-Glow","Other"], Species:["Chinook (King)","Coho","Steelhead","Lake Trout","Brown Trout","Other"], TrollDirection:["N","NE","E","SE","S","SW","W","NW"], Clouds:["Clear","Partly","Overcast","Fog"], HookLocation:["Jaw","Corner","Tongue","Outside"] }; }
  function save(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
    function load(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)); }catch(e){ return null; } }
    const DB_NAME='blfl-db', DB_VER=1;
    function openDB(){ return new Promise((resolve,reject)=>{ const req=indexedDB.open(DB_NAME,DB_VER); req.onupgradeneeded=()=>{ const db=req.result; if(!db.objectStoreNames.contains('photos')) db.createObjectStore('photos',{keyPath:'id'}); }; req.onsuccess=()=>resolve(req.result); req.onerror=()=>reject(req.error); }); }
    async function savePhoto(entryId, dataURL){ const db=await openDB(); await new Promise((res,rej)=>{ const tx=db.transaction('photos','readwrite'); tx.objectStore('photos').put({id:entryId, dataURL, ts:Date.now()}); tx.oncomplete=res; tx.onerror=()=>rej(tx.error); }); }
  async function getPhoto(entryId){ const db=await openDB(); return await new Promise((res,rej)=>{ const tx=db.transaction('photos','readonly'); const req=tx.objectStore('photos').get(entryId); req.onsuccess=()=>res((req.result && req.result.dataURL) || ''); req.onerror=()=>rej(req.error); }); }
    async function deletePhoto(entryId){ const db=await openDB(); await new Promise((res,rej)=>{ const tx=db.transaction('photos','readwrite'); tx.objectStore('photos').delete(entryId); tx.oncomplete=res; tx.onerror=()=>rej(tx.error); }); }
  // (Removed duplicate event listener for .tab-btn)
    function fillSelect(id, arr){ const el=$(id); el.innerHTML = '<option value="">—</option>' + arr.map(v=>`<option>${v}</option>`).join(''); }
    function fillAllSelects(){ fillSelect('#platform', state.lists.Platform); fillSelect('#lineType', state.lists.LineType); fillSelect('#lureType', state.lists.LureType); fillSelect('#species', state.lists.Species); fillSelect('#trollDir', state.lists.TrollDirection); fillSelect('#clouds', state.lists.Clouds); fillSelect('#hookLoc', state.lists.HookLocation); }
    function listsToTextarea(){ $('#listPlatform').value = state.lists.Platform.join('\n'); $('#listLineType').value = state.lists.LineType.join('\n'); $('#listLureType').value = state.lists.LureType.join('\n'); $('#listSpecies').value = state.lists.Species.join('\n'); $('#listTrollDir').value = state.lists.TrollDirection.join('\n'); $('#listClouds').value = state.lists.Clouds.join('\n'); $('#listHookLoc').value = state.lists.HookLocation.join('\n'); }
  function textareaToLists(){ const split=t=>t.split('\n').map(s=>s.trim()).filter(Boolean); state.lists.Platform=split($('#listPlatform').value); state.lists.LineType=split($('#listLineType').value); state.lists.LureType=split($('#listLureType').value); state.lists.Species=split($('#listSpecies').value); state.lists.TrollDirection=split($('#listTrollDir').value); state.lists.Clouds=split($('#listClouds').value); state.lists.HookLocation=split($('#listHookLoc').value); save(); fillAllSelects(); }
  // (Removed duplicate event listeners for #saveLists and #restoreDefaults)
    function currentTripId(){ return $('#tripSelect').value || null; }
  function ensureTrip(){ let id=currentTripId(); if(!id){ id=uid(); state.trips[id]={id, header:{}, entries:[], createdAt:Date.now(), updatedAt:Date.now()}; $('#tripSelect').value=id; save(); refreshTripSelect(); } return id; }
  function refreshTripSelect(){ const sel=$('#tripSelect'); const opts=Object.values(state.trips).sort((a,b)=>{ const ad=(b.header && b.header.date) || ''; const bd=(a.header && a.header.date) || ''; return ad.localeCompare(bd); }); sel.innerHTML = opts.map(t=>`<option value="${t.id}">${(t.header && t.header.date)||'(no date)'} • ${ (t.header && t.header.port) || 'Port'}</option>`).join(''); }
  function saveHeader(){ const id=currentTripId()||uid(); state.trips[id]=state.trips[id]||{id, header:{}, entries:[], createdAt:Date.now(), updatedAt:Date.now()}; state.trips[id].header={ date:$('#tripDate').value, startTime:$('#startTime').value, port:$('#port').value, boat:$('#boat').value, crew:$('#crew').value, hours:$('#hours').value, airTemp:$('#airTemp').value, surfaceTemp:$('#surfaceTemp').value, wind:$('#wind').value, waves:$('#waves').value, clouds:$('#clouds').value }; state.trips[id].updatedAt=Date.now(); save(); refreshTripSelect(); $('#tripSelect').value=id; alert('Trip header saved.'); }
  // (Removed duplicate event listeners for #saveTrip, #newTrip, #tripSelect)
  function loadHeaderIntoForm(){ const t=state.trips[currentTripId()]; if(!t) return; const h=t.header||{}; $('#tripDate').value=h.date||''; $('#startTime').value=h.startTime||''; $('#port').value=h.port||''; $('#boat').value=h.boat||''; $('#crew').value=h.crew||''; $('#hours').value=h.hours||''; $('#airTemp').value=h.airTemp||''; $('#surfaceTemp').value=h.surfaceTemp||''; $('#wind').value=h.wind||''; $('#waves').value=h.waves||''; $('#clouds').value=h.clouds||''; }
  // (Removed duplicate event listener for #platform)
    function setNow(){ const d=new Date(); $('#time').value=d.toTimeString().slice(0,5); if(!$('#tripDate').value) $('#tripDate').value=d.toISOString().slice(0,10); if(!$('#startTime').value) $('#startTime').value=d.toTimeString().slice(0,5); }
  // (Removed duplicate event listener for #nowBtn)
  setNow();
  const photoInput = $('#photoInput'); const photoPreview = $('#photoPreview'); const clearPhotoBtn = $('#clearPhoto'); let pendingPhotoDataURL='';
  function fileToDataURLResized(file, maxDim=1600, quality=0.82){ return new Promise((resolve,reject)=>{ const fr=new FileReader(); fr.onload=()=>{ const img=new Image(); img.onload=()=>{ const c=document.createElement('canvas'); let w=img.width,h=img.height; const scale=Math.min(1, maxDim/Math.max(w,h)); const nw=Math.max(1,Math.round(w*scale)), nh=Math.max(1,Math.round(h*scale)); c.width=nw; c.height=nh; c.getContext('2d').drawImage(img,0,0,nw,nh); try{ resolve(c.toDataURL('image/jpeg', quality)); }catch(e){ reject(e); } }; img.onerror=reject; img.src=fr.result; }; fr.onerror=reject; fr.readAsDataURL(file); }); }
  function readVal(id){ const el=document.querySelector(id); return (el && el.value || '').trim(); } function num(x){ return x?Number(x):''; }
  function computeTs(header, timeStr){ if(header && header.date && timeStr){ const ds=header.date+'T'+timeStr+':00'; const d=new Date(ds); if(!isNaN(d)) return d.getTime(); } return Date.now(); }
    let editingEntryId=null; let undoTimer=null; let pendingDelete=null; const UNDO_MS=12000;
    function setEditing(on){ editingEntryId = on?editingEntryId:null; $('#cancelEdit').style.display = on?'inline-block':'none'; $('#addEntry').textContent = on?'Update entry':'Save entry'; }
    function validateEntry(isQuick){ const req=[]; const time=readVal('#time'); const platform=readVal('#platform'); const species=readVal('#species'); const lureType=readVal('#lureType'); const water=readVal('#waterDepth'); const target=readVal('#targetDepth'); if(!time) req.push('#time'); if(!platform) req.push('#platform'); if(!species) req.push('#species'); if(!lureType) req.push('#lureType'); if(!water && !target) { req.push('#waterDepth'); req.push('#targetDepth'); }
      $$('#tab-log input, #tab-log select').forEach(el=> el.classList.remove('invalid')); req.forEach(sel=>{ const el=$(sel); if(el) el.classList.add('invalid'); }); return { ok: req.length===0, missing:req };
    }
    async function addOrUpdateEntry(force=false){ const t=state.trips[ensureTrip()]; const header=t.header; const quick=state.settings.quickMode; const v=validateEntry(quick); if(!v.ok && !force){ $('#forceSave').style.display='inline-block'; toast('Missing required fields. Fill red or tap Force.'); return; } $('#forceSave').style.display='none'; const base={ id: editingEntryId||uid(), time:readVal('#time'), platform:readVal('#platform'), trollDir:readVal('#trollDir'), waterDepth:num(readVal('#waterDepth')), ballDepth:num(readVal('#ballDepth')), ballWeight:num(readVal('#ballWeight')), dipsySize:readVal('#dipsySize'), dipsySetting:readVal('#dipsySetting'), copperLen:num(readVal('#copperLen')), leadcoreColors:readVal('#leadcoreColors'), targetDepth:num(readVal('#targetDepth')), lineOut:num(readVal('#lineOut')), lineType:readVal('#lineType'), lineStrength:num(readVal('#lineStrength')), leaderLen:num(readVal('#leaderLen')), lureType:readVal('#lureType'), lureBrand:readVal('#lureBrand'), lureSize:readVal('#lureSize'), lureColor:readVal('#lureColor'), attractor:readVal('#attractor'), flyMeat:readVal('#flyMeat'), speedBall:num(readVal('#speedBall')), sog:num(readVal('#sog')), strikeDepthSeen:num(readVal('#strikeDepthSeen')), species:readVal('#species'), lengthIn:num(readVal('#lengthIn')), weightLb:num(readVal('#weightLb')), keptRel:readVal('#keptRel')||'Kept', landed:readVal('#landedYN'), hookLoc:readVal('#hookLoc'), gps:readVal('#gps'), notes:readVal('#notes'), photo:false };
      if(!base.keptRel) base.keptRel='Kept'; if(!base.time) setNow(); base.ts = computeTs(header, base.time); if(pendingPhotoDataURL){ try{ await savePhoto(base.id, pendingPhotoDataURL); base.photo=true; }catch(e){ alert('Could not save photo: '+e.message); } }
      if(editingEntryId){ const idx=t.entries.findIndex(e=>e.id===editingEntryId); if(idx>-1){ const existingPhoto=t.entries[idx].photo; if(existingPhoto && !base.photo) base.photo=true; t.entries[idx]=Object.assign({}, t.entries[idx], base); toast('Entry updated'); }
      } else { t.entries.push(base); if(state.settings.sticky){ // keep lure fields
          ['lureType','lureBrand','lureSize','lureColor','attractor','flyMeat','lineType','lineStrength'].forEach(id=>{/*sticky implies leave value*/});
        } else { /* will clear below */ }
      }
      t.updatedAt=Date.now(); save(); renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge(); if(editingEntryId){ setEditing(false); clearCatchForm(false); } else { clearCatchForm(!state.settings.sticky); }
    }
  function clearCatchForm(clearSticky){ $$('#tab-log input, #tab-log textarea, #tab-log select').forEach(el=>{ if(['time'].includes(el.id)) { setNow(); return; } if(!clearSticky && ['lureType','lureBrand','lureSize','lureColor','attractor','flyMeat','lineType','lineStrength'].includes(el.id)) return; if(['platform','trollDir','species','keptRel','landedYN','hookLoc','waterDepth','targetDepth'].includes(el.id)) { el.value=''; } else if(el.tagName==='TEXTAREA' || el.tagName==='INPUT' || el.tagName==='SELECT'){ el.value=''; } }); $('#keptRel').value='Kept'; $$('.cond').forEach(x=>x.classList.add('hide')); pendingPhotoDataURL=''; photoInput.value=''; photoPreview.classList.add('hide'); photoPreview.src=''; }
  // (Removed duplicate event listener for #resetForm)
  async function renderEntries(){ const t=state.trips[currentTripId()]; const tbody=$('#entriesTable tbody'); if(!t){ tbody.innerHTML=''; return; } const rows=await Promise.all(t.entries.map(async e=>{ const lure=[e.lureType,e.lureBrand,e.lureColor].filter(Boolean).join(' • '); const depths=[`W:${e.waterDepth||'-'}`,`T:${e.targetDepth||'-'}`,(e.platform==='Downrigger'?`B:${e.ballDepth||'-'}`:'')].filter(Boolean).join(' / '); const dirSpd=[e.trollDir, e.speedBall?`${e.speedBall} mph`:''].filter(Boolean).join(' • '); const wl=[e.landed||'-', e.keptRel||'-'].join('/'); let photoCell=''; if(e.photo){ const durl=await getPhoto(e.id); photoCell = durl ? `<img src="${durl}" class="thumb" alt="thumb" data-view="${e.id}"/>` : '📷'; } else { photoCell=''; } return `<tr><td>${e.time||''}</td><td><span class="pill badge">${e.platform||''}</span></td><td>${photoCell}</td><td>${lure}</td><td>${depths}</td><td>${dirSpd}</td><td>${e.species||''}</td><td>${wl}</td><td style="text-align:right;white-space:nowrap"><button class="btn secondary" data-edit="${e.id}">Edit</button> <button class="btn secondary" data-viewbtn="${e.id}">View</button> <button class="btn secondary" data-del="${e.id}">Delete</button></td></tr>`; })); tbody.innerHTML = rows.join(''); $$('button[data-del]').forEach(b=> b.onclick = ()=>{ delEntry(b.dataset.del); }); $$('button[data-viewbtn]').forEach(b=> b.onclick = ()=>{ openLightbox(b.dataset.viewbtn); }); $$('button[data-edit]').forEach(b=> b.onclick = ()=>{ startEdit(b.dataset.edit); }); $$('img[data-view]').forEach(img=> img.onclick = ()=>{ openLightbox(img.dataset.view); }); }
  function loadEntryIntoForm(e, duplicate=false){ ['time','platform','trollDir','waterDepth','ballDepth','ballWeight','dipsySize','dipsySetting','copperLen','leadcoreColors','targetDepth','lineOut','lineType','lineStrength','leaderLen','lureType','lureBrand','lureSize','lureColor','attractor','flyMeat','speedBall','sog','strikeDepthSeen','species','lengthIn','weightLb','keptRel','landedYN','hookLoc','gps','notes'].forEach(id=>{ const el=$('#'+id); if(el && e[id.replace('landedYN','landed')]) el.value = e[id.replace('landedYN','landed')] ?? ''; }); if(e.platform) $('#platform').dispatchEvent(new Event('change')); if(!duplicate){ editingEntryId=e.id; setEditing(true); pendingPhotoDataURL=''; photoPreview.classList.add('hide'); photoPreview.src=''; } }
  function startEdit(id){ const t=state.trips[currentTripId()]; if(!t) return; const e=t.entries.find(x=>x.id===id); if(!e) return; loadEntryIntoForm(e,false); toast('Editing entry'); }
  async function delEntry(id){ const t=state.trips[currentTripId()]; if(!t) return; const e=t.entries.find(x=>x.id===id); if(!e) return; const photoData = e.photo ? await getPhoto(e.id) : null; t.entries = t.entries.filter(x=>x.id!==id); save(); renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge(); scheduleUndo({ entry:e, photo:photoData }); }
  function scheduleUndo(payload){ pendingDelete=payload; showUndo(); if(undoTimer) clearTimeout(undoTimer); undoTimer=setTimeout(()=>{ finalizeDelete(); }, UNDO_MS); }
  function finalizeDelete(){ if(!pendingDelete) return; if(pendingDelete.entry.photo){ deletePhoto(pendingDelete.entry.id).catch(()=>{}); } pendingDelete=null; hideToast(); }
  function undoDelete(){ if(!pendingDelete) return; const t=state.trips[currentTripId()]; if(!t){ pendingDelete=null; return; } t.entries.push(pendingDelete.entry); save(); renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge(); pendingDelete=null; hideToast(); toast('Restored'); }
    async function openLightbox(entryId){ const durl = await getPhoto(entryId); if(!durl){ alert('No photo for this entry.'); return; } $('#lightboxImg').src=durl; $('#lightbox').classList.remove('hide'); }
  // lightbox handlers are attached inside DOMContentLoaded above (guarded). Duplicate handlers removed.
    function renderSummary(){ const t=state.trips[currentTripId()]; const box=$('#summary'); if(!t||!t.entries.length){ box.innerHTML='<span class="muted">No entries yet.</span>'; return; } const h=t.header||{}; const n=t.entries.length; const landed=t.entries.filter(e=>e.landed==='Y').length; const kept=t.entries.filter(e=>e.keptRel==='Kept').length; const bestWaterDepth=mode(t.entries.map(e=>e.waterDepth).filter(Number.isFinite)); const bestTargetDepth=mode(t.entries.map(e=>e.targetDepth).filter(Number.isFinite)); const bestLureType=mode(t.entries.map(e=>e.lureType).filter(Boolean)); const bestColor=mode(t.entries.map(e=>e.lureColor).filter(Boolean)); const bestDir=mode(t.entries.map(e=>e.trollDir).filter(Boolean)); const lengths=t.entries.map(e=>e.lengthIn).filter(Number.isFinite); const weights=t.entries.map(e=>e.weightLb).filter(Number.isFinite); const avg=(arr)=> (arr.length? (arr.reduce((a,b)=>a+b,0)/arr.length).toFixed(1):''); const chips=[`Date: <b>${h.date||'-'}</b>`,`Port: <b>${h.port||'-'}</b>`,`Crew: <b>${h.crew||'-'}</b>`,`Entries: <b>${n}</b>`,`Landed: <b>${landed}</b>`,`Kept: <b>${kept}</b>`,`Best water depth: <b>${bestWaterDepth||'-'}</b>`,`Best target depth: <b>${bestTargetDepth||'-'}</b>`,`Best direction: <b>${bestDir||'-'}</b>`,`Best lure: <b>${bestLureType||'-'}</b>`,`Best color: <b>${bestColor||'-'}</b>`]; if(lengths.length>=2) chips.push(`Avg length: <b>${avg(lengths)} in</b>`); if(weights.length>=2) chips.push(`Avg weight: <b>${avg(weights)} lb</b>`); box.innerHTML='<div class="grid cols-3">'+chips.map(c=>`<div class="chip">${c}</div>`).join('')+'</div>'; }
  function updateLogBadge(){ const t=state.trips[currentTripId()]; const badge=$('#logCountBadge'); if(!badge) return; const n=(t && t.entries && t.entries.length) || 0; if(n){ badge.style.display='inline-block'; badge.textContent=n; } else { badge.style.display='none'; } }
    function renderAnalytics(){ const t=state.trips[currentTripId()]; const box=$('#analytics'); if(!box) return; if(!t||!t.entries.length){ box.innerHTML='(No data)'; return; } const entries=t.entries.slice(); const countBy=(k)=>{ const m={}; entries.forEach(e=>{ const v=e[k]; if(!v) return; m[v]=(m[v]||0)+1; }); return Object.entries(m).sort((a,b)=>b[1]-a[1]); }; const top=(arr,n=3)=>arr.slice(0,n).map(([k,v])=>`${k} (${v})`).join(', '); const platforms=countBy('platform'); const species=countBy('species'); const lureTypes=countBy('lureType'); const colors=countBy('lureColor'); // depth buckets 10 ft
      function bucket(arr){ const m={}; arr.filter(Number.isFinite).forEach(v=>{ const b=Math.floor(v/10)*10; const label=`${b}-${b+9}`; m[label]=(m[label]||0)+1; }); return Object.entries(m).sort((a,b)=>{ const na=parseInt(a[0]); const nb=parseInt(b[0]); return na-nb; }); }
      const wdBuckets=bucket(entries.map(e=>e.waterDepth)); const tdBuckets=bucket(entries.map(e=>e.targetDepth)); // timeline 15 min
      const timeline=(()=>{ const pts=entries.filter(e=>e.ts); if(!pts.length) return []; const min=Math.min(...pts.map(e=>e.ts)); const max=Math.max(...pts.map(e=>e.ts)); const span=15*60*1000; const buckets=[]; for(let tms=Math.floor(min/span)*span; tms<=max; tms+=span){ buckets.push({ t:tms, c:0 }); } pts.forEach(e=>{ const idx=Math.floor((e.ts - buckets[0].t)/span); if(buckets[idx]) buckets[idx].c++; }); return buckets; })();
      const spark=timeline.map(b=>`<div class="spark" style="width:6px;height:${4+Math.min(30,b.c*6)}px" title="${new Date(b.t).toTimeString().slice(0,5)}: ${b.c}"></div>`).join('');
      const fmtList=(list)=> list.map(([k,v])=>`${k}: <b>${v}</b>`).join(' • ');
      box.innerHTML=`<h4>Platforms</h4>${fmtList(platforms)||'-'}<h4>Species</h4>${fmtList(species)||'-'}<h4>Lure Types (Top)</h4>${top(lureTypes)||'-'}<h4>Colors (Top)</h4>${top(colors)||'-'}<h4>Water Depth (10s)</h4>${wdBuckets.map(([k,v])=>`${k}: <b>${v}</b>`).join(' • ')||'-'}<h4>Target Depth (10s)</h4>${tdBuckets.map(([k,v])=>`${k}: <b>${v}</b>`).join(' • ')||'-'}<h4>Timeline 15m</h4><div style="display:flex;align-items:flex-end;height:50px;">${spark}</div>`;
    }
    function mode(arr){ if(!arr.length) return ''; const map=new Map(); arr.forEach(v=>map.set(v,(map.get(v)||0)+1)); let m='',c=0; map.forEach((n,k)=>{ if(n>c){c=n;m=k;} }); return m; }
    function toCsvRow(fields){ return fields.map(v=>{ if(v===null||v===undefined) v=''; v=String(v); if(/[",\n]/.test(v)) v='"'+v.replace(/"/g,'""')+'"'; return v; }).join(','); }
  async function exportCsv(){ const t=state.trips[currentTripId()]; if(!t) return alert('No trip.'); const h=['TripDate','Time','Timestamp','PortArea','GPS_Lat','GPS_Lon','Waypoint','WaterDepth_ft','SurfaceTemp_F','Platform','RodPosition','LineType','LineStrength_lb','LineLengthOut_ft','DipsySize','DipsySetting','RiggerBallWeight_lb','RiggerBallDepth_ft','TargetDepth_ft','StrikeDepthSeen_ft','SpeedAtBall_mph','SOG_mph','TrollDirection','LureType','LureBrand','LureModel','LureSize','LureColor','LeaderLength_ft','Attractor/Flasher','Fly/MeatColor','Species','Length_in','Weight_lb','KeptOrReleased','HookLocation','Landed_YN','FightTime_min','Notes','HasPhoto']; const lines=[toCsvRow(h)]; const hdr=t.header||{};
    for(const e of t.entries){
      const parts=(e.gps||'').split(',');
      const lat=(parts[0] && parts[0].trim())||'';
      const lon=(parts[1] && parts[1].trim())||'';
      const row=[
        hdr.date||'',             // TripDate
        e.time||'',               // Time
        e.ts||'',                 // Timestamp
        hdr.port||'',             // PortArea
        lat||'',                  // GPS_Lat
        lon||'',                  // GPS_Lon
        '',                       // Waypoint
        e.waterDepth||'',         // WaterDepth_ft (inserted)
        hdr.surfaceTemp||'',      // SurfaceTemp_F
        e.platform||'',           // Platform
        '',                       // RodPosition
        e.lineType||'',           // LineType
        e.lineStrength||'',       // LineStrength_lb
        e.lineOut||'',            // LineLengthOut_ft
        e.dipsySize||'',          // DipsySize
        e.dipsySetting||'',       // DipsySetting
        e.ballWeight||'',         // RiggerBallWeight_lb
        e.ballDepth||'',          // RiggerBallDepth_ft
        e.targetDepth||'',        // TargetDepth_ft
        e.strikeDepthSeen||'',    // StrikeDepthSeen_ft
        e.speedBall||'',          // SpeedAtBall_mph
        e.sog||'',                // SOG_mph
        e.trollDir||'',           // TrollDirection
        e.lureType||'',           // LureType
        e.lureBrand||'',          // LureBrand
        '',                       // LureModel
        e.lureSize||'',           // LureSize
        e.lureColor||'',          // LureColor
        e.leaderLen||'',          // LeaderLength_ft
        e.attractor||'',          // Attractor/Flasher
        e.flyMeat||'',            // Fly/MeatColor
        e.species||'',            // Species
        e.lengthIn||'',           // Length_in
        e.weightLb||'',           // Weight_lb
        e.keptRel||'',            // KeptOrReleased
        e.hookLoc||'',            // HookLocation
        e.landed||'',             // Landed_YN
        '',                       // FightTime_min
        e.notes||'',              // Notes
        e.photo?'Y':'N'           // HasPhoto
      ];
      lines.push(toCsvRow(row));
    }
    download('catches_'+(hdr.date||'trip')+'.csv', lines.join('\n'));
  }
  async function exportJson(){ const id=currentTripId(); if(!id) return alert('No trip.'); const t=state.trips[id]; const photos={}; for(const e of t.entries){ if(e.photo){ photos[e.id]=await getPhoto(e.id); } } const out=Object.assign({}, t, { photos: photos, exportVersion:2 }); const fname='trip_'+(((t.header && t.header.date) || id))+'.json'; download(fname, JSON.stringify(out,null,2)); }
  async function exportAlbum(){ const id=currentTripId(); if(!id) return alert('No trip.'); const t=state.trips[id]; const photos=[]; for(const e of t.entries){ if(e.photo){ photos.push({id:e.id, time:e.time, species:e.species, lure:[e.lureType,e.lureBrand,e.lureColor].filter(Boolean).join(' • '), durl: await getPhoto(e.id)}); } } const tripDate = (t.header && t.header.date) || 'trip'; const html='<!doctype html><meta charset="utf-8"><title>Album '+tripDate+'</title><style>body{font-family:system-ui;background:#0e131b;color:#e8eefb;margin:0;padding:16px}h1{font-size:20px} .g{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px} figure{margin:0;background:#151b26;border:1px solid #243349;border-radius:12px;overflow:hidden} img{width:100%;height:200px;object-fit:cover;display:block} figcaption{padding:8px 10px;font-size:12px;color:#b9c9e3} </style><h1>Trip '+tripDate+'</h1><div class="g">'+photos.map(p=>'<figure><img src="'+p.durl+'"><figcaption>'+ (p.time||'') +' • '+ (p.species||'') +'<br>'+ (p.lure||'') +'</figcaption></figure>').join('')+'</div>'; download('album_'+tripDate+'.html', html); }
  // Push trip summary to Google Sheets Web App (Apps Script). Requires settings: sheetWebAppUrl and sheetSecret
  async function pushTripToSheet(){ const id=currentTripId(); if(!id) return alert('No trip selected'); const t=state.trips[id]; const hdr=t.header||{}; let url = (state.settings && state.settings.sheetWebAppUrl) ? state.settings.sheetWebAppUrl.trim() : ''; let secret = (state.settings && state.settings.sheetSecret) ? state.settings.sheetSecret.trim() : ''; // defensive fallback: read directly from form if state wasn't persisted
    if(!url) url = (readVal('#sheetWebAppUrl') || '').trim(); if(!secret) secret = (readVal('#sheetSecret') || '').trim(); if(!url) return toast('Set Sheet Web App URL in Settings first');
    const payload = {
      secret: secret || '',
      tripDate: hdr.date || '',
      time: hdr.startTime || '',
      port: hdr.port || '',
      gpsLat: hdr.lastLat || '',
      gpsLon: hdr.lastLon || '',
      waterDepth: hdr.bestWaterDepth || '',
      surfaceTemp: hdr.surfaceTemp || '',
      notes: hdr.notes || ''
    };
    try{
      const r = await fetch(url, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
      if(!r.ok) { toast('Push failed: HTTP '+r.status); console.warn('pushTripToSheet failed', r.status); return; }
      const js = await r.json().catch(()=>null);
      if(js && js.ok) { toast('Trip pushed to Google Sheet'); } else { toast('Push completed; server response: '+(js && js.error? js.error : 'unknown')); }
    }catch(e){ console.warn('pushTripToSheet error', e); toast('Network error while pushing trip'); }
  }
  attach('#pushToSheet','click', ()=>{ pushTripToSheet(); });
  // Push full trip: send the entire trip (header + entries) in one POST.
  // Server (Apps Script) should accept payload.trip and append rows server-side.
  async function pushFullTrip(){
    const id = currentTripId(); if(!id) return alert('No trip selected');
    const t = state.trips[id]; const hdr = t.header || {};
    let url = (state.settings && state.settings.sheetWebAppUrl) ? state.settings.sheetWebAppUrl.trim() : '';
    let secret = (state.settings && state.settings.sheetSecret) ? state.settings.sheetSecret.trim() : '';
    // defensive fallback: read directly from form if state wasn't persisted
    if(!url) url = (readVal('#sheetWebAppUrl') || '').trim(); if(!secret) secret = (readVal('#sheetSecret') || '').trim();
    if(!url) return toast('Set Sheet Web App URL in Settings first');
    toast('Pushing full trip (single request)...');
    const payload = { secret: secret || '', trip: t };
    try{
      const r = await fetch(url, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
      if(!r.ok){ console.warn('pushFullTrip failed HTTP', r.status); // try no-cors fallback
        try{
          await fetch(url, { method:'POST', mode:'no-cors', body: JSON.stringify(payload) });
          toast('Push attempted (no-cors fallback). Check sheet.');
          return;
        }catch(nc){ console.warn('no-cors fallback failed', nc); toast('Push failed: HTTP '+r.status); return; }
      }
      const js = await r.json().catch(()=>null);
      if(js && js.ok){ toast('Full trip pushed (server appended rows)'); }
      else { toast('Push completed; server response: '+(js && js.error? js.error : 'unknown')); }
    }catch(err){
      console.warn('pushFullTrip network error', err);
      // try no-cors fallback as last resort
      try{
        await fetch(url, { method:'POST', mode:'no-cors', body: JSON.stringify(payload) });
        toast('Push attempted (no-cors fallback). Check sheet.');
      }catch(nc){
        console.warn('no-cors fallback failed', nc);
        toast('Network/CORS error while pushing full trip');
      }
    }
  }
  attach('#pushFullTrip','click', ()=>{ pushFullTrip(); });
    
  // Google Sheets / Drive upload helpers removed (app is local-only per user request)
    function download(name, content){ const blob=new Blob([content], {type:'text/plain;charset=utf-8'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1000); }
  attach('#exportCsv','click', exportCsv);
    attach('#addToHome','click', ()=>{ alert('Add to Home Screen:\n\n• iPhone (Safari): Share ▸ Add to Home Screen.\n• Android (Chrome): ⋮ menu ▸ Add to Home screen.\n\nThis runs offline and saves to your device.'); });
    function migrate(){ if(!state.dataVersion){ state.dataVersion=3; }
      // Add ts to entries if missing
      Object.values(state.trips||{}).forEach(trip=>{ (trip.entries||[]).forEach(e=>{ if(!e.ts){ const ts=computeTs(trip.header, e.time); e.ts=ts; } }); });
      save(); }
  function initPrefs(){ $('#prefQuickDefault').checked = !!(state.settings && state.settings.quickMode); $('#prefSticky').checked = ((state.settings && state.settings.sticky) !== false); }
  function savePrefs(){ state.settings = state.settings || {}; state.settings.quickMode = $('#prefQuickDefault').checked; state.settings.sticky = $('#prefSticky').checked; const mj = ($('#marineJsonUrl') && $('#marineJsonUrl').value) ? $('#marineJsonUrl').value.trim() : ''; state.settings.marineJsonUrl = mj; const st = ($('#stationJsonTemplate') && $('#stationJsonTemplate').value) ? $('#stationJsonTemplate').value.trim() : ''; state.settings.stationJsonTemplate = st; save(); toast('Preferences saved'); applyQuickMode(); }
  attach('#savePrefs','click', savePrefs);
  // persist sheet web app settings when saving prefs
  function loadSheetPrefsIntoForm(){ try{ const el = $('#sheetWebAppUrl'); if(el) el.value = (state.settings && state.settings.sheetWebAppUrl) || ''; }catch(e){} try{ const s = $('#sheetSecret'); if(s) s.value = (state.settings && state.settings.sheetSecret) || ''; }catch(e){} }
  // update savePrefs to persist new fields
  const _oldSavePrefs = savePrefs;
  savePrefs = function(){ _oldSavePrefs(); state.settings.sheetWebAppUrl = ($('#sheetWebAppUrl') && $('#sheetWebAppUrl').value) ? $('#sheetWebAppUrl').value.trim() : ''; state.settings.sheetSecret = ($('#sheetSecret') && $('#sheetSecret').value) ? $('#sheetSecret').value.trim() : ''; save(); toast('Preferences saved'); };
  // reattach handler so the button invokes the updated savePrefs wrapper
  attach('#savePrefs','click', savePrefs);
    function applyQuickMode(){ const quick = state.settings.quickMode; $('#quickToggle').textContent = 'Quick Mode: '+(quick?'On':'Off'); const essential = new Set(['time','platform','species','lureType','waterDepth','targetDepth','keptRel','landedYN']); $$('#tab-log .grid > div').forEach(div=>{ const input=div.querySelector('input,select,textarea'); if(!input) return; if(essential.has(input.id)) { div.classList.remove('quick-hidden'); } else { if(quick) div.classList.add('quick-hidden'); else div.classList.remove('quick-hidden'); } }); }
  attach('#quickToggle','click', ()=>{ state.settings.quickMode=!state.settings.quickMode; save(); applyQuickMode(); });
    function toast(msg, undo=false){ const el=$('#toast'); el.innerHTML = msg + (undo? ' <button class="btn secondary" id="undoBtn">Undo</button>':''); el.style.display='block'; if(undo){ setTimeout(()=>{ const b=$('#undoBtn'); if(b) b.onclick=()=>{ undoDelete(); }; },0);} }
    function hideToast(){ const el=$('#toast'); el.style.display='none'; }
    function showUndo(){ toast('Entry deleted', true); }
    function init(){ fillAllSelects(); listsToTextarea(); refreshTripSelect(); if(!currentTripId() && Object.keys(state.trips).length===0){ const id=uid(); state.trips[id]={id, header:{}, entries:[], createdAt:Date.now(), updatedAt:Date.now()}; save(); refreshTripSelect(); $('#tripSelect').value=id; } migrate(); initPrefs(); // load marine JSON URL into the settings input
    try{ const el = $('#marineJsonUrl'); if(el) el.value = (state.settings && state.settings.marineJsonUrl) || ''; }catch(e){}
  try{ const st = $('#stationJsonTemplate'); if(st) st.value = (state.settings && state.settings.stationJsonTemplate) || 'https://blfl-ndbc-proxy.elliottdanielp.workers.dev/stations/{station}.json'; }catch(e){}
    // load sheet prefs
    try{ loadSheetPrefsIntoForm(); }catch(e){}
        // load stations list (for nearest NDBC station lookup)
        try{
          fetch('stations.json', { cache: 'no-store' }).then(r=>r.json()).then(js=>{ window.__stations = js || [] }).catch(()=>{ window.__stations = []; });
        }catch(e){ window.__stations = []; }
      loadHeaderIntoForm(); applyQuickMode(); updateLogBadge(); }
  attach('#prefSticky','change', ()=>{ /* immediate reflection not needed */ });
  attach('#prefQuickDefault','change', ()=>{ /* just state toggle on save */ });
    $('#keptRel').value='Kept';
    attach('#quickToggle','dblclick', ()=>{ // quick clear validation marks
      $$('#tab-log .invalid').forEach(el=>el.classList.remove('invalid')); });
    init();
  // Download button triggers the Catch Conditions flow (useful reminder)
  // Use guarded attaches for photo input, clear photo and downloadConditions
  attach('#photoInput', 'change', async () => { const input = document.querySelector('#photoInput'); const f = (input && input.files && input.files[0]); if(!f){ pendingPhotoDataURL=''; if(photoPreview) { photoPreview.classList.add('hide'); photoPreview.src=''; } return; } try{ pendingPhotoDataURL = await fileToDataURLResized(f); if(photoPreview){ photoPreview.src = pendingPhotoDataURL; photoPreview.classList.remove('hide'); } } catch(err){ alert('Photo error: '+err.message); } });
  attach('#clearPhoto', 'click', ()=>{ pendingPhotoDataURL=''; const input = document.querySelector('#photoInput'); if(input) input.value=''; if(photoPreview){ photoPreview.classList.add('hide'); photoPreview.src=''; } });
  // Test station template fetch button (settings area)
  attach('#testStationJson','click', async ()=>{
    try{
      const tpl = ($('#stationJsonTemplate') && $('#stationJsonTemplate').value) ? $('#stationJsonTemplate').value.trim() : '';
      if(!tpl){ toast('Set station JSON template first in Preferences'); return; }
      // pick nearest station if available
      const stations = window.__stations || [];
      let nearest = stations[0] || null;
      if(stations.length && ('geolocation' in navigator)){
        navigator.geolocation.getCurrentPosition(async pos=>{
          const lat = pos.coords.latitude, lon = pos.coords.longitude;
          const toR = n => n * Math.PI / 180;
          const hav = (a,b)=>{ const R=6371; const dLat=toR(b.lat-a.lat); const dLon=toR(b.lon-a.lon); const la=toR(a.lat), lb=toR(b.lat); const h = Math.sin(dLat/2)**2 + Math.cos(la)*Math.cos(lb)*Math.sin(dLon/2)**2; return 2*R*Math.asin(Math.sqrt(h)); };
          let best=null, bestD=Infinity; stations.forEach(s=>{ const d = hav({lat,lon}, {lat:s.lat, lon:s.lon}); if(d<bestD){ bestD=d; best=s; } }); if(best) nearest = best;
          const url = tpl.replace('{station}', encodeURIComponent(nearest.id)).replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
          try{
            const r = await fetch(url, { cache: 'no-store' }); if(!r.ok){ toast('Fetch failed: '+r.status); console.warn('station fetch failed', r.status, url); return; } const js = await r.json(); toast('Station JSON fetched OK'); console.log('station JSON', js);
          }catch(e){ toast('Fetch error (see console)'); console.warn('station fetch error', e); }
        }, err=>{ toast('Geolocation failed: '+(err && err.message)); console.warn('geolocation failed', err); });
      } else {
        try{
          const url = tpl.replace('{station}', encodeURIComponent(nearest && nearest.id || ''));
          const r = await fetch(url, { cache: 'no-store' }); if(!r.ok){ toast('Fetch failed: '+r.status); console.warn('station fetch failed', r.status, url); return; } const js = await r.json(); toast('Station JSON fetched OK'); console.log('station JSON', js);
        }catch(e){ toast('Fetch error (see console)'); console.warn('station fetch error', e); }
      }
    }catch(e){ toast('Test failed'); console.warn('testStationJson failed', e); }
  });
  attach('#debugStationJson','click', async ()=>{
    try{
      const tpl = ($('#stationJsonTemplate') && $('#stationJsonTemplate').value) ? $('#stationJsonTemplate').value.trim() : '';
      if(!tpl){ toast('Set station JSON template first in Preferences'); return; }
      const stations = window.__stations || [];
      let nearest = stations[0] || null;
      if(stations.length && ('geolocation' in navigator)){
        navigator.geolocation.getCurrentPosition(async pos=>{
          const lat = pos.coords.latitude, lon = pos.coords.longitude;
          const toR = n => n * Math.PI / 180;
          const hav = (a,b)=>{ const R=6371; const dLat=toR(b.lat-a.lat); const dLon=toR(b.lon-a.lon); const la=toR(a.lat), lb=toR(b.lat); const h = Math.sin(dLat/2)**2 + Math.cos(la)*Math.cos(lb)*Math.sin(dLon/2)**2; return 2*R*Math.asin(Math.sqrt(h)); };
          let best=null, bestD=Infinity; stations.forEach(s=>{ const d = hav({lat,lon}, {lat:s.lat, lon:s.lon}); if(d<bestD){ bestD=d; best=s; } }); if(best) nearest = best;
          const url = tpl.replace('{station}', encodeURIComponent(nearest.id)).replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
          const debugUrl = url + (url.includes('?')? '&' : '?') + 'debug=1&prefer=ocean-spec';
          try{
            const r = await fetch(debugUrl, { cache: 'no-store' });
            const js = await r.json();
            console.log('debug station response', js);
            if(js && js.raw){ toast('Raw data returned; see console'); } else if(js && (js.sstC!==undefined || js.waveM!==undefined)){ toast('Parsed station data returned; see console'); } else { toast('No usable data; see console'); }
          }catch(e){ toast('Debug fetch failed (see console)'); console.warn('debug fetch error', e); }
        }, err=>{ toast('Geolocation failed: '+(err && err.message)); console.warn('geolocation failed', err); });
      } else {
        try{
          const url = tpl.replace('{station}', encodeURIComponent(nearest && nearest.id || ''));
          const debugUrl = url + (url.includes('?')? '&' : '?') + 'debug=1&prefer=ocean-spec';
          const r = await fetch(debugUrl, { cache: 'no-store' });
          const js = await r.json();
          console.log('debug station response', js);
          if(js && js.raw){ toast('Raw data returned; see console'); } else if(js && (js.sstC!==undefined || js.waveM!==undefined)){ toast('Parsed station data returned; see console'); } else { toast('No usable data; see console'); }
        }catch(e){ toast('Debug fetch failed (see console)'); console.warn('debug fetch error', e); }
      }
    }catch(e){ toast('Debug failed'); console.warn('debugStationJson failed', e); }
  });
  attach('#downloadConditions','click', ()=>{ if($('#fetchConditions')) $('#fetchConditions').click(); });
    // Register service worker for offline support (if available)
    if ('serviceWorker' in navigator) {
      // use relative path so it works on GitHub Pages project pages
      navigator.serviceWorker.register('service-worker.js').then(reg => {
        console.log('ServiceWorker registered:', reg.scope);
      }).catch(err => {
        console.warn('ServiceWorker registration failed:', err);
      });
    }
  </script>
</body>
</html>
