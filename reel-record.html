<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
	<title>Big Lake Fishing Log</title>
	<link rel="manifest" href="manifest.json">
	<link rel="icon" href="favicon.ico">
	<link rel="icon" type="image/svg+xml" href="favicon.svg">
	<link rel="apple-touch-icon" href="icon-192.png">
	<style>
		:root { --bg:#0e131b; --card:#151b26; --ink:#e8eefb; --muted:#9fb0c8; --accent:#52a7ff; --accent-2:#2ed0a2; --danger:#ff6b6b; --warning:#ffd166; --good:#06d6a0; --shadow:rgba(0,0,0,.35); --radius:18px; }
		html, body { height:100%; } body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,sans-serif; background:var(--bg); color:var(--ink); }
		.wrap { max-width: 880px; margin:0 auto; padding: 8px; }
	/* Brand header: full-width bar with rounded bottom and centered title + tagline */
	header { position: sticky; top:0; z-index: 30; background: linear-gradient(180deg,#0b2944,#0e1a2a); backdrop-filter: blur(6px); border-bottom: none; border-radius: 0 0 14px 14px; box-shadow: 0 6px 20px rgba(0,0,0,0.45); }
	.bar { display:flex; gap:8px; align-items:center; padding: 14px 12px; }
	.title-container { display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; width:100%; }
	.title { font-weight:900; letter-spacing:0.6px; font-size:26px; color: #eaf6ff; text-shadow: 0 3px 14px rgba(0,0,0,0.5); }
	.tagline { margin-top:4px; font-size:13px; color:var(--accent-2); opacity:0.95; font-weight:700; letter-spacing:0.6px; animation: fadeUp .85s ease both; }
	@keyframes fadeUp{ from{ opacity:0; transform:translateY(6px);} to{ opacity:1; transform:translateY(0);} }
		.tabs { display:flex; gap:8px; overflow:auto; padding: 6px 8px 12px; }
		.tab-btn { flex:1; text-align:center; border:1px solid #26364c; background:#111622; color:var(--muted); padding:16px 0; border-radius:16px; font-weight:700; font-size:18px; }
		.tab-btn.active { color:#fff; border-color: var(--accent); box-shadow: 0 0 0 2px rgba(82,167,255,.15) inset; }
		.card { background:var(--card); border:1px solid #243349; border-radius: var(--radius); box-shadow: 0 8px 24px var(--shadow); padding:18px; }
		.grid { display:grid; grid-template-columns: 1fr; gap: 18px; } @media(min-width:720px){ .grid.cols-2{ grid-template-columns: 1fr 1fr; } .grid.cols-3{ grid-template-columns: repeat(3,1fr);} }
	/* prevent grid items from forcing horizontal overflow on small phones */
	.grid > div { min-width:0; }
		label { display:block; font-size: 16px; color: var(--muted); margin-bottom:8px; font-weight:600; } input, select, textarea, button { width:100%; box-sizing:border-box; border-radius:16px; border:1.5px solid #2a3b54; background:#0c111a; color:#fff; padding:18px; font-size:20px; margin-bottom:8px; }
		select { padding-right:24px; } textarea { min-height:100px; }
		.row { display:flex; gap:14px; } .row > * { flex:1; } .chip { display:inline-flex; align-items:center; gap:8px; background:#0c111a; border:1.5px dashed #2f3f57; padding:12px 14px; border-radius:999px; font-size:16px; color:var(--muted); }
		.muted { color:var(--muted); font-size:16px; } .hint { font-size:15px; color:#8cabd8; margin-top:8px; }
		.btn { background:linear-gradient(180deg,#0e7eed,#0a5fc1); border:none; font-weight:800; letter-spacing:.3px; cursor:pointer; font-size:20px; padding:18px 0; border-radius:16px; }
			.btn.sm { font-size:16px; padding:10px 12px; border-radius:12px; }
			.btn.xs { font-size:14px; padding:8px 10px; border-radius:10px; }
		.btn.secondary { background:#0c111a; border:1.5px solid #2b3e59; color:#cfe3ff; } .btn.good { background:linear-gradient(180deg,#14bd8d,#0da77a); }
		.btn.warn { background:linear-gradient(180deg,#ffb703,#f77f00); } .btn.danger { background:linear-gradient(180deg,#ff4d4d,#bf2e2e); }
		table { width:100%; border-collapse: collapse; } th, td { padding:16px; border-bottom:1.5px solid #223145; text-align:left; font-size:18px; }
		th { color:#b8cdf1; font-weight:800; font-size:18px; position: sticky; top:0; background:#162133; z-index:1; } tr:hover td { background:#121b2b; }
		.pill { padding:8px 14px; border-radius:9999px; font-size:16px; display:inline-block; } .pill.badge { background:#0c111a; border:1.5px solid #2f3f57; color:#b9c9e3; }
		.spacer { height:16px; } .section-title { font-weight:900; letter-spacing:.4px; font-size:24px; } .footer { color:var(--muted); text-align:center; font-size:16px; padding:18px 0 32px; }
		.hide { display:none !important; }
		.thumb { width:90px; height:90px; object-fit:cover; border-radius:14px; border:1.5px solid #2a3b54; }
		.thumb-row { display:flex; gap:14px; align-items:center; }
		.lightbox { position:fixed; inset:0; background:rgba(0,0,0,.85); display:flex; align-items:center; justify-content:center; padding:20px; z-index:9999; }
		.lightbox img { max-width:95vw; max-height:85vh; border-radius:18px; box-shadow:0 10px 30px rgba(0,0,0,.6); }
		.lightbox .close { position:absolute; top:14px; right:14px; }
	.invalid { border-color: var(--danger)!important; }
	.badge-count { background:var(--accent); color:#fff; font-size:16px; padding:4px 10px; border-radius:999px; margin-left:10px; line-height:1; }
	.quick-hidden { display:none !important; }
	/* Bite highlight styling */
	.bite-row td { background: rgba(46,208,162,0.08); }
	.bite-row td:first-child { border-left: 3px solid var(--accent-2); }
	.pill.badge.bite { background:#0c111a; border:1.5px solid var(--accent-2); color:#b9f3df; margin-right:8px; }
	.prefs-row { display:flex; gap:16px; flex-wrap:wrap; }
	.switch { position:relative; display:inline-flex; align-items:center; gap:8px; font-size:18px; cursor:pointer; }
	.switch input { width:auto; accent-color: var(--accent); }
	#analytics { font-size:16px; line-height:1.5; }
	#analytics h4 { margin:10px 0 4px; font-size:18px; letter-spacing:.5px; text-transform:uppercase; color:var(--muted); }
	.spark { display:inline-block; background:var(--accent); height:14px; margin-right:4px; border-radius:4px; }
	#toast { position:fixed; left:50%; transform:translateX(-50%); bottom:24px; background:#142032; color:#fff; padding:16px 24px; border:1.5px solid #21405c; border-radius:18px; box-shadow:0 6px 16px rgba(0,0,0,.4); display:none; z-index:99999; font-size:18px; }
	#toast button { width:auto; padding:10px 16px; margin-left:14px; font-size:18px; }
	/* Mobile-specific layout tweaks for smaller phones (iPhone) */
	@media(max-width:420px){
	input, select, textarea, button { padding:12px; font-size:16px; border-radius:12px; }
		.tab-btn { font-size:16px; padding:12px 8px; border-radius:14px; }
		.grid.cols-2, .grid.cols-3 { grid-template-columns: 1fr !important; }
		.row { flex-direction:column; }
		.card { padding:14px; }
		.section-title { font-size:20px; }
		.tabs { gap:6px; padding:6px 6px 8px; }
		#toast { font-size:16px; padding:12px 18px; bottom:18px; }
	/* Tighter header spacing on small phones */
	header { border-radius: 0 0 10px 10px; }
	.bar { padding:10px 8px; }
	.title { font-size:18px; }
	.tagline { font-size:12px; }
	/* logo removed: styling not required */
	}

/* anchored header dropdown (dedicated icon button, not title) */
.icon-btn { background:transparent; border:1px solid rgba(255,255,255,0.12); color:var(--ink); border-radius:12px; width:44px; height:44px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; }
.icon-btn svg { width:26px; height:26px; fill:none; stroke:#e8eefb; stroke-width:2.2; stroke-linecap:round; stroke-linejoin:round; }
.menu-list { position:absolute; top:calc(100% + 8px); left:0; min-width:240px; max-height:70vh; overflow:auto; -webkit-overflow-scrolling:touch; background:var(--card); border:1px solid #223145; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.5); padding:10px; z-index:60; display:flex; flex-direction:column; gap:8px; opacity:0; transform: translateY(4px) scale(0.98); transition: opacity .12s ease, transform .12s ease; }
.menu-list.open { opacity:1; transform: translateY(0) scale(1); }
.menu-list[hidden] { display:none; }
.menu-list .menu-link { text-decoration:none; color:var(--ink); padding:12px 14px; border-radius:10px; font-weight:700; font-size:18px; display:block; text-align:left; }
.menu-list .menu-link:hover, .menu-list .menu-link[aria-current="true"] { background:#0c1624; }
.menu-label { font-size:12px; letter-spacing:.6px; text-transform:uppercase; color:#89a2c4; padding:6px 8px 2px; }
.menu-sep { height:1px; background:#223145; margin:6px 4px; border-radius:1px; }
@media(min-width:720px){ .menu-list { left:50%; transform:translateX(-50%); } }
@media(max-width:520px){ .icon-btn { width:46px; height:46px; border-radius:14px; } }

	/* Ensure date/time native controls don't overflow their container on small screens */
	input[type="date"], input[type="time"]{ max-width:100%; box-sizing:border-box; }
	/* General guard: inputs should never overflow their parent columns */
	input, select, textarea { max-width:100%; box-sizing:border-box; }

	/* Slightly reduce input padding on small screens to avoid visual overflow */
	@media(max-width:420px){
		input, select, textarea { padding:10px 12px; font-size:15px; }
	.bar { height:84px; }
	}
	/* iPhone 15 Pro specific (approx CSS device width 393px) */
	@media(max-width:400px){
		input, select, textarea, button { padding:10px; font-size:15px; border-radius:10px; }
		.tab-btn { font-size:15px; padding:10px 8px; }
		.section-title { font-size:18px; }
		.card { padding:12px; }
		/* avoid inputs causing horizontal overflow */
		input, select, textarea { max-width:100%; box-sizing:border-box; }
	}
	/* global safety to avoid horizontal scrolling caused by shadows/rounded inputs */
	html,body{ overflow-x:hidden; }
	/* highlight for auto-filled fields */
	.auto-filled { outline: 2px solid var(--accent-2); box-shadow: 0 10px 30px rgba(46,208,162,0.12); transition: box-shadow .35s, outline .35s; }
	/* bottom action bar (mobile thumb-friendly) */
	#bottomBar { position: fixed; left: 12px; right: 12px; bottom: 18px; display:flex; gap:8px; justify-content:space-between; align-items:center; z-index:60; }
	#bottomBar .bar-btn { flex:1; padding:12px 10px; border-radius:14px; font-size:16px; }
	#saveStatus { margin-left:10px; min-width:120px; text-align:center; }
	@media(min-width:721px){ #bottomBar{ display:none; } }
	/* Rigger calc highlight when open */
	#riggerCalc { border:1.5px dashed #2f3f57; border-radius:12px; padding:8px; }
	#riggerCalc[open] { outline:2px solid var(--accent-2); box-shadow:0 0 0 3px rgba(46,208,162,.15) inset; }
	</style>
</head>
<body>
	<header>
		<div class="bar" style="justify-content:center; padding:10px 12px; position:relative;">
			<div class="menu-anchor" style="position:absolute; left:12px; top:8px;">
				<button id="navToggleRR" class="icon-btn" aria-expanded="false" aria-haspopup="true" aria-controls="navMenuRR" aria-label="Menu">
					<svg viewBox="0 0 24 24" aria-hidden="true">
						<path d="M4 6h14M4 12h14M4 18h14"/>
						<path d="M18 7l2 2l2-2"/>
					</svg>
				</button>
				<div id="navMenuRR" class="menu-list" hidden>
					<div class="menu-label">Playbook</div>
					<a href="index.html#playbook" class="menu-link">Overview</a>
					<div class="menu-sep" role="separator"></div>
					<div class="menu-label">Logging</div>
					<a href="#tab-setup" class="menu-link">Trip Setup</a>
					<a href="#tab-log" class="menu-link">Catch Log</a>
					<a href="#tab-review" class="menu-link">Review & Export</a>
					<a href="#tab-settings" class="menu-link">Settings</a>
					<div class="menu-sep" role="separator"></div>
					<button id="quickModeMenu" type="button" class="menu-link">Quick Mode: Off</button>
				</div>
			</div>
			<div class="title-container">
				<div class="title">Reel-Record</div>
				<div class="tagline">Log. Learn. Land More Fish</div>
			</div>
		</div>
	</header>
	<main class="wrap">
		<section id="tab-setup" class="grid">
			<div class="card">
				<div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
					<div class="section-title">Trip header</div>
					<button class="btn xs" id="fetchConditions" type="button" title="Use GPS to auto-fill conditions">Catch Conditions (GPS)</button>
				</div>
				<div class="row" style="margin-top:8px">
					<button id="genThermoPlan" class="btn secondary" type="button" style="display:none">Generate plan</button>
				</div>
				<div class="grid cols-1" style="margin-top:8px">
					<label for="tripSelect">Current trip</label>
					<select id="tripSelect"></select>
				</div>
				<div class="grid cols-2">
					<div><label for="tripDate">Date</label><input id="tripDate" type="date" /></div>
					<div><label for="startTime">Start time</label><input id="startTime" type="time" /></div>
					<div><label for="port">Port / Area</label><input id="port" placeholder="e.g., St. Joseph, 80-160 FOW" /></div>
					<div><label for="boat">Boat</label><input id="boat" placeholder="Boat name" /></div>
					<div><label for="crew">Crew</label><input id="crew" placeholder="Whoâ€™s aboard" /></div>
					<div><label for="hours">Planned hours</label><input id="hours" type="number" inputmode="decimal" placeholder="e.g., 5" /></div>
				</div>
				<div class="grid cols-3">
					<div><label for="airTemp">Air temp (Â°F)</label><input id="airTemp" type="number" inputmode="decimal" /></div>
					<div><label for="surfaceTemp">Surface temp (Â°F)</label><input id="surfaceTemp" type="number" inputmode="decimal" /></div>
					<div><label for="wind">Wind (dir/speed)</label><input id="wind" placeholder="e.g., WNW 10" /></div>
					<div><label for="waves">Waves (ft)</label><input id="waves" type="number" inputmode="decimal" /></div>
					<div><label for="clouds">Cloud cover</label><select id="clouds"></select></div>
				</div>
				<!-- removed Download and Manual Override per request -->
				<div style="margin-top:8px">
					<div class="muted">Tip: Tap <b>Catch Conditions (GPS)</b> before you leave to save latest conditions. Last cached: <span id="conditionsCached">â€”</span></div>
					<div class="muted">Nearest station: <span id="conditionsStation">â€”</span></div>
					<div id="marineSource" class="muted">Source: â€”</div>
				</div>
				<div class="hint">Tip: You can edit dropdown options under <b>Settings â†’ Lists</b>.</div>
				<div id="saveStatus" class="pill badge" style="display:inline-block;margin-top:8px">Saved</div>
			</div>
			<div class="card">
				<div class="section-title">Gear</div>
				<label for="gearNotes">Notes on gear (rods, reels, boards, rigs)</label>
				<textarea id="gearNotes" placeholder="e.g., 2 Cannon downriggers, 300/250 copper on Ninja 9.5 boards, dipsy setups..."></textarea>
			</div>
			<div class="card">
				<div class="section-title">Save / load trip</div>
				<div class="grid cols-2">
					<button class="btn good" id="saveTrip">Start Trip</button>
					<button class="btn secondary" id="newTrip">New trip</button>
				</div>
			</div>
		</section>
		<section id="tab-log" class="grid hide">
			<!-- Thermocline plan panel (shown after generation) -->
			<div class="card" id="thermoPlanPanel" style="display:none">
				<details open id="thermoDetails">
					<summary><strong>Thermocline & Plan (beta)</strong></summary>
					<div class="note" id="thermoStatus" style="margin-top:6px; font-size:14px"></div>
					<div id="thermoResult" style="margin-top:10px"></div>
				</details>
			</div>
			<div class="card">
				<div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
					<div class="section-title">Log a catch / bite</div>
					<div style="position:relative">
						<button id="logBiteBtn" class="icon-btn" type="button" title="Log a bite" aria-haspopup="true" aria-expanded="false">ðŸŽ£âœ–</button>
						<div id="logBiteMenu" class="menu-list" hidden style="right:0; left:auto; min-width:200px">
							<div class="menu-label">Log Bite on...</div>
							<button class="menu-link" data-bite="Downrigger" type="button">Downrigger</button>
							<button class="menu-link" data-bite="Planer Board" type="button">Planer Board</button>
							<button class="menu-link" data-bite="Dipsy" type="button">Dipsy Diver</button>
						</div>
					</div>
				</div>
				<div class="grid cols-3">
					<div><label for="time">Time</label><input id="time" type="time" /></div>
					<div><label for="platform">Platform</label><select id="platform"></select></div>
					<div><label for="trollDir">Troll direction</label><select id="trollDir"></select></div>
				</div>
				<div class="grid cols-3">
					<div><label for="waterDepth">Water depth (ft)</label><input id="waterDepth" type="number" inputmode="numeric" /></div>
					<div class="cond cond-rigger hide"><label for="ballDepth">Ball depth (ft)</label><input id="ballDepth" type="number" inputmode="numeric" /></div>
					<div class="cond cond-rigger hide"><label for="ballWeight">Rigger ball weight (lb)</label><input id="ballWeight" type="number" inputmode="decimal" /></div>
					<div class="cond cond-dipsy hide"><label for="dipsySize">Dipsy size</label><input id="dipsySize" placeholder="#0/#1/#2/#3" /></div>
					<div class="cond cond-dipsy hide"><label for="dipsySetting">Dipsy setting</label><input id="dipsySetting" placeholder="e.g., 1.5" /></div>
					<div class="cond cond-copper hide"><label for="copperLen">Copper length (ft)</label><input id="copperLen" type="number" inputmode="numeric" /></div>
					<div class="cond cond-leadcore hide"><label for="leadcoreColors">Leadcore (colors)</label><input id="leadcoreColors" placeholder="e.g., 5c/7c" /></div>
					<div><label for="targetDepth">Target depth (ft)</label><input id="targetDepth" type="number" inputmode="numeric" /></div>
				</div>
				<div class="grid cols-3">
					<div><label for="lureType">Lure type</label><select id="lureType"></select></div>
					<div><label for="lureBrand">Brand / model</label><input id="lureBrand" placeholder="e.g., Moonshine RV, J-plug" /></div>
					<div><label for="lureSize">Size</label><input id="lureSize" placeholder="e.g., mag, standard, 4" /></div>
					<div><label for="lureColor">Color / pattern</label><select id="lureColor"></select></div>
					<div><label for="attractor">Attractor / flasher</label><select id="attractor"></select></div>
					<div><label for="flyMeat">Fly / meat color</label><select id="flyMeat"></select></div>
				</div>
				<!-- Downrigger speed calculator dropdown (moved from index.html) -->
				<details id="riggerCalc">
				  <summary><strong>Downrigger Cannonball Speed Calculator</strong></summary>
				  <div class="grid cols-3" style="margin-top:10px">
				    <div><label for="riggerSog">SOG (mph)</label><input id="riggerSog" type="number" inputmode="decimal" placeholder="e.g., 2.6" /></div>
				    <div><label for="riggerWeight">Cannonball weight (lb)</label><input id="riggerWeight" type="number" inputmode="decimal" placeholder="e.g., 15" /></div>
				    <div><label for="riggerDepth">Depth (ft)</label><input id="riggerDepth" type="number" inputmode="numeric" placeholder="optional" /></div>
				  </div>
				  <div class="row" style="margin-top:8px">
				    <button id="calcRiggerBtn" class="btn secondary" type="button">Calculate</button>
				  </div>
				  <div id="riggerResult" class="hint" style="margin-top:8px"></div>
				</details>
				<div class="grid cols-3">
					<div><label for="speedBall">Speed @ ball (mph)</label><input id="speedBall" type="number" inputmode="decimal" /></div>
					<div><label for="sog">SOG (mph)</label><input id="sog" type="number" inputmode="decimal" /></div>
					<div><label for="strikeDepthSeen">Strike depth seen (ft)</label><input id="strikeDepthSeen" type="number" inputmode="numeric" /></div>
				</div>
				<div class="grid cols-3">
					<div><label for="species">Species</label><select id="species"></select></div>
					<div><label for="lengthIn">Length (in)</label><input id="lengthIn" type="number" inputmode="decimal" /></div>
					<div><label for="weightLb">Weight (lb)</label><input id="weightLb" type="number" inputmode="decimal" /></div>
				</div>
				<div class="grid cols-2">
					<div>
						<label for="gps">GPS (lat, lon)</label>
						<input id="gps" placeholder="e.g., 42.10, -86.50" />
						<input id="photoInput" type="file" accept="image/*" capture="environment" />
					<div class="hint">Tip: On iPhone/Android this opens the camera. We compress before saving to keep storage light.</div>
					<div class="thumb-row">
						<img id="photoPreview" class="thumb hide" alt="preview"/>
						<button class="btn secondary" id="clearPhoto" type="button">Remove photo</button>
					</div>
				</div>
				<div class="row">
					<button class="btn good" id="addEntry">Save entry</button>
					<button class="btn secondary" id="resetForm">Reset form</button>
					<button class="btn secondary" id="dupLast" type="button">Duplicate last</button>
					<button class="btn secondary" id="cancelEdit" type="button" style="display:none">Cancel edit</button>
					<button class="btn warn" id="forceSave" type="button" style="display:none">Force save</button>
					<button class="btn warn" id="endTrip" type="button" title="End current trip, export, and reset">End Trip</button>
				</div>
			</div>
			<div class="card">
				<div class="section-title">Session entries</div>
				<div style="overflow:auto; max-height: 45vh;">
					<table id="entriesTable">
						<thead>
							<tr><th>Time</th><th>Platf.</th><th>Photo</th><th>Lure</th><th>Depths</th><th>Dir/Speed</th><th>Species</th><th></th></tr>
						</thead>
						<tbody></tbody>
					</table>
				</div>
			</div>
		</section>
		<section id="tab-review" class="grid hide">
			<div class="card">
				<div class="section-title">Trip summary</div>
				<div id="summary" class="muted">(Fill in Trip Setup and add entries to see a summary.)</div>
			</div>
			<div class="card">
				<div class="section-title">Analytics</div>
				<div id="analytics" class="muted">(Data appears after entries.)</div>
			</div>
			<!-- Thermocline card moved to Setup/Log per request -->
			<div class="card">
				<div class="section-title">Export / backup</div>
				<div class="grid cols-1">
					<div style="display:flex;gap:12px">
						<button class="btn secondary" id="pushFullTrip">Push full trip (rows)</button>
					</div>
				</div>
				<div class="hint">Note: trip will be uploaded only with cell service.</div>
			</div>
						<div class="card">
								<details>
									<summary><strong>Manage data</strong></summary>
									<div class="grid cols-2" style="margin-top:10px">
										<button class="btn danger" id="clearTrip" type="button">Clear current trip</button>
										<button class="btn danger" id="clearAll" type="button">Clear ALL trips</button>
										<button class="btn danger" id="deleteTrip" type="button" style="grid-column:span 2">Delete trip</button>
									</div>
									<div class="hint">Clearing is permanent on this device. Export first if you want a backup.</div>
								</details>
						</div>
		</section>
		<section id="tab-settings" class="grid hide">
			<div class="card">
				<div class="section-title">Lists</div>
				<div class="grid cols-2">
					<div><label for="listPlatform">Platform options (one per line)</label><textarea id="listPlatform"></textarea></div>
					<div><label for="listLineType">Line types</label><textarea id="listLineType"></textarea></div>
					<div><label for="listLureType">Lure types</label><textarea id="listLureType"></textarea></div>
					<div><label for="listLureColors">Lure colors / patterns</label><textarea id="listLureColors"></textarea></div>
					<div><label for="listAttractors">Attractors / flashers</label><textarea id="listAttractors"></textarea></div>
					<div><label for="listFlyMeat">Fly / meat colors</label><textarea id="listFlyMeat"></textarea></div>
					<div><label for="listSpecies">Species</label><textarea id="listSpecies"></textarea></div>
					<div><label for="listTrollDir">Troll directions</label><textarea id="listTrollDir"></textarea></div>
					<div><label for="listClouds">Cloud cover</label><textarea id="listClouds"></textarea></div>
				</div>
				<div class="row">
					<button class="btn good" id="saveLists">Save lists</button>
					<button class="btn secondary" id="restoreDefaults">Restore defaults</button>
				</div>
			</div>
			<div class="card">
				<div class="section-title">About</div>
				<div class="muted">All data is stored locally on this device. Text data uses <b>localStorage</b>; photos use <b>IndexedDB</b> to avoid size limits. Export CSV/JSON/Album after each trip to back up.</div>
			</div>
			<div class="card">
				<div class="section-title">Preferences</div>
				<div class="prefs-row">
					<label class="switch"><input type="checkbox" id="prefQuickDefault"/> Quick mode by default</label>
					<label class="switch"><input type="checkbox" id="prefSticky" checked/> Sticky lure fields</label>
					<label class="switch"><input type="checkbox" id="prefThermoBeta"/> Enable Thermocline Plan (beta)</label>
				</div>
				<div style="margin-top:12px">
					<label for="marineJsonUrl">Optional: Marine data JSON URL (public)</label>
					<input id="marineJsonUrl" placeholder="https://example.com/marine.json" />
					<div class="hint">If you host a simple JSON file with fields { sstC: <Celsius>, waveM: <meters> } we will fetch it (useful at the dock before heading out).</div>
				</div>
				<div style="margin-top:12px">
					<label for="stationJsonTemplate">Optional: Station JSON template (public)</label>
					<input id="stationJsonTemplate" placeholder="https://yourhost.example/stations/{station}.json or raw GitHub URL" />
					<div class="hint">You can paste a GitHub Pages or raw URL template. Use <code>{station}</code> to substitute station id. Example: <code>https://raw.githubusercontent.com/elliottdanielp/big_lake_fishing_log/main/sample-ndbc.json</code></div>
				</div>
				<div style="margin-top:12px">
					<label for="sheetWebAppUrl">Optional: Google Sheet Web App URL</label>
					<input id="sheetWebAppUrl" placeholder="https://script.google.com/macros/s/....../exec" />
					<div class="hint">Paste the Web App URL from Apps Script (deploy as Web app). We'll POST a single summary row when you tap Push to Google Sheet.</div>
				</div>
				<div style="margin-top:6px">
					<label for="sheetSecret">Optional: Sheet secret (short token)</label>
					<input id="sheetSecret" placeholder="shared-secret-for-posts" />
					<div class="hint">A short secret that the Apps Script validates to prevent accidental writes. Keep private.</div>
				</div>
				<div class="row" style="margin-top:10px">
					<button class="btn good" id="savePrefs" type="button">Save preferences</button>
				</div>
				<div class="hint">Sticky keeps lure fields after saving. Quick mode hides advanced fields for speed.</div>
			</div>
		</section>
	</main>
	<div style="max-width:880px;margin:14px auto 6px;padding:6px 12px;text-align:center;">
		<div class="muted" style="margin-top:8px;font-size:14px;">Tip: On iPhone use Safari â–¸ Share â–¸ Add to Home Screen</div>
	</div>
	<div class="footer">Â© You. Fish hard, log smart.</div>
	<div id="lightbox" class="lightbox hide" role="dialog" aria-modal="true">
		<img id="lightboxImg" alt="photo" />
		<button class="btn secondary close" id="lightboxClose">Close</button>
	</div>
	<div id="toast"></div>
	<!-- Mobile bottom action bar removed per request -->
	<script>
	// Ensure all event listeners are attached after DOM is loaded
	const $ = (sel) => document.querySelector(sel);
	const $$ = (sel) => Array.from(document.querySelectorAll(sel));
	const uid = () => Math.random().toString(36).slice(2) + Date.now().toString(36);
	// Helper for older browsers: attach event only if element exists (avoids optional-chaining syntax)
	function attach(selector, evt, handler) { const el = document.querySelector(selector); if (el) el.addEventListener(evt, handler); }
	const onReady = (fn) => { if (document.readyState === 'loading') window.addEventListener('DOMContentLoaded', fn); else fn(); };
	onReady(() => {
				// Prevent browser from restoring previous scroll position on hash changes
				try{ if('scrollRestoration' in history) history.scrollRestoration = 'manual'; }catch(_){}
			// All other event listeners below (move all listeners inside this block)
	attach('#fetchConditions', 'click', async () => {
				// Minimal local-only implementation: attempt geolocation then mark conditions cached.
				try {
					if (!('geolocation' in navigator)) {
						toast('Geolocation unavailable');
						return;
					}
					navigator.geolocation.getCurrentPosition(async pos => {
						const { latitude, longitude } = pos.coords;
						// store coords in the header for reference and populate GPS field on the catch form
						const cur = currentTripId();
						const lat = Number(latitude).toFixed(5);
						const lon = Number(longitude).toFixed(5);
						if (cur && state.trips[cur]) {
							state.trips[cur].header = state.trips[cur].header || {};
							state.trips[cur].header.lastLat = lat;
							state.trips[cur].header.lastLon = lon;
							state.trips[cur].header.lastFetchedAt = Date.now();
							save(); indicateSaved();
						}
						const el = document.getElementById('conditionsCached');
						if (el) el.textContent = new Date().toLocaleString() + ' â€¢ ' + lat + ', ' + lon;
						// also prefill the GPS input in the catch form so new entries inherit the location
						const gpsInput = document.getElementById('gps');
						if (gpsInput && !gpsInput.value) gpsInput.value = lat + ', ' + lon;
						// Fetch weather via Open-Meteo to populate airTemp, wind and clouds (best-effort)
						try{
							const wm = await fetchOpenMeteo(latitude, longitude);
							if(wm && typeof wm.tempC === 'number'){
								// convert to Â°F for the UI
								const f = Math.round((wm.tempC * 9/5) + 32);
								const airEl = document.getElementById('airTemp');
								if(airEl) airEl.value = f;
								// store
								if(cur && state.trips[cur]) state.trips[cur].header.airTemp = String(f);
							}
							if(wm && typeof wm.windKmh === 'number'){
								const mph = Math.round(wm.windKmh / 1.609);
								const dir = (typeof wm.windDeg==='number') ? degToCompass(wm.windDeg) : '';
								const wstr = dir ? `${dir} ${mph} mph` : `${mph} mph`;
								const windEl = document.getElementById('wind');
								if(windEl) windEl.value = wstr;
								if(cur && state.trips[cur]) state.trips[cur].header.wind = wstr;
							}
							if(wm && typeof wm.cloudPct === 'number'){
								// map cloud % to nearest option in #clouds select if possible
								const cloudsEl = document.getElementById('clouds');
								let label = '';
								if(cloudsEl){
									const pct = wm.cloudPct;
									// simple mapping: 0-10 Clear, 11-50 Partly, 51-100 Overcast
									if(pct<=10) label = 'Clear'; else if(pct<=50) label = 'Partly'; else label = 'Overcast';
									// pick matching option if present
									const found = Array.from(cloudsEl.options).find(o=>o.text.toLowerCase().startsWith(label.toLowerCase()));
									if(found) { cloudsEl.value = found.value || found.text; }
									else { try{ cloudsEl.insertAdjacentHTML('beforeend', `<option>${label}</option>`); cloudsEl.value = label; }catch(_){} }
								}
								if(cur && state.trips[cur]) state.trips[cur].header.clouds = label;
							}
							// attempt to fetch marine / surface data (sea surface temp, waves)
							try{
								// compute nearest station if we have a stations list
								let nearest = null;
								try{
									const stations = window.__stations || [];
									if(stations.length){
										const toR = n => n * Math.PI / 180;
										const hav = (a,b)=>{ const R=6371; const dLat=toR(b.lat-a.lat); const dLon=toR(b.lon-a.lon); const la=toR(a.lat), lb=toR(b.lat); const h = Math.sin(dLat/2)**2 + Math.cos(la)*Math.cos(lb)*Math.sin(dLon/2)**2; return 2*R*Math.asin(Math.sqrt(h)); };
										let best=null, bestD=Infinity; stations.forEach(s=>{ const d = hav({lat: latitude, lon: longitude}, {lat:s.lat, lon:s.lon}); if(d<bestD){ bestD=d; best=s; } }); if(best) nearest = Object.assign({}, best, {distKm: bestD});
									}
								}catch(e){ console.warn('stations lookup failed', e); }
								if(nearest){ 
									const cs = document.getElementById('conditionsStation'); 
									if(cs) cs.textContent = nearest.name + ' â€¢ ' + (nearest.distKm? nearest.distKm.toFixed(1)+' km':''); 
									// Auto-fill Port/Area from nearest station if port field empty
									try{
										const portEl = document.getElementById('port');
										if(portEl && !portEl.value){
											const portVal = nearest.name + (nearest.distKm? (' â€¢ '+nearest.distKm.toFixed(1)+' km') : '');
											portEl.value = portVal;
											if(cur && state.trips[cur]) state.trips[cur].header.port = portVal;
										}
										// Auto-fill date and start time if empty
										const dateEl = document.getElementById('tripDate');
										const timeEl = document.getElementById('startTime');
										const now = new Date();
										if(dateEl && !dateEl.value){ const localDate = now.getFullYear() + '-' + String(now.getMonth()+1).padStart(2,'0') + '-' + String(now.getDate()).padStart(2,'0'); dateEl.value = localDate; if(cur && state.trips[cur]) state.trips[cur].header.date = localDate; }
										if(timeEl && !timeEl.value){ const t = now.toTimeString().slice(0,5); timeEl.value = t; if(cur && state.trips[cur]) state.trips[cur].header.startTime = t; }
										// persist the header after auto-filling
										save(); indicateSaved();
									}catch(e){ console.warn('auto-fill port/date failed', e); }
								}

								// try station-specific JSON template if configured
								let marine = null;
								try{
									const tpl = (state.settings && state.settings.stationJsonTemplate) ? String(state.settings.stationJsonTemplate).trim() : '';
									if(tpl && nearest){
										const url = tpl.replace('{station}', encodeURIComponent(nearest.id)).replace('{lat}', encodeURIComponent(latitude)).replace('{lon}', encodeURIComponent(longitude));
										try{
											const r = await fetch(url, { cache: 'no-store' });
											if(r.ok){
												const js = await r.json();
												const s = js && (js.sstC ?? js.surfaceTempC ?? js.sst ?? null);
												const wv = js && (js.waveM ?? js.significant_wave_height ?? js.wave ?? null);
												if(s!==null || wv!==null){ marine = { sstC: s===null?null:Number(s), waveM: wv===null?null:Number(wv) }; }
											} else { console.warn('station template HTTP', r.status); }
										}catch(e){ console.warn('station template fetch failed', e); }
									}
								}catch(e){ console.warn('station template handling failed', e); }

								// fallback to default marine fetch if we didn't get a station JSON
								if(!marine){
									marine = await fetchMarineNearest(latitude, longitude);
								}

								if(marine){
									if(typeof marine.sstC === 'number'){
										const sstF = Math.round((marine.sstC * 9/5) + 32);
										const sEl = document.getElementById('surfaceTemp');
										if(sEl) sEl.value = sstF;
										if(cur && state.trips[cur]) state.trips[cur].header.surfaceTemp = String(sstF);
									}
									if(typeof marine.waveM === 'number'){
										const waveFt = (marine.waveM * 3.28084).toFixed(1);
										const wEl = document.getElementById('waves');
										if(wEl) wEl.value = waveFt;
										if(cur && state.trips[cur]) state.trips[cur].header.waves = String(waveFt);
									}
									// persist source metadata, snapshot for undo, show human timestamp and highlight fields
									try{
										const ms = document.getElementById('marineSource');
										const stationId = (marine && marine.station) ? String(marine.station) : (nearest && nearest.id ? String(nearest.id) : '');
										const src = stationId ? `buoy ${stationId}` : 'autofill';
										if(cur && state.trips[cur]){
											// snapshot previous header for undo
											pendingMarineUndo = { id: cur, prevHeader: Object.assign({}, state.trips[cur].header || {}) };
											state.trips[cur].header.marineSource = src;
											state.trips[cur].header.marineFetchedAt = Date.now();
											if(stationId) state.trips[cur].header.marineStation = stationId;
										}
										if(ms){
											const d = new Date(state.trips[cur].header.marineFetchedAt);
											ms.textContent = 'Source: Auto-filled from ' + src + ' â€¢ ' + d.toLocaleString();
										}
										// highlight the auto-filled fields briefly
										try{ const sEl = document.getElementById('surfaceTemp'); const wEl = document.getElementById('waves'); if(sEl){ sEl.classList.add('auto-filled'); setTimeout(()=>sEl.classList.remove('auto-filled'), 3000); } if(wEl){ wEl.classList.add('auto-filled'); setTimeout(()=>wEl.classList.remove('auto-filled'), 3000); } }catch(e){}
										// show undo in toast
										toast('Conditions cached (local) â€” values auto-filled. <button class="btn secondary" id="undoMarineBtn">Undo</button>', true);
										setTimeout(hideToast, 8000);
										// wire undo button once shown
										setTimeout(()=>{ const b = document.getElementById('undoMarineBtn'); if(b) b.addEventListener('click', ()=>{ if(pendingMarineUndo && pendingMarineUndo.id){ const id = pendingMarineUndo.id; state.trips[id].header = pendingMarineUndo.prevHeader || {}; save(); indicateSaved(); loadHeaderIntoForm(); const ms2 = document.getElementById('marineSource'); if(ms2) ms2.textContent = 'Source: â€”'; pendingMarineUndo = null; toast('Auto-fill undone'); setTimeout(hideToast, 1600); } }); }, 50);
									}catch(e){ console.warn('failed to persist marine source', e); }
								}
							}catch(e){ console.warn('marine fetch error', e); }
							save(); indicateSaved();
						}catch(err){
							console.warn('Weather fetch failed', err);
						}
						toast('Conditions cached (local)');
						// auto-hide the toast quickly so it doesn't obscure form fields on small screens
						setTimeout(hideToast, 1600);
					}, err => {
						toast('Could not get location: ' + (err && err.message));
						setTimeout(hideToast, 2000);
					}, { enableHighAccuracy: true, timeout: 8000, maximumAge: 10000 });
				} catch (err) { console.warn('fetchConditions error', err); toast('Failed to fetch conditions'); }
			});
	attach('#saveTrip', 'click', saveHeader);
	attach('#newTrip', 'click', async () => {
					const id = uid();
					state.trips[id] = { id, header:{}, entries:[], active:false, createdAt:Date.now(), updatedAt:Date.now() };
				save(); refreshTripSelect();
				const sel=document.getElementById('tripSelect'); if(sel) sel.value=id;
				loadHeaderIntoForm(); applyActiveTripGating();
				toast('New trip started'); setTimeout(hideToast, 1200);
			});
	attach('#tripSelect', 'change', () => {
				// ...existing code...
			});
	attach('#platform', 'change', () => {
				// ...existing code...
			});
	attach('#nowBtn', 'click', setNow);
	attach('#getGps', 'click', () => {
				// ...existing code...
			});
	attach('#saveLists', 'click', textareaToLists);
	attach('#restoreDefaults', 'click', () => {
				// ...existing code...
			});
	attach('#addEntry', 'click', () => addOrUpdateEntry(false));
	attach('#forceSave', 'click', () => addOrUpdateEntry(true));
	attach('#cancelEdit', 'click', () => { setEditing(false); clearCatchForm(false); });
	attach('#dupLast', 'click', () => {
				const t=state.trips[currentTripId()];
				if(!t||!t.entries.length) return toast('No previous entry');
				const last=t.entries[t.entries.length-1];
				loadEntryIntoForm(last, true);
				editingEntryId=null;
				setNow();
				setEditing(false);
			});
	attach('#resetForm', 'click', clearCatchForm);
	attach('#clearPhoto', 'click', () => {
				// ...existing code...
			});
	// lightbox handlers (guarded)
	const lbCloseBtn = $('#lightboxClose');
	if (lbCloseBtn) lbCloseBtn.addEventListener('click', () => { const lb = $('#lightbox'); if (lb) lb.classList.add('hide'); });
	const lightboxEl = $('#lightbox');
	if (lightboxEl) lightboxEl.addEventListener('click', (e) => { if (e.target && e.target.id === 'lightbox') { lightboxEl.classList.add('hide'); } });
			attach('#exportCsv', 'click', exportCsv);

	// Wire mobile bottom bar buttons (if present)
	// bottom bar removed

	// Header menu: Quick Mode toggle from menu
	attach('#quickModeMenu','click', ()=>{
		state.settings.quickMode = !state.settings.quickMode;
		save(); indicateSaved();
		applyQuickMode();
		const m = document.getElementById('quickModeMenu'); if(m) m.textContent = 'Quick Mode: ' + (state.settings.quickMode ? 'On' : 'Off');
		toast('Quick Mode ' + (state.settings.quickMode ? 'On' : 'Off'));
		setTimeout(hideToast, 1200);
	});

			// Tab switching for top nav
			// Hash-based section switching (no top tab bar)
			function showSection(name){
				['setup','log','review','settings'].forEach(n=>{
					const el = document.getElementById('tab-'+n);
					if(!el) return;
					const isActive = (n===name);
					if(isActive) el.classList.remove('hide'); else el.classList.add('hide');
					el.setAttribute('aria-hidden', isActive ? 'false' : 'true');
				});
				if(name==='review'){ renderSummary(); renderAnalytics(); }
				if(name==='log'){ renderEntries(); }
				// Gate Catch Log visibility if no active trip
				applyActiveTripGating();
			}
			function applyHash(){
				const h = location.hash || '#tab-setup';
				const match = /^#tab-(setup|log|review|settings)$/.exec(h);
				const name = match ? match[1] : 'setup';
				// If Catch Log requested but trip is not active, redirect to setup
				if(name === 'log' && !isTripActive()){
					location.hash = '#tab-setup';
					showSection('setup');
					return;
				}
				showSection(name);
				// Always open target section at the top
							if(name === 'log') {
								try{ window.scrollTo({ top: 0, left: 0, behavior: 'auto' }); }catch(_){ window.scrollTo(0,0); }
								// Reinforce scroll reset in case of mobile browser quirks
								setTimeout(()=>{ try{ window.scrollTo({ top: 0, left: 0, behavior: 'auto' }); }catch(_){ window.scrollTo(0,0); } }, 50);
								requestAnimationFrame(()=>{ try{ window.scrollTo({ top: 0, left: 0, behavior: 'auto' }); }catch(_){ window.scrollTo(0,0); } });
								if(document.activeElement && typeof document.activeElement.blur==='function') { document.activeElement.blur(); }
							}
			}
			window.addEventListener('hashchange', applyHash);
			applyHash();
			// Initialize Quick Mode label in menu
			const qm = document.getElementById('quickModeMenu'); if(qm) qm.textContent = 'Quick Mode: ' + (state.settings.quickMode ? 'On' : 'Off');
			applyActiveTripGating();

			// Main-column Settings button (above Add to Home) â€” show settings panel when tapped
			attach('#mainSettingsBtn', 'click', (e) => {
				location.hash = '#tab-settings';
				const s = document.getElementById('tab-settings'); if(s) s.scrollIntoView({behavior:'smooth', block:'start'});
			});

			// Add any other button listeners here as needed
		});
		function degToCompass(num) {
			const val = Math.floor((num / 22.5) + 0.5);
			const arr = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
			return arr[(val % 16)];
		}
		// Fetch current weather from Open-Meteo (no API key). Returns an object or throws.
		async function fetchOpenMeteo(lat, lon){
			const url = `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}&current_weather=true&hourly=cloudcover&timezone=auto`;
			const r = await fetch(url, {cache: 'no-store'});
			if(!r.ok) throw new Error('Weather API HTTP '+r.status);
			const js = await r.json();
			// current_weather: temperature (Â°C), windspeed (km/h), winddirection (deg)
			const cw = js.current_weather || {};
			const tempC = cw.temperature;
			const windKmh = cw.windspeed;
			const windDeg = cw.winddirection;
			// attempt to derive cloud cover from nearest hourly point
			let cloudPct = null;
			if(js.hourly && Array.isArray(js.hourly.time) && Array.isArray(js.hourly.cloudcover)){
				const times = js.hourly.time.map(t=>new Date(t).getTime());
				const now = Date.now();
				// find nearest index
				let bestIdx = 0, bestDiff = Infinity;
				for(let i=0;i<times.length;i++){ const d = Math.abs(times[i]-now); if(d<bestDiff){ bestDiff=d; bestIdx=i; } }
				cloudPct = Number(js.hourly.cloudcover[bestIdx]);
			}
			return { tempC, windKmh, windDeg, cloudPct };
		}

		// Placeholder for marine/surface data API for Lake Michigan (Holland <-> Muskegon area).
		// Real marine data (surface temp, waves) typically comes from NOAA/GLERL/NDBC/ERDDAP and may need different endpoints.
		// This placeholder returns null and is intended to be replaced with a proper API call later.
		async function fetchMarineNearest(lat, lon){
			// 1) If the user supplied a public JSON URL in Settings, try it first.
			//    Accepts either a tiny JSON like { sstC: 4.2, waveM: 0.6 }
			//    or a full Open-Meteo marine response (hourly.time + hourly.sea_surface_temperature etc.).
			try{
				const mj = (state && state.settings && state.settings.marineJsonUrl) ? String(state.settings.marineJsonUrl).trim() : '';
				// ALSO: if user configured a station JSON template (worker), prefer calling it with prefer=ocean-spec
				const tpl = (state && state.settings && state.settings.stationJsonTemplate) ? String(state.settings.stationJsonTemplate).trim() : '';
				if(tpl){
					try{
						// If we have a stations list, compute nearest id (best-effort). Otherwise the calling code may have provided nearest id via template placeholders.
						let stationId = '';
						try{
							const stations = window.__stations || [];
							if(stations.length){
								// simple haversine nearest
								const toR = n => n * Math.PI / 180;
								const hav = (a,b)=>{ const R=6371; const dLat=toR(b.lat-a.lat); const dLon=toR(b.lon-a.lon); const la=toR(a.lat), lb=toR(b.lat); const h = Math.sin(dLat/2)**2 + Math.cos(la)*Math.cos(lb)*Math.sin(dLon/2)**2; return 2*R*Math.asin(Math.sqrt(h)); };
								let best=null, bestD=Infinity; stations.forEach(s=>{ const d = hav({lat: lat, lon: lon}, {lat:s.lat, lon:s.lon}); if(d<bestD){ bestD=d; best=s; } }); if(best) stationId = best.id || '';
							}
							// Fallback: if no station or port still empty, set Port to lat, lon
							try{
								const portEl2 = document.getElementById('port');
								if(portEl2 && !portEl2.value){ const v = lat + ', ' + lon; portEl2.value = v; if(cur && state.trips[cur]) state.trips[cur].header.port = v; }
							}catch(_){ }
						}catch(e){ console.warn('nearest station lookup failed', e); }
						// build URL by substituting {station},{lat},{lon}
						let url = tpl.replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
						if(stationId) url = url.replace('{station}', encodeURIComponent(stationId));
						// request prefer=ocean-spec so worker composes SST from .ocean and WVHT from .spec
						const debugSuffix = url.includes('?') ? '&' : '?';
						const prefUrl = url + debugSuffix + 'prefer=ocean-spec';
						const r = await fetch(prefUrl, { cache: 'no-store' });
						if(r.ok){
							const js = await r.json();
							// Accept tiny shapes or composed fields
							const maybeSst = js && (js.sstC ?? js.surfaceTempC ?? js.sst ?? null);
							const maybeWave = js && (js.waveM ?? js.significant_wave_height ?? js.wave ?? null);
							if(maybeSst !== undefined || maybeWave !== undefined){
								const s = (maybeSst===null||maybeSst===undefined)? null : Number(maybeSst);
								const w = (maybeWave===null||maybeWave===undefined)? null : Number(maybeWave);
								return { sstC: s, waveM: w };
							}
						} else {
							console.warn('station template prefer fetch failed', r.status, prefUrl);
						}
					}catch(e){ console.warn('station template prefer fetch error', e); }
				}
				if(mj){
					try{
						// allow simple placeholders {lat} and {lon} in the URL
						let url = mj.replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
						const r = await fetch(url, { cache: 'no-store' });
						if(r.ok){
							const js = await r.json();
							// tiny JSON shape
							const maybeSst = js && (js.sstC ?? js.surfaceTempC ?? js.sst ?? js.sea_surface_temperature);
							const maybeWave = js && (js.waveM ?? js.significant_wave_height ?? js.waveM ?? js.wave ?? js.significant_wave_height_meters);
							if(maybeSst !== undefined || maybeWave !== undefined){
								const s = (maybeSst===null||maybeSst===undefined)? null : Number(maybeSst);
								const w = (maybeWave===null||maybeWave===undefined)? null : Number(maybeWave);
								return { sstC: s, waveM: w };
							}
							// try to parse full Open-Meteo marine response
							if(js && js.hourly && Array.isArray(js.hourly.time)){
								const times = js.hourly.time.map(t=>new Date(t).getTime());
								const now = Date.now();
								let bestIdx = 0, bestDiff = Infinity;
								for(let i=0;i<times.length;i++){ const d = Math.abs(times[i]-now); if(d<bestDiff){ bestDiff=d; bestIdx=i; } }
								const sst = (js.hourly.sea_surface_temperature && js.hourly.sea_surface_temperature[bestIdx]!==undefined) ? Number(js.hourly.sea_surface_temperature[bestIdx]) : null;
								const wave = (js.hourly.significant_wave_height && js.hourly.significant_wave_height[bestIdx]!==undefined) ? Number(js.hourly.significant_wave_height[bestIdx]) : null;
								return { sstC: sst, waveM: wave };
							}
							// if we reach here, the JSON didn't match expected shapes
							console.warn('marineJsonUrl returned JSON but no recognizable fields');
						} else {
							console.warn('marineJsonUrl HTTP', r.status);
						}
					}catch(e){ console.warn('Failed to fetch/parse marineJsonUrl', e); }
				}
			}catch(e){ console.warn('marineJsonUrl handling failed', e); }

			// 2) Fallback: Open-Meteo Marine API (public, no key) â€” returns sea surface temperature and significant wave height (hourly)
			try{
				const m = await fetchOpenMeteoMarine(lat, lon);
				return m; // { sstC, waveM }
			}catch(err){
				console.warn('Marine fallback failed', err);
				return null;
			}
		}

		// Query Open-Meteo's Marine API (no key). Returns { sstC, waveM } or throws.
		async function fetchOpenMeteoMarine(lat, lon){
			// hourly=sea_surface_temperature,significant_wave_height
			// If a proxy is configured (to bypass CORS or add station logic), use it
			const proxy = (window && window.MARINE_PROXY_URL) ? window.MARINE_PROXY_URL.replace(/\/$/, '') : null;
			let res;
			if(proxy){
				const url = `${proxy}/api/marine?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}`;
				res = await fetch(url, { cache: 'no-store' });
			} else {
				const url = `https://marine-api.open-meteo.com/v1/marine?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}&hourly=sea_surface_temperature,significant_wave_height&timezone=auto`;
				res = await fetch(url, { cache: 'no-store' });
			}
			if(!res.ok) throw new Error('Marine API HTTP '+res.status);
			const js = await res.json();
			// pick nearest hourly value
			let sst = null, wave = null;
			if(js && js.hourly && Array.isArray(js.hourly.time)){
				const times = js.hourly.time.map(t=>new Date(t).getTime());
				const now = Date.now();
				let bestIdx = 0, bestDiff = Infinity;
				for(let i=0;i<times.length;i++){ const d = Math.abs(times[i]-now); if(d<bestDiff){ bestDiff=d; bestIdx=i; } }
				if(js.hourly.sea_surface_temperature && js.hourly.sea_surface_temperature[bestIdx] !== undefined) sst = Number(js.hourly.sea_surface_temperature[bestIdx]);
				if(js.hourly.significant_wave_height && js.hourly.significant_wave_height[bestIdx] !== undefined) wave = Number(js.hourly.significant_wave_height[bestIdx]);
			}
			return { sstC: sst, waveM: wave };
		}
	const LS_KEY = 'blfl.state.v2';
	let state = load() || { trips: {}, lists: defaults(), dataVersion:3, settings:{quickMode:false, sticky:true} };
	let pendingMarineUndo = null;
		function defaults(){ return { Platform:["Downrigger","Dipsy","Copper","Leadcore","Planer Board","Flatline"], LineType:["Wire","Braid","Mono","Fluorocarbon","Copper","Leadcore"], LureType:["Spoon","Plug","Flasher/Fly","Meat Rig","Spin-n-Glow","Other"], LureColors:["NBK","Blue Dolphin","UV Blue/Green","Glow Green","Glow White","Orange/Silver","Green Dolphin","UV Stud","Blue Bubble","Chrome/Green","Chrome/Blue","Bloody Nose"], Attractors:["8\" White Crush","8\" UV Stud","11\" Chrome-Green","11\" White Paddle","8\" Blue Bubble","8\" Green Dot"], FlyMeat:["Blue Fly","Green Fly","Blue/Green Fly","Green Meat","Blue Meat","UV Fly"], Species:["Chinook (King)","Coho","Steelhead","Lake Trout","Brown Trout","Other"], TrollDirection:["N","NE","E","SE","S","SW","W","NW"], Clouds:["Clear","Partly","Overcast","Fog"], HookLocation:["Jaw","Corner","Tongue","Outside"] }; }
	function save(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
	// small helper to indicate saved status in the UI
	function indicateSaved(){ try{ const s = document.getElementById('saveStatus'); if(!s) return; s.textContent = 'Saved â€¢ ' + new Date().toLocaleTimeString(); s.style.opacity = '1'; setTimeout(()=>{ s.textContent = 'Saved'; }, 2500); }catch(e){} }
		function load(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)); }catch(e){ return null; } }
		const DB_NAME='blfl-db', DB_VER=1;
		function openDB(){ return new Promise((resolve,reject)=>{ const req=indexedDB.open(DB_NAME,DB_VER); req.onupgradeneeded=()=>{ const db=req.result; if(!db.objectStoreNames.contains('photos')) db.createObjectStore('photos',{keyPath:'id'}); }; req.onsuccess=()=>resolve(req.result); req.onerror=()=>reject(req.error); }); }
		async function savePhoto(entryId, dataURL){ const db=await openDB(); await new Promise((res,rej)=>{ const tx=db.transaction('photos','readwrite'); tx.objectStore('photos').put({id:entryId, dataURL, ts:Date.now()}); tx.oncomplete=res; tx.onerror=()=>rej(tx.error); }); }
	async function getPhoto(entryId){ const db=await openDB(); return await new Promise((res,rej)=>{ const tx=db.transaction('photos','readonly'); const req=tx.objectStore('photos').get(entryId); req.onsuccess=()=>res((req.result && req.result.dataURL) || ''); req.onerror=()=>rej(req.error); }); }
		async function deletePhoto(entryId){ const db=await openDB(); await new Promise((res,rej)=>{ const tx=db.transaction('photos','readwrite'); tx.objectStore('photos').delete(entryId); tx.oncomplete=res; tx.onerror=()=>rej(tx.error); }); }
	// (Removed duplicate event listener for .tab-btn)
		function fillSelect(id, arr){ const el=$(id); if(!el) return; const values = (Array.isArray(arr) && arr.length) ? arr : []; el.innerHTML = '<option value="">â€”</option>' + values.map(v=>`<option>${v}</option>`).join(''); }
		function ensureListsSeeded(){ const d=defaults(); state.lists = state.lists || {}; const keys=["Platform","LineType","LureType","LureColors","Attractors","FlyMeat","Species","TrollDirection","Clouds","HookLocation"]; keys.forEach(k=>{ if(!Array.isArray(state.lists[k]) || !state.lists[k].length){ state.lists[k] = d[k].slice(); } }); }
		function fillAllSelects(){ ensureListsSeeded(); fillSelect('#platform', state.lists.Platform); fillSelect('#lureType', state.lists.LureType); fillSelect('#species', state.lists.Species); fillSelect('#trollDir', state.lists.TrollDirection); fillSelect('#clouds', state.lists.Clouds); fillSelect('#lureColor', state.lists.LureColors); fillSelect('#attractor', state.lists.Attractors); fillSelect('#flyMeat', state.lists.FlyMeat); }
		function listsToTextarea(){ ensureListsSeeded(); $('#listPlatform').value = state.lists.Platform.join('\n'); $('#listLineType').value = state.lists.LineType.join('\n'); $('#listLureType').value = state.lists.LureType.join('\n'); $('#listLureColors').value = state.lists.LureColors.join('\n'); $('#listAttractors').value = state.lists.Attractors.join('\n'); $('#listFlyMeat').value = state.lists.FlyMeat.join('\n'); $('#listSpecies').value = state.lists.Species.join('\n'); $('#listTrollDir').value = state.lists.TrollDirection.join('\n'); $('#listClouds').value = state.lists.Clouds.join('\n'); $('#listHookLoc').value = state.lists.HookLocation.join('\n'); }
		function textareaToLists(){ const split=t=>t.split('\n').map(s=>s.trim()).filter(Boolean); state.lists = state.lists || {}; state.lists.Platform=split($('#listPlatform').value); state.lists.LineType=split($('#listLineType').value); state.lists.LureType=split($('#listLureType').value); state.lists.LureColors=split($('#listLureColors').value); state.lists.Attractors=split($('#listAttractors').value); state.lists.FlyMeat=split($('#listFlyMeat').value); state.lists.Species=split($('#listSpecies').value); state.lists.TrollDirection=split($('#listTrollDir').value); state.lists.Clouds=split($('#listClouds').value); state.lists.HookLocation=split($('#listHookLoc').value); save(); indicateSaved(); fillAllSelects(); }
	// (Removed duplicate event listeners for #saveLists and #restoreDefaults)
		function currentTripId(){ return $('#tripSelect').value || null; }
	function ensureTrip(){ let id=currentTripId(); if(!id){ id=uid(); state.trips[id]={id, header:{}, entries:[], active:false, createdAt:Date.now(), updatedAt:Date.now()}; $('#tripSelect').value=id; save(); indicateSaved(); refreshTripSelect(); } return id; }
	function refreshTripSelect(){ const sel=$('#tripSelect'); const opts=Object.values(state.trips).sort((a,b)=>{ const ad=(b.header && b.header.date) || ''; const bd=(a.header && a.header.date) || ''; return ad.localeCompare(bd); }); sel.innerHTML = opts.map(t=>`<option value="${t.id}">${(t.header && t.header.date)||'(no date)'} â€¢ ${ (t.header && t.header.port) || 'Port'}</option>`).join(''); }
	function saveHeader(){ const id=currentTripId()||uid(); state.trips[id]=state.trips[id]||{id, header:{}, entries:[], active:false, createdAt:Date.now(), updatedAt:Date.now()}; state.trips[id].header={ date:$('#tripDate').value, startTime:$('#startTime').value, port:$('#port').value, boat:$('#boat').value, crew:$('#crew').value, hours:$('#hours').value, airTemp:$('#airTemp').value, surfaceTemp:$('#surfaceTemp').value, wind:$('#wind').value, waves:$('#waves').value, clouds:$('#clouds').value, gearNotes:$('#gearNotes')?$('#gearNotes').value:'' }; state.trips[id].updatedAt=Date.now(); state.trips[id].active = true; save(); refreshTripSelect(); $('#tripSelect').value=id; toast('Trip started'); setTimeout(hideToast, 1200); location.hash = '#tab-log'; try{ window.scrollTo({ top: 0, left: 0, behavior: 'auto' }); }catch(_){ window.scrollTo(0,0); } setTimeout(()=>{ try{ window.scrollTo({ top: 0, left: 0, behavior: 'auto' }); }catch(_){ window.scrollTo(0,0); } }, 50); applyActiveTripGating(); }

	// Determine active via explicit flag set on Start Trip and cleared on End/New
	function isTripActive(){ const t=state.trips[currentTripId()]; return !!(t && t.active === true); }
	function applyActiveTripGating(){ const active = isTripActive(); const logSec = document.getElementById('tab-log'); if(logSec){ if(active) logSec.classList.remove('hide'); else logSec.classList.add('hide'); }
		// Title: strictly based on active flag
	try{ const headerTitle = document.querySelector('#tab-setup .section-title'); if(headerTitle){ headerTitle.textContent = active ? 'Edit Setup' : 'New Trip'; headerTitle.style.color = active ? 'var(--accent-2)' : ''; } }catch(e){}
		// Menu: hide Catch Log link when inactive
		try{ const logLink = document.querySelector('#navMenuRR a[href="#tab-log"]'); if(logLink){ logLink.style.display = active ? '' : 'none'; } }catch(e){}
	}

	// End Trip: export/push then reset to fresh trip
	async function endTripFlow(){
		const id = currentTripId(); if(!id) { toast('No trip selected'); return; }
		const t = state.trips[id]; if(!t) { toast('No trip selected'); return; }
		// Attempt push when online and configured, but always export CSV locally
		const url = (state.settings && state.settings.sheetWebAppUrl) ? state.settings.sheetWebAppUrl.trim() : '';
		const secret = (state.settings && state.settings.sheetSecret) ? state.settings.sheetSecret.trim() : '';
		const online = navigator.onLine;
		let pushed = false;
		if(online && url && secret){
			try{ await pushFullTrip(); pushed = true; }catch(e){ console.warn('endTrip push failed', e); }
		}
		try{ await exportCsv(); }catch(e){ console.warn('local export failed', e); }
		// Reset to a fresh trip (keep preferences)
		await resetToFreshTrip();
		location.hash = '#tab-setup';
		toast('Trip ended â€¢ exported locally' + (pushed? ' â€¢ pushed to Sheet' : ''));
		setTimeout(hideToast, 2200);
	}
	attach('#endTrip','click', ()=>{
		const ok = confirm('End current trip, export locally, and start a new blank trip?\n\nTip: Ensure important notes are saved.');
		if(ok) endTripFlow();
	});

	async function resetToFreshTrip(){
		const id = currentTripId(); if(!id) { ensureTrip(); return; }
		const t = state.trips[id]; if(t){
			try{ for(const e of (t.entries||[])){ if(e.photo){ try{ await deletePhoto(e.id); }catch(_){} } } }catch(_){ }
		}
		// Create new blank trip and select it, keep old trip for history
		try{ if(t) t.active = false; }catch(_){ }
		const newId = uid(); state.trips[newId] = { id:newId, header:{}, entries:[], active:false, createdAt:Date.now(), updatedAt:Date.now() };
		save(); refreshTripSelect();
		const sel = document.getElementById('tripSelect'); if(sel) sel.value = newId;
		loadHeaderIntoForm(); renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge(); applyActiveTripGating();
	}
  
	// (Removed duplicate event listeners for #saveTrip, #newTrip, #tripSelect)
	function loadHeaderIntoForm(){ const t=state.trips[currentTripId()]; if(!t) return; const h=t.header||{}; $('#tripDate').value=h.date||''; $('#startTime').value=h.startTime||''; $('#port').value=h.port||''; $('#boat').value=h.boat||''; $('#crew').value=h.crew||''; $('#hours').value=h.hours||''; $('#airTemp').value=h.airTemp||''; $('#surfaceTemp').value=h.surfaceTemp||''; $('#wind').value=h.wind||''; $('#waves').value=h.waves||''; $('#clouds').value=h.clouds||''; const g=$('#gearNotes'); if(g) g.value=h.gearNotes||''; }
	// (Removed duplicate event listener for #platform)
		function setNow(){ const d=new Date(); $('#time').value=d.toTimeString().slice(0,5); if(!$('#tripDate').value) $('#tripDate').value=d.toISOString().slice(0,10); if(!$('#startTime').value) $('#startTime').value=d.toTimeString().slice(0,5); }
	// (Removed duplicate event listener for #nowBtn)
	setNow();
	const photoInput = $('#photoInput'); const photoPreview = $('#photoPreview'); const clearPhotoBtn = $('#clearPhoto'); let pendingPhotoDataURL='';
	function fileToDataURLResized(file, maxDim=1600, quality=0.82){ return new Promise((resolve,reject)=>{ const fr=new FileReader(); fr.onload=()=>{ const img=new Image(); img.onload=()=>{ const c=document.createElement('canvas'); let w=img.width,h=img.height; const scale=Math.min(1, maxDim/Math.max(w,h)); const nw=Math.max(1,Math.round(w*scale)), nh=Math.max(1,Math.round(h*scale)); c.width=nw; c.height=nh; c.getContext('2d').drawImage(img,0,0,nw,nh); try{ resolve(c.toDataURL('image/jpeg', quality)); }catch(e){ reject(e); } }; img.onerror=reject; img.src=fr.result; }; fr.onerror=reject; fr.readAsDataURL(file); }); }
	function readVal(id){ const el=document.querySelector(id); return (el && el.value || '').trim(); } function num(x){ return x?Number(x):''; }
	function fmt12hFromParts(timeStr){ // expects HH:MM or blank
		if(!timeStr) return '';
		const m = /^(\d{1,2}):(\d{2})$/.exec(timeStr);
		if(!m) return timeStr;
		let h = parseInt(m[1],10); const min=m[2]; const ampm = h>=12? 'PM':'AM'; h = h%12; if(h===0) h=12; return `${h}:${min} ${ampm}`;
	}
	function fmt12hFromDate(d){ try{ let h=d.getHours(), m=d.getMinutes(); const ampm=h>=12?'PM':'AM'; h=h%12; if(h===0) h=12; return `${h}:${String(m).padStart(2,'0')} ${ampm}`; }catch(_){ return ''; }}
	function computeTs(header, timeStr){ if(header && header.date && timeStr){ const ds=header.date+'T'+timeStr+':00'; const d=new Date(ds); if(!isNaN(d)) return d.getTime(); } return Date.now(); }
		let editingEntryId=null; let undoTimer=null; let pendingDelete=null; const UNDO_MS=12000;
		function setEditing(on){ editingEntryId = on?editingEntryId:null; $('#cancelEdit').style.display = on?'inline-block':'none'; $('#addEntry').textContent = on?'Update entry':'Save entry'; }
		function validateEntry(isQuick){ const req=[]; const time=readVal('#time'); const platform=readVal('#platform'); const species=readVal('#species'); const lureType=readVal('#lureType'); const water=readVal('#waterDepth'); const target=readVal('#targetDepth'); if(!time) req.push('#time'); if(!platform) req.push('#platform'); if(!species) req.push('#species'); if(!lureType) req.push('#lureType'); if(!water && !target) { req.push('#waterDepth'); req.push('#targetDepth'); }
			$$('#tab-log input, #tab-log select').forEach(el=> el.classList.remove('invalid')); req.forEach(sel=>{ const el=$(sel); if(el) el.classList.add('invalid'); }); return { ok: req.length===0, missing:req };
		}
			async function addOrUpdateEntry(force=false){ const t=state.trips[ensureTrip()]; const header=t.header; const quick=state.settings.quickMode; const v=validateEntry(quick); if(!v.ok && !force){ $('#forceSave').style.display='inline-block'; toast('Missing required fields. Fill red or tap Force.'); return; } $('#forceSave').style.display='none'; const base={ id: editingEntryId||uid(), time:readVal('#time'), platform:readVal('#platform'), trollDir:readVal('#trollDir'), waterDepth:num(readVal('#waterDepth')), ballDepth:num(readVal('#ballDepth')), ballWeight:num(readVal('#ballWeight')), dipsySize:readVal('#dipsySize'), dipsySetting:readVal('#dipsySetting'), copperLen:num(readVal('#copperLen')), leadcoreColors:readVal('#leadcoreColors'), targetDepth:num(readVal('#targetDepth')), lureType:readVal('#lureType'), lureBrand:readVal('#lureBrand'), lureSize:readVal('#lureSize'), lureColor:readVal('#lureColor'), attractor:readVal('#attractor'), flyMeat:readVal('#flyMeat'), speedBall:num(readVal('#speedBall')), sog:num(readVal('#sog')), strikeDepthSeen:num(readVal('#strikeDepthSeen')), species:readVal('#species'), lengthIn:num(readVal('#lengthIn')), weightLb:num(readVal('#weightLb')), gps:readVal('#gps'), notes:readVal('#notes'), photo:false };
				if(!base.time) setNow(); base.ts = computeTs(header, base.time); if(pendingPhotoDataURL){ try{ await savePhoto(base.id, pendingPhotoDataURL); base.photo=true; }catch(e){ alert('Could not save photo: '+e.message); } }
			if(editingEntryId){ const idx=t.entries.findIndex(e=>e.id===editingEntryId); if(idx>-1){ const existingPhoto=t.entries[idx].photo; if(existingPhoto && !base.photo) base.photo=true; t.entries[idx]=Object.assign({}, t.entries[idx], base); toast('Entry updated'); }
			} else { t.entries.push(base); if(state.settings.sticky){ // keep lure fields
					['lureType','lureBrand','lureSize','lureColor','attractor','flyMeat','lineType','lineStrength'].forEach(id=>{/*sticky implies leave value*/});
				} else { /* will clear below */ }
			}
	t.updatedAt=Date.now(); save(); indicateSaved(); renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge(); if(editingEntryId){ setEditing(false); clearCatchForm(false); } else { clearCatchForm(!state.settings.sticky); }
		}
	function clearCatchForm(clearSticky){ $$('#tab-log input, #tab-log textarea, #tab-log select').forEach(el=>{ if(['time'].includes(el.id)) { setNow(); return; } if(!clearSticky && ['lureType','lureBrand','lureSize','lureColor','attractor','flyMeat'].includes(el.id)) return; if(['platform','trollDir','species','waterDepth','targetDepth'].includes(el.id)) { el.value=''; } else if(el.tagName==='TEXTAREA' || el.tagName==='INPUT' || el.tagName==='SELECT'){ el.value=''; } }); $$('.cond').forEach(x=>x.classList.add('hide')); pendingPhotoDataURL=''; photoInput.value=''; photoPreview.classList.add('hide'); photoPreview.src=''; }
	// (Removed duplicate event listener for #resetForm)
	async function renderEntries(){ const t=state.trips[currentTripId()]; const tbody=$('#entriesTable tbody'); if(!t){ tbody.innerHTML=''; return; } const rows=await Promise.all(t.entries.map(async e=>{ const lure=[e.lureType,e.lureBrand,e.lureColor].filter(Boolean).join(' â€¢ '); const depths=[`W:${e.waterDepth||'-'}`,`T:${e.targetDepth||'-'}`,(e.platform==='Downrigger'?`B:${e.ballDepth||'-'}`:'')].filter(Boolean).join(' / '); const dirSpd=[e.trollDir, e.speedBall?`${e.speedBall} mph`:''].filter(Boolean).join(' â€¢ '); let photoCell=''; if(e.photo){ const durl=await getPhoto(e.id); photoCell = durl ? `<img src="${durl}" class="thumb" alt="thumb" data-view="${e.id}"/>` : 'ðŸ“·'; } else { photoCell=''; } const rowClass = e.isBite ? ' class="bite-row"' : ''; const timeCell = `${e.isBite ? '<span class="pill badge bite">ðŸŽ¯ Bite</span> ' : ''}${fmt12hFromParts(e.time||'')}`; return `<tr${rowClass}><td>${timeCell}</td><td><span class=\"pill badge\">${e.platform||''}</span></td><td>${photoCell}</td><td>${lure}</td><td>${depths}</td><td>${dirSpd}</td><td>${e.species||''}</td><td style=\"text-align:right;white-space:nowrap\"><button class=\"btn secondary\" data-edit=\"${e.id}\">Edit</button> <button class=\"btn secondary\" data-viewbtn=\"${e.id}\">View</button> <button class=\"btn secondary\" data-del=\"${e.id}\">Delete</button></td></tr>`; })); tbody.innerHTML = rows.join(''); $$('button[data-del]').forEach(b=> b.onclick = ()=>{ delEntry(b.dataset.del); }); $$('button[data-viewbtn]').forEach(b=> b.onclick = ()=>{ openLightbox(b.dataset.viewbtn); }); $$('button[data-edit]').forEach(b=> b.onclick = ()=>{ startEdit(b.dataset.edit); }); $$('img[data-view]').forEach(img=> img.onclick = ()=>{ openLightbox(img.dataset.view); }); }
	function loadEntryIntoForm(e, duplicate=false){ ['time','platform','trollDir','waterDepth','ballDepth','ballWeight','dipsySize','dipsySetting','copperLen','leadcoreColors','targetDepth','lureType','lureBrand','lureSize','lureColor','attractor','flyMeat','speedBall','sog','strikeDepthSeen','species','lengthIn','weightLb','gps','notes'].forEach(id=>{ const el=$('#'+id); if(el && e[id]) el.value = e[id] ?? ''; }); if(e.platform) $('#platform').dispatchEvent(new Event('change')); if(!duplicate){ editingEntryId=e.id; setEditing(true); pendingPhotoDataURL=''; photoPreview.classList.add('hide'); photoPreview.src=''; } }
	function startEdit(id){ const t=state.trips[currentTripId()]; if(!t) return; const e=t.entries.find(x=>x.id===id); if(!e) return; loadEntryIntoForm(e,false); toast('Editing entry'); }
	async function delEntry(id){ const t=state.trips[currentTripId()]; if(!t) return; const e=t.entries.find(x=>x.id===id); if(!e) return; const photoData = e.photo ? await getPhoto(e.id) : null; t.entries = t.entries.filter(x=>x.id!==id); save(); indicateSaved(); renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge(); scheduleUndo({ entry:e, photo:photoData }); }
	function scheduleUndo(payload){ pendingDelete=payload; showUndo(); if(undoTimer) clearTimeout(undoTimer); undoTimer=setTimeout(()=>{ finalizeDelete(); }, UNDO_MS); }
	function finalizeDelete(){ if(!pendingDelete) return; if(pendingDelete.entry.photo){ deletePhoto(pendingDelete.entry.id).catch(()=>{}); } pendingDelete=null; hideToast(); }
	function undoDelete(){ if(!pendingDelete) return; const t=state.trips[currentTripId()]; if(!t){ pendingDelete=null; return; } t.entries.push(pendingDelete.entry); save(); indicateSaved(); renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge(); pendingDelete=null; hideToast(); toast('Restored'); }
		async function openLightbox(entryId){ const durl = await getPhoto(entryId); if(!durl){ alert('No photo for this entry.'); return; } $('#lightboxImg').src=durl; $('#lightbox').classList.remove('hide'); }
	// lightbox handlers are attached inside DOMContentLoaded above (guarded). Duplicate handlers removed.
		function renderSummary(){ const t=state.trips[currentTripId()]; const box=$('#summary'); if(!t||!t.entries.length){ box.innerHTML='<span class="muted">No entries yet.</span>'; return; } const h=t.header||{}; const n=t.entries.length; const landed=t.entries.filter(e=>e.landed==='Y').length; const kept=t.entries.filter(e=>e.keptRel==='Kept').length; const bestWaterDepth=mode(t.entries.map(e=>e.waterDepth).filter(Number.isFinite)); const bestTargetDepth=mode(t.entries.map(e=>e.targetDepth).filter(Number.isFinite)); const bestLureType=mode(t.entries.map(e=>e.lureType).filter(Boolean)); const bestColor=mode(t.entries.map(e=>e.lureColor).filter(Boolean)); const bestDir=mode(t.entries.map(e=>e.trollDir).filter(Boolean)); const lengths=t.entries.map(e=>e.lengthIn).filter(Number.isFinite); const weights=t.entries.map(e=>e.weightLb).filter(Number.isFinite); const avg=(arr)=> (arr.length? (arr.reduce((a,b)=>a+b,0)/arr.length).toFixed(1):''); const chips=[`Date: <b>${h.date||'-'}</b>`,`Port: <b>${h.port||'-'}</b>`,`Crew: <b>${h.crew||'-'}</b>`,`Entries: <b>${n}</b>`,`Landed: <b>${landed}</b>`,`Kept: <b>${kept}</b>`,`Best water depth: <b>${bestWaterDepth||'-'}</b>`,`Best target depth: <b>${bestTargetDepth||'-'}</b>`,`Best direction: <b>${bestDir||'-'}</b>`,`Best lure: <b>${bestLureType||'-'}</b>`,`Best color: <b>${bestColor||'-'}</b>`]; if(lengths.length>=2) chips.push(`Avg length: <b>${avg(lengths)} in</b>`); if(weights.length>=2) chips.push(`Avg weight: <b>${avg(weights)} lb</b>`); box.innerHTML='<div class="grid cols-3">'+chips.map(c=>`<div class="chip">${c}</div>`).join('')+'</div>'; }
	function updateLogBadge(){ const t=state.trips[currentTripId()]; const badge=$('#logCountBadge'); if(!badge) return; const n=(t && t.entries && t.entries.length) || 0; if(n){ badge.style.display='inline-block'; badge.textContent=n; } else { badge.style.display='none'; } }
		function renderAnalytics(){ const t=state.trips[currentTripId()]; const box=$('#analytics'); if(!box) return; if(!t||!t.entries.length){ box.innerHTML='(No data)'; return; } const entries=t.entries.slice(); const countBy=(k)=>{ const m={}; entries.forEach(e=>{ const v=e[k]; if(!v) return; m[v]=(m[v]||0)+1; }); return Object.entries(m).sort((a,b)=>b[1]-a[1]); }; const top=(arr,n=3)=>arr.slice(0,n).map(([k,v])=>`${k} (${v})`).join(', '); const platforms=countBy('platform'); const species=countBy('species'); const lureTypes=countBy('lureType'); const colors=countBy('lureColor'); // depth buckets 10 ft
			function bucket(arr){ const m={}; arr.filter(Number.isFinite).forEach(v=>{ const b=Math.floor(v/10)*10; const label=`${b}-${b+9}`; m[label]=(m[label]||0)+1; }); return Object.entries(m).sort((a,b)=>{ const na=parseInt(a[0]); const nb=parseInt(b[0]); return na-nb; }); }
			const wdBuckets=bucket(entries.map(e=>e.waterDepth)); const tdBuckets=bucket(entries.map(e=>e.targetDepth)); // timeline 15 min
			const timeline=(()=>{ const pts=entries.filter(e=>e.ts); if(!pts.length) return []; const min=Math.min(...pts.map(e=>e.ts)); const max=Math.max(...pts.map(e=>e.ts)); const span=15*60*1000; const buckets=[]; for(let tms=Math.floor(min/span)*span; tms<=max; tms+=span){ buckets.push({ t:tms, c:0 }); } pts.forEach(e=>{ const idx=Math.floor((e.ts - buckets[0].t)/span); if(buckets[idx]) buckets[idx].c++; }); return buckets; })();
			const spark=timeline.map(b=>{ const tt = fmt12hFromDate(new Date(b.t)); return `<div class="spark" style="width:6px;height:${4+Math.min(30,b.c*6)}px" title="${tt}: ${b.c}"></div>`; }).join('');
			const fmtList=(list)=> list.map(([k,v])=>`${k}: <b>${v}</b>`).join(' â€¢ ');
			box.innerHTML=`<h4>Platforms</h4>${fmtList(platforms)||'-'}<h4>Species</h4>${fmtList(species)||'-'}<h4>Lure Types (Top)</h4>${top(lureTypes)||'-'}<h4>Colors (Top)</h4>${top(colors)||'-'}<h4>Water Depth (10s)</h4>${wdBuckets.map(([k,v])=>`${k}: <b>${v}</b>`).join(' â€¢ ')||'-'}<h4>Target Depth (10s)</h4>${tdBuckets.map(([k,v])=>`${k}: <b>${v}</b>`).join(' â€¢ ')||'-'}<h4>Timeline 15m</h4><div style="display:flex;align-items:flex-end;height:50px;">${spark}</div>`;
		}
		function mode(arr){ if(!arr.length) return ''; const map=new Map(); arr.forEach(v=>map.set(v,(map.get(v)||0)+1)); let m='',c=0; map.forEach((n,k)=>{ if(n>c){c=n;m=k;} }); return m; }
		function toCsvRow(fields){ return fields.map(v=>{ if(v===null||v===undefined) v=''; v=String(v); if(/[",\n]/.test(v)) v='"'+v.replace(/"/g,'""')+'"'; return v; }).join(','); }
		async function exportCsv(){ const t=state.trips[currentTripId()]; if(!t) return alert('No trip.'); const h=['TripDate','Time','Timestamp','PortArea','GPS_Lat','GPS_Lon','Waypoint','WaterDepth_ft','SurfaceTemp_F','Platform','DipsySize','DipsySetting','RiggerBallWeight_lb','RiggerBallDepth_ft','TargetDepth_ft','StrikeDepthSeen_ft','SpeedAtBall_mph','SOG_mph','TrollDirection','LureType','LureBrand','LureModel','LureSize','LureColor','Attractor/Flasher','Fly/MeatColor','Species','Length_in','Weight_lb','Notes','HasPhoto']; const lines=[toCsvRow(h)]; const hdr=t.header||{};
		for(const e of t.entries){
			const parts=(e.gps||'').split(',');
			const lat=(parts[0] && parts[0].trim())||'';
			const lon=(parts[1] && parts[1].trim())||'';
				const row=[
				hdr.date||'',             // TripDate
				fmt12hFromParts(e.time||''),               // Time
				e.ts||'',                 // Timestamp
				hdr.port||'',             // PortArea
				lat||'',                  // GPS_Lat
				lon||'',                  // GPS_Lon
				'',                       // Waypoint
				e.waterDepth||'',         // WaterDepth_ft (inserted)
				hdr.surfaceTemp||'',      // SurfaceTemp_F
				e.platform||'',           // Platform
				e.dipsySize||'',          // DipsySize
				e.dipsySetting||'',       // DipsySetting
				e.ballWeight||'',         // RiggerBallWeight_lb
				e.ballDepth||'',          // RiggerBallDepth_ft
				e.targetDepth||'',        // TargetDepth_ft
				e.strikeDepthSeen||'',    // StrikeDepthSeen_ft
				e.speedBall||'',          // SpeedAtBall_mph
				e.sog||'',                // SOG_mph
				e.trollDir||'',           // TrollDirection
				e.lureType||'',           // LureType
				e.lureBrand||'',          // LureBrand
				'',                       // LureModel
				e.lureSize||'',           // LureSize
				e.lureColor||'',          // LureColor
				e.attractor||'',          // Attractor/Flasher
				e.flyMeat||'',            // Fly/MeatColor
				e.species||'',            // Species
				e.lengthIn||'',           // Length_in
				e.weightLb||'',           // Weight_lb
				e.notes||'',              // Notes
				e.photo?'Y':'N'           // HasPhoto
			];
			lines.push(toCsvRow(row));
		}
		download('catches_'+(hdr.date||'trip')+'.csv', lines.join('\n'));
	}
	async function exportJson(){ const id=currentTripId(); if(!id) return alert('No trip.'); const t=state.trips[id]; const photos={}; for(const e of t.entries){ if(e.photo){ photos[e.id]=await getPhoto(e.id); } } const out=Object.assign({}, t, { photos: photos, exportVersion:2 }); const fname='trip_'+(((t.header && t.header.date) || id))+'.json'; download(fname, JSON.stringify(out,null,2)); }
	async function exportAlbum(){ const id=currentTripId(); if(!id) return alert('No trip.'); const t=state.trips[id]; const photos=[]; for(const e of t.entries){ if(e.photo){ photos.push({id:e.id, time:e.time, species:e.species, lure:[e.lureType,e.lureBrand,e.lureColor].filter(Boolean).join(' â€¢ '), durl: await getPhoto(e.id)}); } } const tripDate = (t.header && t.header.date) || 'trip'; const html='<!doctype html><meta charset="utf-8"><title>Album '+tripDate+'</title><style>body{font-family:system-ui;background:#0e131b;color:#e8eefb;margin:0;padding:16px}h1{font-size:20px} .g{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px} figure{margin:0;background:#151b26;border:1px solid #243349;border-radius:12px;overflow:hidden} img{width:100%;height:200px;object-fit:cover;display:block} figcaption{padding:8px 10px;font-size:12px;color:#b9c9e3} </style><h1>Trip '+tripDate+'</h1><div class="g">'+photos.map(p=>'<figure><img src="'+p.durl+'"><figcaption>'+ (p.time||'') +' â€¢ '+ (p.species||'') +'<br>'+ (p.lure||'') +'</figcaption></figure>').join('')+'</div>'; download('album_'+tripDate+'.html', html); }
	// Push trip summary to Google Sheets Web App (Apps Script). Requires settings: sheetWebAppUrl and sheetSecret
	async function pushTripToSheet(){ const id=currentTripId(); if(!id) return alert('No trip selected'); const t=state.trips[id]; const hdr=t.header||{}; let url = (state.settings && state.settings.sheetWebAppUrl) ? state.settings.sheetWebAppUrl.trim() : ''; let secret = (state.settings && state.settings.sheetSecret) ? state.settings.sheetSecret.trim() : ''; // defensive fallback: read directly from form if state wasn't persisted
		if(!url) url = (readVal('#sheetWebAppUrl') || '').trim(); if(!secret) secret = (readVal('#sheetSecret') || '').trim(); if(!url) return toast('Set Sheet Web App URL in Settings first');
		const payload = {
			secret: secret || '',
			tripDate: hdr.date || '',
			time: hdr.startTime || '',
			port: hdr.port || '',
			gpsLat: hdr.lastLat || '',
			gpsLon: hdr.lastLon || '',
			waterDepth: hdr.bestWaterDepth || '',
			surfaceTemp: hdr.surfaceTemp || '',
			notes: hdr.notes || ''
		};
		try{
			const r = await fetch(url, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
			if(!r.ok) { toast('Push failed: HTTP '+r.status); console.warn('pushTripToSheet failed', r.status); return; }
			const js = await r.json().catch(()=>null);
			if(js && js.ok) { toast('Trip pushed to Google Sheet'); } else { toast('Push completed; server response: '+(js && js.error? js.error : 'unknown')); }
		}catch(e){ console.warn('pushTripToSheet error', e); toast('Network error while pushing trip'); }
	}
	attach('#pushToSheet','click', ()=>{ pushTripToSheet(); });
	// Push full trip: send the entire trip (header + entries) in one POST.
	// Server (Apps Script) should accept payload.trip and append rows server-side.
	async function pushFullTrip(){
		const id = currentTripId(); if(!id) return alert('No trip selected');
		const t = state.trips[id]; const hdr = t.header || {};
		let url = (state.settings && state.settings.sheetWebAppUrl) ? state.settings.sheetWebAppUrl.trim() : '';
		let secret = (state.settings && state.settings.sheetSecret) ? state.settings.sheetSecret.trim() : '';
		// defensive fallback: read directly from form if state wasn't persisted
		if(!url) url = (readVal('#sheetWebAppUrl') || '').trim(); if(!secret) secret = (readVal('#sheetSecret') || '').trim();
		if(!url) return toast('Set Sheet Web App URL in Settings first');
		toast('Pushing full trip (single request)...');
		const payload = { secret: secret || '', trip: t };
		try{
			const r = await fetch(url, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
			if(!r.ok){ console.warn('pushFullTrip failed HTTP', r.status); // try no-cors fallback
				try{
					await fetch(url, { method:'POST', mode:'no-cors', body: JSON.stringify(payload) });
					toast('Push attempted (no-cors fallback). Check sheet.');
					return;
				}catch(nc){ console.warn('no-cors fallback failed', nc); toast('Push failed: HTTP '+r.status); return; }
			}
			const js = await r.json().catch(()=>null);
			if(js && js.ok){ toast('Full trip pushed (server appended rows)'); }
			else { toast('Push completed; server response: '+(js && js.error? js.error : 'unknown')); }
		}catch(err){
			console.warn('pushFullTrip network error', err);
			// try no-cors fallback as last resort
			try{
				await fetch(url, { method:'POST', mode:'no-cors', body: JSON.stringify(payload) });
				toast('Push attempted (no-cors fallback). Check sheet.');
			}catch(nc){
				console.warn('no-cors fallback failed', nc);
				toast('Network/CORS error while pushing full trip');
			}
		}
	}
	attach('#pushFullTrip','click', ()=>{ pushFullTrip(); });

	// Thermocline & Plan (beta) â€” lightweight implementation
	attach('#genThermoPlan','click', async ()=>{
		if(!(state.settings && state.settings.thermoBeta)) { toast('Enable beta in Settings'); return; }
		// ensure panel visible and navigate to Catch Log tab for context
		const panel = document.getElementById('thermoPlanPanel'); if(panel) panel.style.display = '';
		const statusEl = document.getElementById('thermoStatus'); const outEl = document.getElementById('thermoResult');
		if(statusEl) statusEl.textContent = 'Gathering sources...'; if(outEl) outEl.textContent = '';
		// switch to Catch Log so the panel is visible
		try{ location.hash = '#tab-log'; }catch(_){}
		try{
			const t = state.trips[currentTripId()]; if(!t) { if(statusEl) statusEl.textContent='No trip'; return; }
			const hdr = t.header || {}; const lat = parseFloat(hdr.lastLat||''); const lon = parseFloat(hdr.lastLon||'');
			if(!isFinite(lat) || !isFinite(lon)) { if(statusEl) statusEl.textContent='No GPS cached. Tap Catch Conditions (GPS) first.'; return; }
			const stations = (window.__stations||[]).slice();
			// simple corridor: within 30 km and +/- 10 km cross-track box (approx by distance only here)
			const near = stations.map(s=>({ s, d: haversineKm(lat,lon, s.lat, s.lon) }))
				.filter(x=> x.d <= 30)
				.sort((a,b)=> a.d - b.d)
				.slice(0, 12)
				.map(x=> x.s);
			if(statusEl) statusEl.textContent = `Found ${near.length} sources...`;
			// fetch profiles best-effort via stationJsonTemplate if present
			const tpl = (state.settings && state.settings.stationJsonTemplate) ? String(state.settings.stationJsonTemplate).trim() : '';
			const profiles = [];
			for(const s of near){
				let prof = null;
				if(tpl){
					const url = tpl.replace('{station}', encodeURIComponent(s.id)).replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
					const u2 = url + (url.includes('?')?'&':'?') + 'prefer=ocean-spec';
					try{ const r = await fetch(u2, { cache:'no-store' }); if(r.ok){ const js = await r.json(); prof = normalizeProfile(js, s, lat, lon); } }catch(_){ }
				}
				if(prof) profiles.push(prof);
			}
			if(!profiles.length){ if(statusEl) statusEl.textContent = 'No profile data; estimating from surface and history...';
				// estimate band using surface temp and recent entries
				const surfF = parseFloat(hdr.surfaceTemp||'');
				const est = estimateFromHistory(t, isFinite(surfF)? (surfF-32)*5/9 : null);
				renderPlan(est, outEl, statusEl);
				return;
			}
			if(statusEl) statusEl.textContent = 'Analyzing stations...';
			const stationResults = profiles.map(p=> perStationThermo(p));
			if(statusEl) statusEl.textContent = 'Fusing corridor...';
			const comp = fuseThermo(stationResults, {lat, lon});
			renderPlan(comp, outEl, statusEl);
	}catch(e){ console.warn('thermo plan error', e); if(statusEl) statusEl.textContent = 'Failed to generate plan'; }
	});

	function haversineKm(aLat,aLon,bLat,bLon){ const toR=n=>n*Math.PI/180; const dLat=toR(bLat-aLat), dLon=toR(bLon-aLon); const la=toR(aLat), lb=toR(bLat); const h = Math.sin(dLat/2)**2 + Math.cos(la)*Math.cos(lb)*Math.sin(dLon/2)**2; return 2*6371*Math.asin(Math.sqrt(h)); }
	function normalizeProfile(js, station, userLat, userLon){
		// Accept shapes: { profile:[{z_m,t_c}], when?, ts?, time? }
		let profile = [];
		if(js && Array.isArray(js.profile)) profile = js.profile.map(p=>({ z_m: Number(p.z_m), t_c: Number(p.t_c) })).filter(p=> isFinite(p.z_m) && isFinite(p.t_c)).sort((a,b)=> a.z_m-b.z_m);
		if(!profile.length) return null;
		const ts = (js && (js.when || js.ts || js.time)) ? Number(js.when || js.ts || js.time) : Date.now();
		const ageH = Math.abs(Date.now() - ts)/3600000;
		const isChain = profile.length >= 5; // heuristic
		return { id: station.id, lat:station.lat, lon:station.lon, ts, age_h: ageH, isChain, profile };
	}
	function perStationThermo(p){
		const sm = smoothProfile(p.profile, 3);
		const grad = centralGradient(sm);
		// find peak gradient in plausible band (3..40 m)
		let peak = { z: NaN, g: -Infinity };
		for(const g of grad){ if(g.z>=3 && g.z<=40 && g.g>peak.g) peak = g; }
		const tc_conf = Math.max(0, Math.min(1, peak.g / 0.5)); // 0.5 Â°C/m ~ strong
		const iso52 = zAtTemp(sm, 11.1);
		const iso55 = zAtTemp(sm, 12.8);
		return { stationId: p.id, lat:p.lat, lon:p.lon, when:p.ts, z_tc_m: peak.z, tc_conf, iso52_m: iso52, iso55_m: iso55, isChain: !!p.isChain };
	}
	function smoothProfile(profile, win){ if(!Array.isArray(profile)||!profile.length) return profile||[]; const out=[]; const k=Math.max(1, Math.floor(win)); for(let i=0;i<profile.length;i++){ let sum=0,c=0; for(let j=i-k;j<=i+k;j++){ if(j>=0&&j<profile.length){ sum+=profile[j].t_c; c++; } } out.push({ z: profile[i].z_m, t: sum/c }); } return out; }
	function centralGradient(sm){ const g=[]; for(let i=1;i<sm.length-1;i++){ const dz = (sm[i+1].z - sm[i-1].z); const dT = (sm[i+1].t - sm[i-1].t); if(dz>0){ g.push({ z: sm[i].z, g: Math.abs(dT/dz) }); } } return g; }
	function zAtTemp(sm, tc){ for(let i=1;i<sm.length;i++){ const z0=sm[i-1].z, z1=sm[i].z; const t0=sm[i-1].t, t1=sm[i].t; if((t0-tc)*(t1-tc)<=0){ const r = (tc - t0)/((t1 - t0)||1); return z0 + r*(z1 - z0); } } return null; }
	function fuseThermo(st, ref){
		const now = Date.now();
		const rows = [];
		for(const r of st){ if(!isFinite(r.z_tc_m)) continue; const dKm = haversineKm(ref.lat, ref.lon, r.lat, r.lon); const dtH = Math.abs(now - r.when)/3600000; let w = Math.exp(-dKm/30) * Math.exp(-dtH/6) * (r.isChain?1.15:1.0) * Math.max(0.1, Math.min(1, r.tc_conf||0.5)); rows.push({ w, z:r.z_tc_m, iso52:r.iso52_m, iso55:r.iso55_m }); }
		if(!rows.length) return { cline_m: null, iso10_m: null, iso12_m: null, sources: 0, conf: 0 };
		const zAvg = wMean(rows.map(x=>[x.z,x.w])); const zStd = wStd(rows.map(x=>[x.z,x.w]), zAvg);
		const kept = rows.filter(x=>{ const out = Math.abs(x.z - zAvg) > 2.5*(zStd||1e-6); return !out || x.w>0.6; });
		const Z = wMean(kept.map(x=>[x.z,x.w]));
		const I52 = wMean(kept.filter(x=>isFinite(x.iso52)).map(x=>[x.iso52,x.w]));
		const I55 = wMean(kept.filter(x=>isFinite(x.iso55)).map(x=>[x.iso55,x.w]));
		const wSum = kept.reduce((s,x)=>s+x.w,0); const conf = Math.max(0, Math.min(1, wSum / (kept.length || 1)));
		return { cline_m: Z, iso10_m: I52, iso12_m: I55, sources: kept.length, conf };
	}
	function wMean(pairs){ if(!pairs.length) return null; let sw=0, s=0; for(const [v,w] of pairs){ if(isFinite(v)&&isFinite(w)){ s+=v*w; sw+=w; } } return sw? s/sw : null; }
	function wStd(pairs, mean){ if(!pairs.length||!isFinite(mean)) return 0; let sw=0, s=0; for(const [v,w] of pairs){ if(isFinite(v)&&isFinite(w)){ s+=w*Math.pow(v-mean,2); sw+=w; } } return sw? Math.sqrt(s/sw) : 0; }
	function estimateFromHistory(trip, sstC){
		// Use last 6 catches to infer band; fallback from waterDepth/targetDepth
		const recent = (trip.entries||[]).slice(-6);
		const depths = recent.map(e=> e.targetDepth || e.waterDepth).filter(n=> Number.isFinite(n));
		const avg = depths.length? depths.reduce((a,b)=>a+b,0)/depths.length : null;
		const estCline = avg? Math.max(10, Math.min(120, avg)) : 60;
		return { cline_m: estCline*0.3048, iso10_m: (estCline-15)*0.3048, iso12_m: (estCline-5)*0.3048, sources: 0 };
	}
	function renderPlan(comp, outEl, statusEl){
		const ft = m=> (m==null? 'â€”' : Math.round(m*3.28084));
		const cl = ft(comp.cline_m), i52 = ft(comp.iso10_m), i55 = ft(comp.iso12_m);
		const confPct = Math.round((comp.conf||0)*100);
		const rigs = [
			{ label:'Deep rigger', depth: i55? i55 : (cl? cl : 60), note:'Flasher/fly or meat in green/UV' },
			{ label:'High rigger', depth: i55? Math.max(10, i55-5) : (cl? Math.max(10, cl-10):50), note:'Mag or std spoon 5â€“10 ft above break' },
			{ label:'Dipsy', depth: cl? Math.max(30, cl-5) : 45, note:'8" paddle + fly; adjust for hits' }
		];
		const html = `
		  <div class="chip" style="display:block; border-radius:12px; line-height:1.4">Thermocline <b>${cl||'â€”'} ft</b> â€¢ 52Â°F <b>${i52||'â€”'} ft</b> â€¢ 55Â°F <b>${i55||'â€”'} ft</b><br/>Sources <b>${comp.sources||0}</b> â€¢ Confidence <b>${confPct}%</b></div>
		  <div class="kv-group" style="margin-top:10px">
			<div class="group-title">Recommended spread</div>
			<ul style="margin:4px 0 0; padding-left:18px; list-style:disc">
			  ${rigs.map(r=> `<li style=\"margin:6px 0\"><span class=\"pill depth\" style=\"margin-right:8px\">${r.depth} ft</span><strong>${r.label}</strong> â€“ ${r.note}</li>`).join('')}
			</ul>
		  </div>`;
		if(outEl) outEl.innerHTML = html.trim();
		if(statusEl) statusEl.textContent = 'Plan generated';
	}
    
	// Google Sheets / Drive upload helpers removed (app is local-only per user request)
		function download(name, content){ const blob=new Blob([content], {type:'text/plain;charset=utf-8'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1000); }
  
		attach('#addToHome','click', ()=>{ alert('Add to Home Screen:\n\nâ€¢ iPhone (Safari): Share â–¸ Add to Home Screen.\nâ€¢ Android (Chrome): â‹® menu â–¸ Add to Home screen.\n\nThis runs offline and saves to your device.'); });
		function migrate(){ if(!state.dataVersion){ state.dataVersion=3; }
			// Add ts to entries if missing
	Object.values(state.trips||{}).forEach(trip=>{ (trip.entries||[]).forEach(e=>{ if(!e.ts){ const ts=computeTs(trip.header, e.time); e.ts=ts; } }); });
	save(); indicateSaved(); }
	function initPrefs(){ $('#prefQuickDefault').checked = !!(state.settings && state.settings.quickMode); $('#prefSticky').checked = ((state.settings && state.settings.sticky) !== false); $('#prefThermoBeta').checked = !!(state.settings && state.settings.thermoBeta); }
	function savePrefs(){ state.settings = state.settings || {}; state.settings.quickMode = $('#prefQuickDefault').checked; state.settings.sticky = $('#prefSticky').checked; state.settings.thermoBeta = $('#prefThermoBeta').checked; const mj = ($('#marineJsonUrl') && $('#marineJsonUrl').value) ? $('#marineJsonUrl').value.trim() : ''; state.settings.marineJsonUrl = mj; const st = ($('#stationJsonTemplate') && $('#stationJsonTemplate').value) ? $('#stationJsonTemplate').value.trim() : ''; state.settings.stationJsonTemplate = st; save(); indicateSaved(); toast('Preferences saved'); applyQuickMode(); applyThermoVisibility(); }
	// persist sheet web app settings when saving prefs
	function loadSheetPrefsIntoForm(){ try{ const el = $('#sheetWebAppUrl'); if(el) el.value = (state.settings && state.settings.sheetWebAppUrl) || ''; }catch(e){} try{ const s = $('#sheetSecret'); if(s) s.value = (state.settings && state.settings.sheetSecret) || ''; }catch(e){} }
	// update savePrefs to persist new fields
	const _oldSavePrefs = savePrefs;
	savePrefs = function(){ _oldSavePrefs(); state.settings.sheetWebAppUrl = ($('#sheetWebAppUrl') && $('#sheetWebAppUrl').value) ? $('#sheetWebAppUrl').value.trim() : ''; state.settings.sheetSecret = ($('#sheetSecret') && $('#sheetSecret').value) ? $('#sheetSecret').value.trim() : ''; save(); indicateSaved(); toast('Preferences saved'); };
	// reattach handler so the button invokes the updated savePrefs wrapper
	attach('#savePrefs','click', savePrefs);
	function applyThermoVisibility(){
		const btn = document.getElementById('genThermoPlan');
		const panel = document.getElementById('thermoPlanPanel');
		const enabled = !!(state.settings && state.settings.thermoBeta);
		if(btn) btn.style.display = enabled ? '' : 'none';
		if(panel) panel.style.display = 'none'; // hidden by default; shown after generation
		const res = document.getElementById('thermoResult'); if(res && !enabled) res.textContent = 'Enable in Settings to use this.';
	}
		function applyQuickMode(){ const quick = state.settings.quickMode; // Update menu item too
			const qm=document.getElementById('quickModeMenu'); if(qm) qm.textContent = 'Quick Mode: '+(quick?'On':'Off');
			const essential = new Set(['time','platform','species','lureType','waterDepth','targetDepth']);
			$$('#tab-log .grid > div').forEach(div=>{ const input=div.querySelector('input,select,textarea'); if(!input) return; if(essential.has(input.id)) { div.classList.remove('quick-hidden'); } else { if(quick) div.classList.add('quick-hidden'); else div.classList.remove('quick-hidden'); } });
			// Hide rigger calc <details> in Quick Mode
			try{ const rc = document.getElementById('riggerCalc'); if(rc){ rc.style.display = quick ? 'none' : ''; } }catch(_){ }
		}
		function toast(msg, undo=false){ const el=$('#toast'); el.innerHTML = msg + (undo? ' <button class="btn secondary" id="undoBtn">Undo</button>':''); el.style.display='block'; if(undo){ setTimeout(()=>{ const b=$('#undoBtn'); if(b) b.onclick=()=>{ undoDelete(); }; },0); setTimeout(hideToast, 8000); } else { setTimeout(hideToast, 2000); } }
		function hideToast(){ const el=$('#toast'); el.style.display='none'; }
		function showUndo(){ toast('Entry deleted', true); }
		function init(){ ensureListsSeeded(); fillAllSelects(); listsToTextarea(); refreshTripSelect(); if(!currentTripId() && Object.keys(state.trips).length===0){ const id=uid(); state.trips[id]={id, header:{}, entries:[], active:false, createdAt:Date.now(), updatedAt:Date.now()}; save(); refreshTripSelect(); $('#tripSelect').value=id; } migrate(); initPrefs(); // load marine JSON URL into the settings input
		try{ const el = $('#marineJsonUrl'); if(el) el.value = (state.settings && state.settings.marineJsonUrl) || ''; }catch(e){}
	try{ const st = $('#stationJsonTemplate'); if(st) st.value = (state.settings && state.settings.stationJsonTemplate) || 'https://blfl-ndbc-proxy.elliottdanielp.workers.dev/stations/{station}.json'; }catch(e){}
		// load sheet prefs
		try{ loadSheetPrefsIntoForm(); }catch(e){}
				// load stations list (for nearest NDBC station lookup)
				try{
					fetch('stations.json', { cache: 'no-store' }).then(r=>r.json()).then(js=>{ window.__stations = js || [] }).catch(()=>{ window.__stations = []; });
				}catch(e){ window.__stations = []; }
			loadHeaderIntoForm(); applyQuickMode(); applyThermoVisibility(); updateLogBadge(); }
	attach('#prefSticky','change', ()=>{ /* immediate reflection not needed */ });
	attach('#prefQuickDefault','change', ()=>{ /* just state toggle on save */ });
	attach('#prefThermoBeta','change', ()=>{ /* just reflect on save */ });
		attach('#quickToggle','dblclick', ()=>{ // quick clear validation marks
			$$('#tab-log .invalid').forEach(el=>el.classList.remove('invalid')); });
		init();
		applyActiveTripGating();
	// Download button triggers the Catch Conditions flow (useful reminder)
	// Use guarded attaches for photo input, clear photo and downloadConditions
	attach('#photoInput', 'change', async () => { const input = document.querySelector('#photoInput'); const f = (input && input.files && input.files[0]); if(!f){ pendingPhotoDataURL=''; if(photoPreview) { photoPreview.classList.add('hide'); photoPreview.src=''; } return; } try{ pendingPhotoDataURL = await fileToDataURLResized(f); if(photoPreview){ photoPreview.src = pendingPhotoDataURL; photoPreview.classList.remove('hide'); } } catch(err){ alert('Photo error: '+err.message); } });
	attach('#clearPhoto', 'click', ()=>{ pendingPhotoDataURL=''; const input = document.querySelector('#photoInput'); if(input) input.value=''; if(photoPreview){ photoPreview.classList.add('hide'); photoPreview.src=''; } });
	// Test station template fetch button (settings area)
	attach('#testStationJson','click', async ()=>{
		try{
			const tpl = ($('#stationJsonTemplate') && $('#stationJsonTemplate').value) ? $('#stationJsonTemplate').value.trim() : '';
			if(!tpl){ toast('Set station JSON template first in Preferences'); return; }
			// pick nearest station if available
			const stations = window.__stations || [];
			let nearest = stations[0] || null;
			if(stations.length && ('geolocation' in navigator)){
				navigator.geolocation.getCurrentPosition(async pos=>{
					const lat = pos.coords.latitude, lon = pos.coords.longitude;
					const toR = n => n * Math.PI / 180;
					const hav = (a,b)=>{ const R=6371; const dLat=toR(b.lat-a.lat); const dLon=toR(b.lon-a.lon); const la=toR(a.lat), lb=toR(b.lat); const h = Math.sin(dLat/2)**2 + Math.cos(la)*Math.cos(lb)*Math.sin(dLon/2)**2; return 2*R*Math.asin(Math.sqrt(h)); };
					let best=null, bestD=Infinity; stations.forEach(s=>{ const d = hav({lat,lon}, {lat:s.lat, lon:s.lon}); if(d<bestD){ bestD=d; best=s; } }); if(best) nearest = best;
					const url = tpl.replace('{station}', encodeURIComponent(nearest.id)).replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
					try{
						const r = await fetch(url, { cache: 'no-store' }); if(!r.ok){ toast('Fetch failed: '+r.status); console.warn('station fetch failed', r.status, url); return; } const js = await r.json(); toast('Station JSON fetched OK'); console.log('station JSON', js);
					}catch(e){ toast('Fetch error (see console)'); console.warn('station fetch error', e); }
				}, err=>{ toast('Geolocation failed: '+(err && err.message)); console.warn('geolocation failed', err); });
			} else {
				try{
					const url = tpl.replace('{station}', encodeURIComponent(nearest && nearest.id || ''));
					const r = await fetch(url, { cache: 'no-store' }); if(!r.ok){ toast('Fetch failed: '+r.status); console.warn('station fetch failed', r.status, url); return; } const js = await r.json(); toast('Station JSON fetched OK'); console.log('station JSON', js);
				}catch(e){ toast('Fetch error (see console)'); console.warn('station fetch error', e); }
			}
		}catch(e){ toast('Test failed'); console.warn('testStationJson failed', e); }
	});
	attach('#debugStationJson','click', async ()=>{
		try{
			const tpl = ($('#stationJsonTemplate') && $('#stationJsonTemplate').value) ? $('#stationJsonTemplate').value.trim() : '';
			if(!tpl){ toast('Set station JSON template first in Preferences'); return; }
			const stations = window.__stations || [];
			let nearest = stations[0] || null;
			if(stations.length && ('geolocation' in navigator)){
				navigator.geolocation.getCurrentPosition(async pos=>{
					const lat = pos.coords.latitude, lon = pos.coords.longitude;
					const toR = n => n * Math.PI / 180;
					const hav = (a,b)=>{ const R=6371; const dLat=toR(b.lat-a.lat); const dLon=toR(b.lon-a.lon); const la=toR(a.lat), lb=toR(b.lat); const h = Math.sin(dLat/2)**2 + Math.cos(la)*Math.cos(lb)*Math.sin(dLon/2)**2; return 2*R*Math.asin(Math.sqrt(h)); };
					let best=null, bestD=Infinity; stations.forEach(s=>{ const d = hav({lat,lon}, {lat:s.lat, lon:s.lon}); if(d<bestD){ bestD=d; best=s; } }); if(best) nearest = best;
					const url = tpl.replace('{station}', encodeURIComponent(nearest.id)).replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
					const debugUrl = url + (url.includes('?')? '&' : '?') + 'debug=1&prefer=ocean-spec';
					try{
						const r = await fetch(debugUrl, { cache: 'no-store' });
						const js = await r.json();
						console.log('debug station response', js);
						if(js && js.raw){ toast('Raw data returned; see console'); } else if(js && (js.sstC!==undefined || js.waveM!==undefined)){ toast('Parsed station data returned; see console'); } else { toast('No usable data; see console'); }
					}catch(e){ toast('Debug fetch failed (see console)'); console.warn('debug fetch error', e); }
				}, err=>{ toast('Geolocation failed: '+(err && err.message)); console.warn('geolocation failed', err); });
			} else {
				try{
					const url = tpl.replace('{station}', encodeURIComponent(nearest && nearest.id || ''));
					const debugUrl = url + (url.includes('?')? '&' : '?') + 'debug=1&prefer=ocean-spec';
					const r = await fetch(debugUrl, { cache: 'no-store' });
					const js = await r.json();
					console.log('debug station response', js);
					if(js && js.raw){ toast('Raw data returned; see console'); } else if(js && (js.sstC!==undefined || js.waveM!==undefined)){ toast('Parsed station data returned; see console'); } else { toast('No usable data; see console'); }
				}catch(e){ toast('Debug fetch failed (see console)'); console.warn('debug fetch error', e); }
			}
		}catch(e){ toast('Debug failed'); console.warn('debugStationJson failed', e); }
	});
	// removed Download Conditions button
	function defaults(){ return { Platform:["Downrigger","Dipsy","Copper","Leadcore","Planer Board","Flatline"], LineType:["Wire","Braid","Mono","Fluorocarbon","Copper","Leadcore"], LureType:["Spoon","Plug","Flasher/Fly","Meat Rig","Spin-n-Glow","Other"], LureColors:["NBK","Blue Dolphin","UV Blue/Green","Glow Green","Glow White","Orange/Silver","Green Dolphin","UV Stud","Blue Bubble","Chrome/Green","Chrome/Blue","Bloody Nose"], Attractors:["8\" White Crush","8\" UV Stud","11\" Chrome-Green","11\" White Paddle","8\" Blue Bubble","8\" Green Dot"], FlyMeat:["Blue Fly","Green Fly","Blue/Green Fly","Green Meat","Blue Meat","UV Fly"], Species:["Chinook (King)","Coho","Steelhead","Lake Trout","Brown Trout","Other"], TrollDirection:["N","NE","E","SE","S","SW","W","NW"], Clouds:["Clear","Partly","Overcast","Fog"] }; }
	function ensureListsSeeded(){ const d=defaults(); state.lists = state.lists || {}; const keys=["Platform","LineType","LureType","LureColors","Attractors","FlyMeat","Species","TrollDirection","Clouds"]; keys.forEach(k=>{ if(!Array.isArray(state.lists[k]) || !state.lists[k].length){ state.lists[k] = d[k].slice(); } }); }
	function listsToTextarea(){ ensureListsSeeded(); $('#listPlatform').value = state.lists.Platform.join('\n'); $('#listLineType').value = state.lists.LineType.join('\n'); $('#listLureType').value = state.lists.LureType.join('\n'); $('#listLureColors').value = state.lists.LureColors.join('\n'); $('#listAttractors').value = state.lists.Attractors.join('\n'); $('#listFlyMeat').value = state.lists.FlyMeat.join('\n'); $('#listSpecies').value = state.lists.Species.join('\n'); $('#listTrollDir').value = state.lists.TrollDirection.join('\n'); $('#listClouds').value = state.lists.Clouds.join('\n'); }
	function textareaToLists(){ const split=t=>t.split('\n').map(s=>s.trim()).filter(Boolean); state.lists = state.lists || {}; state.lists.Platform=split($('#listPlatform').value); state.lists.LineType=split($('#listLineType').value); state.lists.LureType=split($('#listLureType').value); state.lists.LureColors=split($('#listLureColors').value); state.lists.Attractors=split($('#listAttractors').value); state.lists.FlyMeat=split($('#listFlyMeat').value); state.lists.Species=split($('#listSpecies').value); state.lists.TrollDirection=split($('#listTrollDir').value); state.lists.Clouds=split($('#listClouds').value); save(); indicateSaved(); fillAllSelects(); }

	// Log Bite popup behavior
	(function(){
		const btn = document.getElementById('logBiteBtn');
		const menu = document.getElementById('logBiteMenu');
		if(!btn || !menu) return;
		let open=false;
		function show(){ menu.hidden=false; requestAnimationFrame(()=> menu.classList.add('open')); btn.setAttribute('aria-expanded','true'); document.addEventListener('click', onDoc); open=true; }
		function hide(){ menu.classList.remove('open'); setTimeout(()=>{ menu.hidden=true; }, 120); btn.setAttribute('aria-expanded','false'); document.removeEventListener('click', onDoc); open=false; }
		function onDoc(e){ if(!menu.contains(e.target) && e.target!==btn) hide(); }
		btn.addEventListener('click', (e)=>{ e.stopPropagation(); open? hide(): show(); });
		Array.from(menu.querySelectorAll('[data-bite]')).forEach(el=> el.addEventListener('click', ()=>{ const plat = el.getAttribute('data-bite'); hide(); addBite(plat||''); }));
	})();

	async function addBite(platform){ const id = ensureTrip(); const t = state.trips[id]; const header = t.header || {}; const now = new Date(); const timeStr = now.toTimeString().slice(0,5); const entry={ id: uid(), time: timeStr, platform: platform, trollDir: readVal('#trollDir')||'', waterDepth: num(readVal('#waterDepth')), targetDepth: num(readVal('#targetDepth')), lureType: readVal('#lureType')||'', lureBrand: readVal('#lureBrand')||'', lureSize: readVal('#lureSize')||'', lureColor: readVal('#lureColor')||'', attractor: readVal('#attractor')||'', flyMeat: readVal('#flyMeat')||'', speedBall: num(readVal('#speedBall')), sog: num(readVal('#sog')), species: readVal('#species')||'', notes: (readVal('#notes')? (readVal('#notes')+' â€¢ ') : '') + 'Bite', ts: computeTs(header, timeStr), photo: false, isBite:true };
		t.entries.push(entry); t.updatedAt=Date.now(); save(); indicateSaved(); renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge(); toast('Bite logged'); setTimeout(hideToast, 1200); }
	// Manage Data actions â€” Clear current, Clear ALL, Delete trip
	attach('#clearTrip','click', async ()=>{
		const id = currentTripId(); if(!id) return alert('No trip selected');
		const t = state.trips[id]; if(!t) return;
		if(!confirm('Clear all entries for this trip? This cannot be undone.')) return;
		try{ for(const e of t.entries){ if(e.photo){ try{ await deletePhoto(e.id); }catch(_){} } } }catch(_){ }
		t.entries = [];
		save(); indicateSaved();
		renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge();
		toast('Trip entries cleared'); setTimeout(hideToast, 1600);
	});

	attach('#clearAll','click', async ()=>{
		if(!confirm('Clear ALL trips and photos on this device? This cannot be undone.')) return;
		// Clear photos store completely
		try{
			const db = await openDB();
			await new Promise((res,rej)=>{ const tx=db.transaction('photos','readwrite'); const st=tx.objectStore('photos'); st.clear(); tx.oncomplete=res; tx.onerror=()=>rej(tx.error); });
		}catch(_){ }
		state.trips = {};
		save(); refreshTripSelect();
		// Create a fresh blank trip to keep UI stable
		ensureTrip(); loadHeaderIntoForm();
		renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge();
		toast('All trips cleared'); setTimeout(hideToast, 1600);
	});

	attach('#deleteTrip','click', async ()=>{
		const id = currentTripId(); if(!id) return alert('No trip selected');
		const t = state.trips[id]; if(!t) return;
		if(!confirm('Delete this trip and its photos? This cannot be undone.')) return;
		try{ for(const e of t.entries){ if(e.photo){ try{ await deletePhoto(e.id); }catch(_){} } } }catch(_){ }
		delete state.trips[id];
		save(); refreshTripSelect();
		const keys = Object.keys(state.trips);
		if(keys.length){ $('#tripSelect').value = keys[0]; } else { ensureTrip(); }
		loadHeaderIntoForm(); indicateSaved();
		renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge();
		toast('Trip deleted'); setTimeout(hideToast, 1600);
	});
		// Register service worker for offline support (if available)
		if ('serviceWorker' in navigator) {
			// use relative path so it works on GitHub Pages project pages
			navigator.serviceWorker.register('service-worker.js').then(reg => {
				console.log('ServiceWorker registered:', reg.scope);
			}).catch(err => {
				console.warn('ServiceWorker registration failed:', err);
			});
		}


	// Header menu (dedicated icon button) â€” focus trap, Escape, outside click
	(function(){
		const toggle = document.getElementById('navToggleRR');
		const menu = document.getElementById('navMenuRR');
		if(!toggle || !menu) return;
		const links = Array.from(menu.querySelectorAll('a,button'));
		function updateActive(){ const h = location.hash || '#tab-setup'; links.forEach(a=>{ const href=a.getAttribute('href')||''; const is=href && href.startsWith('#') && href===h; if(is) a.setAttribute('aria-current','true'); else a.removeAttribute('aria-current'); }); }
		window.addEventListener('hashchange', updateActive); updateActive();
		let lastFocused=null;
		function open(){ lastFocused=document.activeElement; menu.hidden=false; requestAnimationFrame(()=> menu.classList.add('open')); toggle.setAttribute('aria-expanded','true'); const f=menu.querySelector('a,button'); if(f) f.focus(); document.addEventListener('click', onDoc); document.addEventListener('keydown', onKey); }
		function close(){ menu.classList.remove('open'); setTimeout(()=>{ menu.hidden=true; }, 120); toggle.setAttribute('aria-expanded','false'); document.removeEventListener('click', onDoc); document.removeEventListener('keydown', onKey); if(lastFocused) lastFocused.focus(); lastFocused=null; }
		function onDoc(e){ if(!menu.contains(e.target) && e.target!==toggle) close(); }
		function onKey(e){ if(e.key==='Escape'){ close(); return; } if(e.key==='Tab' && !menu.hidden){ const f=Array.from(menu.querySelectorAll('a,button')).filter(el=>!el.disabled); if(!f.length) return; const first=f[0], last=f[f.length-1]; if(e.shiftKey && document.activeElement===first){ e.preventDefault(); last.focus(); } else if(!e.shiftKey && document.activeElement===last){ e.preventDefault(); first.focus(); } } }
		toggle.addEventListener('click', e=>{ e.stopPropagation(); if(menu.hidden) open(); else close(); });
		links.forEach(a=> a.addEventListener('click', ()=> setTimeout(close, 50)));
	})();

// Downrigger cannonball speed calculator (simplified): show resultant mph and auto-fill Speed @ ball
(function(){
	function calc(){
		const sog = parseFloat(document.getElementById('riggerSog')?.value || '0'); // mph
		const weight = parseFloat(document.getElementById('riggerWeight')?.value || '0'); // lb
		const depth = parseFloat(document.getElementById('riggerDepth')?.value || '0'); // ft
		if(!isFinite(sog) || !isFinite(weight)) return;
		const waterDensity = 62.4; // lb/ft^3
		const dragCoeff = 0.8;     // assumed drag coefficient
		const radiusFt = 0.167;    // ~4 in diameter -> 0.167 ft radius
		const area = Math.PI * radiusFt * radiusFt; // frontal area ft^2
		const vX = sog * 5280 / 3600; // mph -> ft/s
		const vY = Math.sqrt(Math.max(0, (2 * weight) / (waterDensity * dragCoeff * area))); // ft/s
		const vR = Math.sqrt(vX*vX + vY*vY); // ft/s
		const mph = vR * 0.681818; // ft/s to mph
		const el = document.getElementById('riggerResult');
		if(!el) return;
		el.innerHTML = `<b>Resultant (mph): ${mph.toFixed(2)}</b><br><span class="hint">Inputs â€” SOG: ${sog.toFixed(1)} mph â€¢ Weight: ${weight.toFixed(0)} lb${isFinite(depth)&&depth>0?` â€¢ Depth: ${depth.toFixed(0)} ft`:''}</span>`;
		// auto-fill Speed @ ball
		try{ const sb = document.getElementById('speedBall'); if(sb){ sb.value = mph.toFixed(2); sb.classList.add('auto-filled'); setTimeout(()=> sb.classList.remove('auto-filled'), 2500); } }catch(_){ }
	}
	const btn = document.getElementById('calcRiggerBtn');
	if(btn) btn.addEventListener('click', calc);
})();
	</script>
</body>
</html>

