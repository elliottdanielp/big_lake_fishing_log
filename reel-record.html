<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
	<title>Big Lake Fishing Log</title>
	<link rel="manifest" href="manifest.json">
	<link rel="icon" href="favicon.ico">
	<link rel="icon" type="image/svg+xml" href="favicon.svg">
	<link rel="apple-touch-icon" href="icon-192.png">
	<style>
		:root { --bg:#0e131b; --card:#151b26; --ink:#e8eefb; --muted:#9fb0c8; --accent:#52a7ff; --accent-2:#2ed0a2; --danger:#ff6b6b; --warning:#ffd166; --good:#06d6a0; --shadow:rgba(0,0,0,.35); --radius:18px; }
		html, body { height:100%; } body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,sans-serif; background:var(--bg); color:var(--ink); }
		.wrap { max-width: 880px; margin:0 auto; padding: 8px; }
	/* Brand header: full-width bar with rounded bottom and centered title + tagline */
	header { position: sticky; top:0; z-index: 30; background: linear-gradient(180deg,#0b2944,#0e1a2a); backdrop-filter: blur(6px); border-bottom: none; border-radius: 0 0 14px 14px; box-shadow: 0 6px 20px rgba(0,0,0,0.45); }
	.bar { display:flex; gap:8px; align-items:center; padding: 14px 12px; }
	.title-container { display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; width:100%; }
	.title { font-weight:900; letter-spacing:0.6px; font-size:26px; color: #eaf6ff; text-shadow: 0 3px 14px rgba(0,0,0,0.5); }
	.tagline { margin-top:4px; font-size:13px; color:var(--accent-2); opacity:0.95; font-weight:700; letter-spacing:0.6px; animation: fadeUp .85s ease both; }
	@keyframes fadeUp{ from{ opacity:0; transform:translateY(6px);} to{ opacity:1; transform:translateY(0);} }
		.tabs { display:flex; gap:8px; overflow:auto; padding: 6px 8px 12px; }
		.tab-btn { flex:1; text-align:center; border:1px solid #26364c; background:#111622; color:var(--muted); padding:16px 0; border-radius:16px; font-weight:700; font-size:18px; }
		.tab-btn.active { color:#fff; border-color: var(--accent); box-shadow: 0 0 0 2px rgba(82,167,255,.15) inset; }
		.card { background:var(--card); border:1px solid #243349; border-radius: var(--radius); box-shadow: 0 8px 24px var(--shadow); padding:18px; }
		.grid { display:grid; grid-template-columns: 1fr; gap: 18px; } @media(min-width:720px){ .grid.cols-2{ grid-template-columns: 1fr 1fr; } .grid.cols-3{ grid-template-columns: repeat(3,1fr);} }
	/* prevent grid items from forcing horizontal overflow on small phones */
	.grid > div { min-width:0; }
		label { display:block; font-size: 16px; color: var(--muted); margin-bottom:8px; font-weight:600; } input, select, textarea, button { width:100%; box-sizing:border-box; border-radius:16px; border:1.5px solid #2a3b54; background:#0c111a; color:#fff; padding:18px; font-size:20px; margin-bottom:8px; }
		select { padding-right:24px; } textarea { min-height:100px; }
		.row { display:flex; gap:14px; } .row > * { flex:1; } .chip { display:inline-flex; align-items:center; gap:8px; background:#0c111a; border:1.5px dashed #2f3f57; padding:12px 14px; border-radius:999px; font-size:16px; color:var(--muted); }
		.muted { color:var(--muted); font-size:16px; } .hint { font-size:15px; color:#8cabd8; margin-top:8px; }
		.btn { background:linear-gradient(180deg,#0e7eed,#0a5fc1); border:none; font-weight:800; letter-spacing:.3px; cursor:pointer; font-size:20px; padding:18px 0; border-radius:16px; }
			.btn.sm { font-size:16px; padding:10px 12px; border-radius:12px; }
			.btn.xs { font-size:14px; padding:8px 10px; border-radius:10px; }
		.btn.secondary { background:#0c111a; border:1.5px solid #2b3e59; color:#cfe3ff; } .btn.good { background:linear-gradient(180deg,#14bd8d,#0da77a); }
		.btn.warn { background:linear-gradient(180deg,#ffb703,#f77f00); } .btn.danger { background:linear-gradient(180deg,#ff4d4d,#bf2e2e); }
		table { width:100%; border-collapse: collapse; } th, td { padding:16px; border-bottom:1.5px solid #223145; text-align:left; font-size:18px; }
		th { color:#b8cdf1; font-weight:800; font-size:18px; position: sticky; top:0; background:#162133; z-index:1; } tr:hover td { background:#121b2b; }
		.pill { padding:8px 14px; border-radius:9999px; font-size:16px; display:inline-block; } .pill.badge { background:#0c111a; border:1.5px solid #2f3f57; color:#b9c9e3; }
		.spacer { height:16px; } .section-title { font-weight:900; letter-spacing:.4px; font-size:24px; } .footer { color:var(--muted); text-align:center; font-size:16px; padding:18px 0 32px; }
		.hide { display:none !important; }
		.thumb { width:90px; height:90px; object-fit:cover; border-radius:14px; border:1.5px solid #2a3b54; }
		.thumb-row { display:flex; gap:14px; align-items:center; }
		.lightbox { position:fixed; inset:0; background:rgba(0,0,0,.85); display:flex; align-items:center; justify-content:center; padding:20px; z-index:9999; }
		.lightbox img { max-width:95vw; max-height:85vh; border-radius:18px; box-shadow:0 10px 30px rgba(0,0,0,.6); }
		.lightbox .close { position:absolute; top:14px; right:14px; }
	.invalid { border-color: var(--danger)!important; }
	.badge-count { background:var(--accent); color:#fff; font-size:16px; padding:4px 10px; border-radius:999px; margin-left:10px; line-height:1; }
	.quick-hidden { display:none !important; }
	/* Bite highlight styling */
	.bite-row td { background: rgba(46,208,162,0.08); }
	.bite-row td:first-child { border-left: 3px solid var(--accent-2); }
	.pill.badge.bite { background:#0c111a; border:1.5px solid var(--accent-2); color:#b9f3df; margin-right:8px; }
	.prefs-row { display:flex; gap:16px; flex-wrap:wrap; }
	.switch { position:relative; display:inline-flex; align-items:center; gap:8px; font-size:18px; cursor:pointer; }
	.switch input { width:auto; accent-color: var(--accent); }
	#analytics { font-size:16px; line-height:1.5; }
	#analytics h4 { margin:10px 0 4px; font-size:18px; letter-spacing:.5px; text-transform:uppercase; color:var(--muted); }
	.spark { display:inline-block; background:var(--accent); height:14px; margin-right:4px; border-radius:4px; }
	#toast { position:fixed; left:50%; transform:translateX(-50%); bottom:24px; background:#142032; color:#fff; padding:16px 24px; border:1.5px solid #21405c; border-radius:18px; box-shadow:0 6px 16px rgba(0,0,0,.4); display:none; z-index:99999; font-size:18px; }
	#toast button { width:auto; padding:10px 16px; margin-left:14px; font-size:18px; }
	/* Mobile-specific layout tweaks for smaller phones (iPhone) */
	@media(max-width:420px){
	input, select, textarea, button { padding:12px; font-size:16px; border-radius:12px; }
		.tab-btn { font-size:16px; padding:12px 8px; border-radius:14px; }
		.grid.cols-2, .grid.cols-3 { grid-template-columns: 1fr !important; }
		.row { flex-direction:column; }
		.card { padding:14px; }
		.section-title { font-size:20px; }
		.tabs { gap:6px; padding:6px 6px 8px; }
		#toast { font-size:16px; padding:12px 18px; bottom:18px; }
	/* Tighter header spacing on small phones */
	header { border-radius: 0 0 10px 10px; }
	.bar { padding:10px 8px; }
	.title { font-size:18px; }
	.tagline { font-size:12px; }
	/* logo removed: styling not required */
	}

/* anchored header dropdown (dedicated icon button, not title) */
.icon-btn { background:transparent; border:1px solid rgba(255,255,255,0.12); color:var(--ink); border-radius:12px; width:44px; height:44px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; }
.icon-btn svg { width:26px; height:26px; fill:none; stroke:#e8eefb; stroke-width:2.2; stroke-linecap:round; stroke-linejoin:round; }
.menu-list { position:absolute; top:calc(100% + 8px); left:0; min-width:240px; max-height:70vh; overflow:auto; -webkit-overflow-scrolling:touch; background:var(--card); border:1px solid #223145; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.5); padding:10px; z-index:60; display:flex; flex-direction:column; gap:8px; opacity:0; transform: translateY(4px) scale(0.98); transition: opacity .12s ease, transform .12s ease; }
.menu-list.open { opacity:1; transform: translateY(0) scale(1); }
.menu-list[hidden] { display:none; }
.menu-list .menu-link { text-decoration:none; color:var(--ink); padding:12px 14px; border-radius:10px; font-weight:700; font-size:18px; display:block; text-align:left; }
.menu-list .menu-link:hover, .menu-list .menu-link[aria-current="true"] { background:#0c1624; }
.menu-label { font-size:12px; letter-spacing:.6px; text-transform:uppercase; color:#89a2c4; padding:6px 8px 2px; }
.menu-sep { height:1px; background:#223145; margin:6px 4px; border-radius:1px; }
@media(min-width:720px){ .menu-list { left:50%; transform:translateX(-50%); } }
@media(max-width:520px){ .icon-btn { width:46px; height:46px; border-radius:14px; } }

	/* Ensure date/time native controls don't overflow their container on small screens */
	input[type="date"], input[type="time"]{ max-width:100%; box-sizing:border-box; }
	/* General guard: inputs should never overflow their parent columns */
	input, select, textarea { max-width:100%; box-sizing:border-box; }

	/* Slightly reduce input padding on small screens to avoid visual overflow */
	@media(max-width:420px){
		input, select, textarea { padding:10px 12px; font-size:15px; }
	.bar { height:84px; }
	}
	/* iPhone 15 Pro specific (approx CSS device width 393px) */
	@media(max-width:400px){
		input, select, textarea, button { padding:10px; font-size:15px; border-radius:10px; }
		.tab-btn { font-size:15px; padding:10px 8px; }
		.section-title { font-size:18px; }
		.card { padding:12px; }
		/* avoid inputs causing horizontal overflow */
		input, select, textarea { max-width:100%; box-sizing:border-box; }
	}
	/* global safety to avoid horizontal scrolling caused by shadows/rounded inputs */
	html,body{ overflow-x:hidden; }
	/* highlight for auto-filled fields */
	.auto-filled { outline: 2px solid var(--accent-2); box-shadow: 0 10px 30px rgba(46,208,162,0.12); transition: box-shadow .35s, outline .35s; }
	/* bottom action bar (mobile thumb-friendly) */
	#bottomBar { position: fixed; left: 12px; right: 12px; bottom: 18px; display:flex; gap:8px; justify-content:space-between; align-items:center; z-index:60; }
	#bottomBar .bar-btn { flex:1; padding:12px 10px; border-radius:14px; font-size:16px; }
	#saveStatus { margin-left:10px; min-width:120px; text-align:center; }
	@media(min-width:721px){ #bottomBar{ display:none; } }
	/* Rigger calc highlight when open */
	#riggerCalc { border:1.5px dashed #2f3f57; border-radius:12px; padding:8px; }
	#riggerCalc[open] { outline:2px solid var(--accent-2); box-shadow:0 0 0 3px rgba(46,208,162,.15) inset; }
	/* Trip setup gating until first conditions fetch */
	#tab-setup.pending-conditions .needs-conditions { display:none !important; }
	#tab-setup.pending-conditions .await-conditions { display:block !important; }
	.await-conditions { display:none; font-size:14px; margin-top:8px; color:var(--muted); }
	</style>
</head>
<body>
	<header>
		<div class="bar" style="justify-content:center; padding:10px 12px; position:relative;">
			<div class="menu-anchor" style="position:absolute; left:12px; top:8px;">
				<button id="navToggleRR" class="icon-btn" aria-expanded="false" aria-haspopup="true" aria-controls="navMenuRR" aria-label="Menu">
					<svg viewBox="0 0 24 24" aria-hidden="true">
						<path d="M4 6h14M4 12h14M4 18h14"/>
						<path d="M18 7l2 2l2-2"/>
					</svg>
				</button>
				<div id="navMenuRR" class="menu-list" hidden>
					<div class="menu-label">Playbook</div>
					<a href="index.html#playbook" class="menu-link">Overview</a>
					<div class="menu-sep" role="separator"></div>
					<div class="menu-label">Logging</div>
					<a href="#tab-setup" class="menu-link">Trip Setup</a>
					<a href="#tab-log" class="menu-link">Catch Log</a>
					<a href="#tab-review" class="menu-link">Review & Export</a>
					<a href="#tab-settings" class="menu-link">Settings</a>
					<div class="menu-sep" role="separator"></div>
					<button id="quickModeMenu" type="button" class="menu-link">Quick Mode: Off</button>
				</div>
			</div>
			<div class="title-container">
				<div class="title">Reel-Record</div>
				<div class="tagline">Log. Learn. Land More Fish</div>
			</div>
		</div>
	</header>
	<main class="wrap">
		<section id="tab-setup" class="grid">
			<div class="card">
				<div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
					<div class="section-title">Trip header</div>
					<button class="btn xs" id="fetchConditions" type="button" title="Use GPS to auto-fill conditions">Catch Conditions (GPS)</button>
				</div>
				<div class="row needs-conditions" style="margin-top:8px">
					<button id="genThermoPlan" class="btn secondary" type="button">Generate plan</button>
				</div>
				<div class="await-conditions">Tap <b>Catch Conditions (GPS)</b> to unlock trip fields.</div>
				<div class="grid cols-1 needs-conditions" style="margin-top:8px">
					<label for="tripSelect">Current trip</label>
					<select id="tripSelect"></select>
				</div>
				<div class="grid cols-2 needs-conditions">
					<div><label for="tripDate">Date</label><input id="tripDate" type="date" /></div>
					<div><label for="startTime">Start time</label><input id="startTime" type="time" /></div>
					<div><label for="port">Port / Area</label><input id="port" placeholder="e.g., St. Joseph, 80-160 FOW" /></div>
					<div><label for="boat">Boat</label><input id="boat" placeholder="Boat name" /></div>
					<div><label for="crew">Crew</label><input id="crew" placeholder="Who’s aboard" /></div>
					<div><label for="hours">Planned hours</label><input id="hours" type="number" inputmode="decimal" placeholder="e.g., 5" /></div>
				</div>
				<div class="grid cols-3 needs-conditions">
					<div><label for="airTemp">Air temp (°F)</label><input id="airTemp" type="number" inputmode="decimal" /></div>
					<div><label for="surfaceTemp">Surface temp (°F)</label><input id="surfaceTemp" type="number" inputmode="decimal" /></div>
					<div><label for="wind">Wind (dir/speed)</label><input id="wind" placeholder="e.g., WNW 10" /></div>
					<div><label for="waves">Waves (ft)</label><input id="waves" type="number" inputmode="decimal" /></div>
					<div><label for="clouds">Cloud cover</label><select id="clouds"></select></div>
				</div>
				<!-- removed Download and Manual Override per request -->
				<div style="margin-top:8px">
					<div class="muted">Tip: Tap <b>Catch Conditions (GPS)</b> before you leave to save latest conditions. Last cached: <span id="conditionsCached">—</span></div>
					<div class="muted">Nearest station: <span id="conditionsStation">—</span></div>
					<div id="marineSource" class="muted">Source: —</div>
					<div id="tripSlug" class="muted needs-conditions">Trip slug: —</div>
					<div id="marineSnapshot" style="margin-top:8px">
						<div class="section-title" style="font-size:18px; margin:6px 0 6px">Marine Snapshot</div>
						<div id="marineSnapStatus" class="muted" style="font-size:14px">—</div>
						<div id="marineSnapResult" style="margin-top:6px"></div>
						<div class="row needs-conditions" style="margin-top:6px">
							<button id="runMarineSnap" class="btn secondary sm" type="button">Update snapshot</button>
						</div>
					</div>
				</div>
				<div class="hint">Tip: You can edit dropdown options under <b>Settings → Lists</b>.</div>
				<div id="saveStatus" class="pill badge" style="display:inline-block;margin-top:8px">Saved</div>
			</div>
			<div class="card needs-conditions" id="gearCard">
				<div class="section-title">Gear</div>
				<label for="gearNotes">Notes on gear (rods, reels, boards, rigs)</label>
				<textarea id="gearNotes" placeholder="e.g., 2 Cannon downriggers, 300/250 copper on Ninja 9.5 boards, dipsy setups..."></textarea>
			</div>
			<div class="card needs-conditions" id="saveCard">
				<div class="section-title">Save / load trip</div>
				<div class="grid cols-2">
					<button class="btn good" id="saveTrip">Start Trip</button>
					<button class="btn secondary" id="newTrip">New trip</button>
				</div>
			</div>
		</section>
		<section id="tab-log" class="grid hide">
			<!-- Thermocline plan panel (shown after generation) -->
			<div class="card" id="thermoPlanPanel" style="display:none">
				<details open id="thermoDetails">
					<summary><strong>Thermocline & Plan</strong></summary>
					<div class="note" id="thermoStatus" style="margin-top:6px; font-size:14px"></div>
					<div id="thermoResult" style="margin-top:10px"></div>
				</details>
			</div>
			<div class="card">
				<div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
					<div class="section-title">Log a catch / bite</div>
					<div style="position:relative">
						<button id="logBiteBtn" class="icon-btn" type="button" title="Log a bite" aria-haspopup="true" aria-expanded="false">🎣✖</button>
						<div id="logBiteMenu" class="menu-list" hidden style="right:0; left:auto; min-width:200px">
							<div class="menu-label">Log Bite on...</div>
							<button class="menu-link" data-bite="Downrigger" type="button">Downrigger</button>
							<button class="menu-link" data-bite="Planer Board" type="button">Planer Board</button>
							<button class="menu-link" data-bite="Dipsy" type="button">Dipsy Diver</button>
						</div>
					</div>
				</div>
				<div class="grid cols-3">
					<div><label for="time">Time</label><input id="time" type="time" /></div>
					<div><label for="platform">Platform</label><select id="platform"></select></div>
					<div><label for="trollDir">Troll direction</label><select id="trollDir"></select></div>
				</div>
				<div class="grid cols-3">
					<div><label for="waterDepth">Water depth (ft)</label><input id="waterDepth" type="number" inputmode="numeric" /></div>
					<div class="cond cond-rigger hide"><label for="ballDepth">Ball depth (ft)</label><input id="ballDepth" type="number" inputmode="numeric" /></div>
					<div class="cond cond-rigger hide"><label for="ballWeight">Rigger ball weight (lb)</label><input id="ballWeight" type="number" inputmode="decimal" /></div>
					<div class="cond cond-dipsy hide"><label for="dipsySize">Dipsy size</label><input id="dipsySize" placeholder="#0/#1/#2/#3" /></div>
					<div class="cond cond-dipsy hide"><label for="dipsySetting">Dipsy setting</label><input id="dipsySetting" placeholder="e.g., 1.5" /></div>
					<div class="cond cond-copper hide"><label for="copperLen">Copper length (ft)</label><input id="copperLen" type="number" inputmode="numeric" /></div>
					<div class="cond cond-leadcore hide"><label for="leadcoreColors">Leadcore (colors)</label><input id="leadcoreColors" placeholder="e.g., 5c/7c" /></div>
					<div><label for="targetDepth">Target depth (ft)</label><input id="targetDepth" type="number" inputmode="numeric" /></div>
				</div>
				<div class="grid cols-3">
					<div><label for="lureType">Lure type</label><select id="lureType"></select></div>
					<div><label for="lureBrand">Brand / model</label><input id="lureBrand" placeholder="e.g., Moonshine RV, J-plug" /></div>
					<div><label for="lureSize">Size</label><input id="lureSize" placeholder="e.g., mag, standard, 4" /></div>
					<div><label for="lureColor">Color / pattern</label><select id="lureColor"></select></div>
					<div><label for="attractor">Attractor / flasher</label><select id="attractor"></select></div>
					<div><label for="flyMeat">Fly / meat color</label><select id="flyMeat"></select></div>
				</div>
				<!-- Downrigger speed calculator dropdown (moved from index.html) -->
				<details id="riggerCalc">
				  <summary><strong>Downrigger Cannonball Speed Calculator</strong></summary>
				  <div class="grid cols-3" style="margin-top:10px">
				    <div><label for="riggerSog">SOG (mph)</label><input id="riggerSog" type="number" inputmode="decimal" placeholder="2.6" /></div>
				    <div><label for="riggerWeight">Ball weight (lb)</label><input id="riggerWeight" type="number" inputmode="decimal" placeholder="15" /></div>
				    <div><label for="riggerDepth">Depth (ft)</label><input id="riggerDepth" type="number" inputmode="numeric" placeholder="e.g., 85" /></div>
				  </div>
				  <details style="margin-top:6px" id="riggerAdvanced">
				    <summary><strong>Advanced (angle-based)</strong></summary>
				    <div class="grid cols-3" style="margin-top:8px">
				      <div><label for="riggerCableOut">Cable out (ft)</label><input id="riggerCableOut" type="number" inputmode="numeric" placeholder="e.g., 110" /></div>
				      <div><label for="riggerBallShape">Ball shape</label>
				        <select id="riggerBallShape">
				          <option value="sphere">Round (sphere)</option>
				          <option value="torpedo">Torpedo / Fish</option>
				          <option value="pancake">Pancake</option>
				        </select>
				      </div>
				      <div><label for="riggerBallDia">Ball diameter (in)</label><input id="riggerBallDia" type="number" inputmode="decimal" placeholder="e.g., 4" /></div>
				      <div><label for="riggerCableDia">Cable dia (in)</label><input id="riggerCableDia" type="number" inputmode="decimal" placeholder="0.037" /></div>
				      <div><label for="riggerWaterDensity">Water density (kg/m³)</label><input id="riggerWaterDensity" type="number" inputmode="decimal" placeholder="1000" /></div>
				      <div><label for="riggerCdCable">Cable Cd</label><input id="riggerCdCable" type="number" inputmode="decimal" placeholder="1.2" /></div>
				    </div>
				    <div class="hint" style="margin-top:4px; font-size:13px">Provide depth AND cable out to derive blowback angle. Shape sets Cd: sphere 0.47, torpedo 0.20, pancake 0.70. If diameter blank we'll approximate from weight.</div>
				  </details>
				  <div class="row" style="margin-top:10px">
				    <button id="calcRiggerBtn" class="btn secondary" type="button">Calculate</button>
				    <button id="calcRiggerReset" class="btn xs secondary" type="button">Reset</button>
				  </div>
				  <div id="riggerResult" class="hint" style="margin-top:10px"></div>
				  <details style="margin-top:6px">
				    <summary><strong>How this works / tips</strong></summary>
				    <div class="hint" style="font-size:13px; line-height:1.5; margin-top:6px">
				      We approximate underwater speed by balancing horizontal drag (ball + cable) against the downward force (net weight in water).<br>
				      Provide depth and cable out to refine angle & blowback. If cable out unknown, we iterate using drag to estimate angle.<br>
				      Round ball Cd≈0.47, torpedo Cd≈0.20 (faster), pancake Cd≈0.70 (slower). Cable drag matters: thicker cable = more blowback.<br>
				      Use this to spot if your probe speed might differ from GPS (currents) and tune presentation depth. Beta model—field feedback welcome.
				    </div>
				  </details>
				</details>
				<div class="grid cols-3">
					<div><label for="speedBall">Speed @ ball (mph)</label><input id="speedBall" type="number" inputmode="decimal" /></div>
					<div><label for="sog">SOG (mph)</label><input id="sog" type="number" inputmode="decimal" /></div>
					<div><label for="strikeDepthSeen">Strike depth seen (ft)</label><input id="strikeDepthSeen" type="number" inputmode="numeric" /></div>
				</div>
				<div class="grid cols-3">
					<div><label for="species">Species</label><select id="species"></select></div>
					<div><label for="lengthIn">Length (in)</label><input id="lengthIn" type="number" inputmode="decimal" /></div>
					<div><label for="weightLb">Weight (lb)</label><input id="weightLb" type="number" inputmode="decimal" /></div>
				</div>
				<div class="grid cols-2">
					<div>
						<label for="gps">GPS (lat, lon)</label>
						<input id="gps" placeholder="e.g., 42.10, -86.50" />
						<input id="photoInput" type="file" accept="image/*" capture="environment" />
					<div class="hint">Tip: On iPhone/Android this opens the camera. We compress before saving to keep storage light.</div>
					<div class="thumb-row">
						<img id="photoPreview" class="thumb hide" alt="preview"/>
						<button class="btn secondary" id="clearPhoto" type="button">Remove photo</button>
					</div>
				</div>
				<div class="row">
					<button class="btn good" id="addEntry">Save entry</button>
					<button class="btn secondary" id="resetForm">Reset form</button>
					<button class="btn secondary" id="dupLast" type="button">Duplicate last</button>
					<button class="btn secondary" id="cancelEdit" type="button" style="display:none">Cancel edit</button>
					<button class="btn warn" id="forceSave" type="button" style="display:none">Force save</button>
					<button class="btn warn" id="endTrip" type="button" title="End current trip, export, and reset">End Trip</button>
				</div>
			</div>
			<div class="card">
				<div class="section-title">Session entries</div>
				<div style="overflow:auto; max-height: 45vh;">
					<table id="entriesTable">
						<thead>
							<tr><th>Time</th><th>Platf.</th><th>Photo</th><th>Lure</th><th>Depths</th><th>Dir/Speed</th><th>Species</th><th></th></tr>
						</thead>
						<tbody></tbody>
					</table>
				</div>
			</div>
		</section>
		<section id="tab-review" class="grid hide">
			<div class="card">
				<div class="section-title">Trip summary</div>
				<div id="summary" class="muted">(Fill in Trip Setup and add entries to see a summary.)</div>
			</div>
			<div class="card">
				<div class="section-title">Analytics</div>
				<div id="analytics" class="muted">(Data appears after entries.)</div>
			</div>
			<!-- Thermocline card moved to Setup/Log per request -->
			<div class="card">
				<div class="section-title">Export / backup</div>
				<div class="grid cols-1">
					<div style="display:flex;gap:12px">
						<button class="btn secondary" id="pushFullTrip">Push full trip (rows)</button>
					</div>
				</div>
				<div class="hint">Note: trip will be uploaded only with cell service.</div>
			</div>
						<div class="card">
								<details>
									<summary><strong>Manage data</strong></summary>
									<div class="grid cols-2" style="margin-top:10px">
										<button class="btn danger" id="clearTrip" type="button">Clear current trip</button>
										<button class="btn danger" id="clearAll" type="button">Clear ALL trips</button>
										<button class="btn danger" id="deleteTrip" type="button" style="grid-column:span 2">Delete trip</button>
									</div>
									<div class="hint">Clearing is permanent on this device. Export first if you want a backup.</div>
								</details>
						</div>
		</section>
		<section id="tab-settings" class="grid hide">
			<div class="card">
				<div class="section-title">Lists</div>
				<div class="grid cols-2">
					<div><label for="listPlatform">Platform options (one per line)</label><textarea id="listPlatform"></textarea></div>
					<div><label for="listLineType">Line types</label><textarea id="listLineType"></textarea></div>
					<div><label for="listLureType">Lure types</label><textarea id="listLureType"></textarea></div>
					<div><label for="listLureColors">Lure colors / patterns</label><textarea id="listLureColors"></textarea></div>
					<div><label for="listAttractors">Attractors / flashers</label><textarea id="listAttractors"></textarea></div>
					<div><label for="listFlyMeat">Fly / meat colors</label><textarea id="listFlyMeat"></textarea></div>
					<div><label for="listSpecies">Species</label><textarea id="listSpecies"></textarea></div>
					<div><label for="listTrollDir">Troll directions</label><textarea id="listTrollDir"></textarea></div>
					<div><label for="listClouds">Cloud cover</label><textarea id="listClouds"></textarea></div>
				</div>
				<div class="row">
					<button class="btn good" id="saveLists">Save lists</button>
					<button class="btn secondary" id="restoreDefaults">Restore defaults</button>
				</div>
			</div>
			<div class="card">
				<div class="section-title">About</div>
				<div class="muted">All data is stored locally on this device. Text data uses <b>localStorage</b>; photos use <b>IndexedDB</b> to avoid size limits. Export CSV/JSON/Album after each trip to back up.</div>
			</div>
			<div class="card">
				<div class="section-title">Preferences</div>
				<div class="prefs-row">
						<label class="switch"><input type="checkbox" id="prefQuickDefault"/> Quick mode by default</label>
						<label class="switch"><input type="checkbox" id="prefSticky" checked/> Sticky lure fields</label>
					</div>
				<div style="margin-top:12px">
					<label for="marineJsonUrl">Optional: Marine data JSON URL (public)</label>
					<input id="marineJsonUrl" placeholder="https://example.com/marine.json" />
					<div class="hint">If you host a simple JSON file with fields { sstC: <Celsius>, waveM: <meters> } we will fetch it (useful at the dock before heading out).</div>
				</div>
				<div style="margin-top:12px">
					<label for="stationJsonTemplate">Optional: Station JSON template (public)</label>
					<input id="stationJsonTemplate" placeholder="https://yourhost.example/stations/{station}.json or raw GitHub URL" />
					<div class="hint">You can paste a GitHub Pages or raw URL template. Use <code>{station}</code> to substitute station id. Example: <code>https://raw.githubusercontent.com/elliottdanielp/big_lake_fishing_log/main/sample-ndbc.json</code></div>
				</div>
				<div style="margin-top:12px">
					<label for="sheetWebAppUrl">Optional: Google Sheet Web App URL</label>
					<input id="sheetWebAppUrl" placeholder="https://script.google.com/macros/s/....../exec" />
					<div class="hint">Paste the Web App URL from Apps Script (deploy as Web app). We'll POST a single summary row when you tap Push to Google Sheet.</div>
				</div>
				<div style="margin-top:6px">
					<label for="sheetSecret">Optional: Sheet secret (short token)</label>
					<input id="sheetSecret" placeholder="shared-secret-for-posts" />
					<div class="hint">A short secret that the Apps Script validates to prevent accidental writes. Keep private.</div>
				</div>
				<div class="row" style="margin-top:10px">
					<button class="btn good" id="savePrefs" type="button">Save preferences</button>
				</div>
				<div class="hint">Sticky keeps lure fields after saving. Quick mode hides advanced fields for speed.</div>
			</div>
		</section>
	</main>
	<div style="max-width:880px;margin:14px auto 6px;padding:6px 12px;text-align:center;">
		<div class="muted" style="margin-top:8px;font-size:14px;">Tip: On iPhone use Safari ▸ Share ▸ Add to Home Screen</div>
	</div>
	<div class="footer">© You. Fish hard, log smart.</div>
	<div id="lightbox" class="lightbox hide" role="dialog" aria-modal="true">
		<img id="lightboxImg" alt="photo" />
		<button class="btn secondary close" id="lightboxClose">Close</button>
	</div>
	<div id="toast"></div>
	<!-- Mobile bottom action bar removed per request -->
	<script>
	// Ensure all event listeners are attached after DOM is loaded
	const $ = (sel) => document.querySelector(sel);
	const $$ = (sel) => Array.from(document.querySelectorAll(sel));
	const uid = () => Math.random().toString(36).slice(2) + Date.now().toString(36);
	// Helper for older browsers: attach event only if element exists (avoids optional-chaining syntax)
	function attach(selector, evt, handler) { const el = document.querySelector(selector); if (el) el.addEventListener(evt, handler); }
	const onReady = (fn) => { if (document.readyState === 'loading') window.addEventListener('DOMContentLoaded', fn); else fn(); };
	onReady(() => {
				// Prevent browser from restoring previous scroll position on hash changes
				try{ if('scrollRestoration' in history) history.scrollRestoration = 'manual'; }catch(_){}
			// All other event listeners below (move all listeners inside this block)
	attach('#fetchConditions', 'click', async () => {
		// ensure panel visible and navigate to Catch Log tab for context
		const panel = document.getElementById('thermoPlanPanel'); if(panel) panel.style.display = '';
		const statusEl = document.getElementById('thermoStatus'); const outEl = document.getElementById('thermoResult');
		if(statusEl) statusEl.textContent = 'Gathering sources...'; if(outEl) outEl.textContent = '';
		// switch to Catch Log so the panel is visible
		try{ location.hash = '#tab-log'; }catch(_){ }
		try{ window.scrollTo({ top: 0, left: 0, behavior: 'auto' }); }catch(_){ window.scrollTo(0,0); }
		const btn = document.getElementById('genThermoPlan'); const originalBtnTxt = btn? btn.textContent : '';
		if(btn){ btn.disabled = true; btn.textContent = 'Generating...'; }
		try{
			const t = state.trips[currentTripId()]; if(!t) { if(statusEl) statusEl.textContent='No trip'; return; }
			const hdr = t.header || {}; const lat = parseFloat(hdr.lastLat||''); const lon = parseFloat(hdr.lastLon||'');
			if(!isFinite(lat) || !isFinite(lon)) { if(statusEl) statusEl.textContent='No GPS cached. Tap Catch Conditions (GPS) first.'; return; }
			const stations = (window.__stations||[]).slice();
			// First pass: <=45 km up to 18 stations
			let near = stations.map(s=>({s,d:haversineKm(lat,lon,s.lat,s.lon)}))
				.filter(x=> x.d <=45)
				.sort((a,b)=> a.d - b.d)
				.slice(0,18)
				.map(x=> x.s);
			if(statusEl) statusEl.textContent = `Found ${near.length} nearby (<=45 km)...`;
			const tpl = (state.settings && state.settings.stationJsonTemplate) ? String(state.settings.stationJsonTemplate).trim(): '';
			const profiles=[];
			for(const s of near){
				if(!tpl) continue;
				try{
					const url = tpl.replace('{station}', encodeURIComponent(s.id)).replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
					const u2 = url + (url.includes('?')?'&':'?') + 'prefer=ocean-spec&include=profile';
					const r = await fetch(u2,{cache:'no-store'}); if(r.ok){ const js=await r.json(); const prof=normalizeProfile(js,s,lat,lon); if(prof) profiles.push(prof); }
				}catch(_){ }
			}
			// Fallback expansion if <4 profiles: extend to 65 km up to total 25
			if(profiles.length < 4){
				if(statusEl) statusEl.textContent = `Few profiles (${profiles.length}); expanding search...`;
				const expanded = stations.map(s=>({s,d:haversineKm(lat,lon,s.lat,s.lon)}))
					.filter(x=> x.d <=65)
					.sort((a,b)=> a.d - b.d)
					.slice(0,25)
					.map(x=> x.s)
					.filter(s=> !near.find(n=> n.id===s.id));
				for(const s of expanded){
					if(!tpl) continue;
					try{
						const url = tpl.replace('{station}', encodeURIComponent(s.id)).replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
						const u2 = url + (url.includes('?')?'&':'?') + 'prefer=ocean-spec&include=profile';
						const r = await fetch(u2,{cache:'no-store'}); if(r.ok){ const js=await r.json(); const prof=normalizeProfile(js,s,lat,lon); if(prof) profiles.push(prof); }
					}catch(_){ }
				}
				near = near.concat(expanded);
			}
			if(!profiles.length){ if(statusEl) statusEl.textContent = 'No profile data; estimating from surface and history...';
				// estimate band using surface temp and recent entries
				const surfF = parseFloat(hdr.surfaceTemp||'');
				const est = estimateFromHistory(t, isFinite(surfF)? (surfF-32)*5/9 : null);
				renderPlan(est, outEl, statusEl);
				return;
			}
			if(statusEl) statusEl.textContent = `Analyzing ${profiles.length} station profiles...`;
			const stationResults = profiles.map(p=> perStationThermo(p));
			if(statusEl) statusEl.textContent = 'Fusing corridor...';
			const comp = fuseThermo(stationResults, {lat, lon});
			renderPlan(comp, outEl, statusEl);
			// persist lastPlanAt
			try{ t.header.lastPlanAt = Date.now(); save(); indicateSaved(); }catch(_){ }
		}catch(e){ console.warn('thermo plan error', e); if(statusEl) statusEl.textContent='Failed to generate plan'; }
		finally{ if(btn){ btn.disabled=false; btn.textContent = originalBtnTxt; } }
	});
	attach('#saveTrip', 'click', saveHeader);
	attach('#newTrip', 'click', async () => {
					const id = uid();
					state.trips[id] = { id, header:{}, entries:[], active:false, createdAt:Date.now(), updatedAt:Date.now() };
				save(); refreshTripSelect();
				const sel=document.getElementById('tripSelect'); if(sel) sel.value=id;
				loadHeaderIntoForm(); applyActiveTripGating();
				// Re-enable gating UI
				try{ const setup=document.getElementById('tab-setup'); if(setup){ setup.classList.add('pending-conditions'); } }catch(_){ }
				updateTripSlugDisplay();
				toast('New trip started'); setTimeout(hideToast, 1200);
			});
	attach('#tripSelect', 'change', () => {
				// ...existing code...
			});
	attach('#platform', 'change', () => {
				// ...existing code...
			});
	attach('#nowBtn', 'click', setNow);
	attach('#getGps', 'click', () => {
				// ...existing code...
			});
	attach('#saveLists', 'click', textareaToLists);
	attach('#restoreDefaults', 'click', () => {
				// ...existing code...
			});
	attach('#addEntry', 'click', () => addOrUpdateEntry(false));
	attach('#forceSave', 'click', () => addOrUpdateEntry(true));
	attach('#cancelEdit', 'click', () => { setEditing(false); clearCatchForm(false); });
	attach('#dupLast', 'click', () => {
				const t=state.trips[currentTripId()];
				if(!t||!t.entries.length) return toast('No previous entry');
				const last=t.entries[t.entries.length-1];
				loadEntryIntoForm(last, true);
				editingEntryId=null;
				setNow();
				setEditing(false);
			});
	attach('#resetForm', 'click', clearCatchForm);
	attach('#clearPhoto', 'click', () => {
				// ...existing code...
			});
	// lightbox handlers (guarded)
	const lbCloseBtn = $('#lightboxClose');
	if (lbCloseBtn) lbCloseBtn.addEventListener('click', () => { const lb = $('#lightbox'); if (lb) lb.classList.add('hide'); });
	const lightboxEl = $('#lightbox');
	if (lightboxEl) lightboxEl.addEventListener('click', (e) => { if (e.target && e.target.id === 'lightbox') { lightboxEl.classList.add('hide'); } });
			attach('#exportCsv', 'click', exportCsv);

	// Wire mobile bottom bar buttons (if present)
	// bottom bar removed

	// Header menu: Quick Mode toggle from menu
	attach('#quickModeMenu','click', ()=>{
		state.settings.quickMode = !state.settings.quickMode;
		save(); indicateSaved();
		applyQuickMode();
		const m = document.getElementById('quickModeMenu'); if(m) m.textContent = 'Quick Mode: ' + (state.settings.quickMode ? 'On' : 'Off');
		toast('Quick Mode ' + (state.settings.quickMode ? 'On' : 'Off'));
		setTimeout(hideToast, 1200);
	});
	// Manual Marine Snapshot trigger
	attach('#runMarineSnap','click', async ()=>{
		try{
			// prefer cached GPS from header; fall back to geolocation
			const t = state.trips[currentTripId()]; const hdr = t && t.header || {};
			let lat = parseFloat(hdr.lastLat||''); let lon = parseFloat(hdr.lastLon||'');
			if(!isFinite(lat) || !isFinite(lon)){
				if(!('geolocation' in navigator)) { toast('No GPS cached. Use Catch Conditions first.'); return; }
				navigator.geolocation.getCurrentPosition(async pos=>{
					await runMarineSnapshot(pos.coords.latitude, pos.coords.longitude);
				}, err=>{ toast('Location failed: '+(err && err.message)); });
				return;
			}
			await runMarineSnapshot(lat, lon);
		}catch(e){ console.warn('runMarineSnap error', e); toast('Snapshot failed'); }
	});

			// Tab switching for top nav
			// Hash-based section switching (no top tab bar)
			function showSection(name){
				['setup','log','review','settings'].forEach(n=>{
					const el = document.getElementById('tab-'+n);
					if(!el) return;
					const isActive = (n===name);
					if(isActive) el.classList.remove('hide'); else el.classList.add('hide');
					el.setAttribute('aria-hidden', isActive ? 'false' : 'true');
				});
				if(name==='review'){ renderSummary(); renderAnalytics(); }
				if(name==='log'){ renderEntries(); }
				// Gate Catch Log visibility if no active trip
				applyActiveTripGating();
			}
			function applyHash(){
				const h = location.hash || '#tab-setup';
				const match = /^#tab-(setup|log|review|settings)$/.exec(h);
				const name = match ? match[1] : 'setup';
				// If Catch Log requested but trip is not active, redirect to setup
				if(name === 'log' && !isTripActive()){
					location.hash = '#tab-setup';
					showSection('setup');
					return;
				}
				showSection(name);
				// Always open target section at the top
							if(name === 'log') {
								try{ window.scrollTo({ top: 0, left: 0, behavior: 'auto' }); }catch(_){ window.scrollTo(0,0); }
								// Reinforce scroll reset in case of mobile browser quirks
								setTimeout(()=>{ try{ window.scrollTo({ top: 0, left: 0, behavior: 'auto' }); }catch(_){ window.scrollTo(0,0); } }, 50);
								requestAnimationFrame(()=>{ try{ window.scrollTo({ top: 0, left: 0, behavior: 'auto' }); }catch(_){ window.scrollTo(0,0); } });
								if(document.activeElement && typeof document.activeElement.blur==='function') { document.activeElement.blur(); }
							}
			}
			window.addEventListener('hashchange', applyHash);
			applyHash();
			// Initialize Quick Mode label in menu
			const qm = document.getElementById('quickModeMenu'); if(qm) qm.textContent = 'Quick Mode: ' + (state.settings.quickMode ? 'On' : 'Off');
			applyActiveTripGating();

			// Main-column Settings button (above Add to Home) — show settings panel when tapped
			attach('#mainSettingsBtn', 'click', (e) => {
				location.hash = '#tab-settings';
				const s = document.getElementById('tab-settings'); if(s) s.scrollIntoView({behavior:'smooth', block:'start'});
			});

			// Add any other button listeners here as needed
		});
		function degToCompass(num) {
			const val = Math.floor((num / 22.5) + 0.5);
			const arr = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
			return arr[(val % 16)];
		}
		// Fetch current weather from Open-Meteo (no API key). Returns an object or throws.
		async function fetchOpenMeteo(lat, lon){
			const url = `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}&current_weather=true&hourly=cloudcover&timezone=auto`;
			const r = await fetch(url, {cache: 'no-store'});
			if(!r.ok) throw new Error('Weather API HTTP '+r.status);
			const js = await r.json();
			// current_weather: temperature (°C), windspeed (km/h), winddirection (deg)
			const cw = js.current_weather || {};
			const tempC = cw.temperature;
			const windKmh = cw.windspeed;
			const windDeg = cw.winddirection;
			// attempt to derive cloud cover from nearest hourly point
			let cloudPct = null;
			if(js.hourly && Array.isArray(js.hourly.time) && Array.isArray(js.hourly.cloudcover)){
				const times = js.hourly.time.map(t=>new Date(t).getTime());
				const now = Date.now();
				// find nearest index
				let bestIdx = 0, bestDiff = Infinity;
				for(let i=0;i<times.length;i++){ const d = Math.abs(times[i]-now); if(d<bestDiff){ bestDiff=d; bestIdx=i; } }
				cloudPct = Number(js.hourly.cloudcover[bestIdx]);
			}
			return { tempC, windKmh, windDeg, cloudPct };
		}

		// Placeholder for marine/surface data API for Lake Michigan (Holland <-> Muskegon area).
		// Real marine data (surface temp, waves) typically comes from NOAA/GLERL/NDBC/ERDDAP and may need different endpoints.
		// This placeholder returns null and is intended to be replaced with a proper API call later.
		async function fetchMarineNearest(lat, lon){
			// 1) If the user supplied a public JSON URL in Settings, try it first.
			//    Accepts either a tiny JSON like { sstC: 4.2, waveM: 0.6 }
			//    or a full Open-Meteo marine response (hourly.time + hourly.sea_surface_temperature etc.).
			try{
				const mj = (state && state.settings && state.settings.marineJsonUrl) ? String(state.settings.marineJsonUrl).trim() : '';
				// ALSO: if user configured a station JSON template (worker), prefer calling it with prefer=ocean-spec
				const tpl = (state && state.settings && state.settings.stationJsonTemplate) ? String(state.settings.stationJsonTemplate).trim() : '';
				if(tpl){
					try{
						// If we have a stations list, compute nearest id (best-effort). Otherwise the calling code may have provided nearest id via template placeholders.
						let stationId = '';
						try{
							const stations = window.__stations || [];
							if(stations.length){
								// simple haversine nearest
								const toR = n => n * Math.PI / 180;
								const hav = (a,b)=>{ const R=6371; const dLat=toR(b.lat-a.lat); const dLon=toR(b.lon-a.lon); const la=toR(a.lat), lb=toR(b.lat); const h = Math.sin(dLat/2)**2 + Math.cos(la)*Math.cos(lb)*Math.sin(dLon/2)**2; return 2*R*Math.asin(Math.sqrt(h)); };
								let best=null, bestD=Infinity; stations.forEach(s=>{ const d = hav({lat: lat, lon: lon}, {lat:s.lat, lon:s.lon}); if(d<bestD){ bestD=d; best=s; } }); if(best) stationId = best.id || '';
							}
							// Fallback: if no station or port still empty, set Port to lat, lon
							try{
								const portEl2 = document.getElementById('port');
								if(portEl2 && !portEl2.value){ const v = lat + ', ' + lon; portEl2.value = v; if(cur && state.trips[cur]) state.trips[cur].header.port = v; }
							}catch(_){ }
						}catch(e){ console.warn('nearest station lookup failed', e); }
						// build URL by substituting {station},{lat},{lon}
						let url = tpl.replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
						if(stationId) url = url.replace('{station}', encodeURIComponent(stationId));
						// request prefer=ocean-spec so worker composes SST from .ocean and WVHT from .spec
						const debugSuffix = url.includes('?') ? '&' : '?';
						const prefUrl = url + debugSuffix + 'prefer=ocean-spec';
						const r = await fetch(prefUrl, { cache: 'no-store' });
						if(r.ok){
							const js = await r.json();
							// Accept tiny shapes or composed fields
							const maybeSst = js && (js.sstC ?? js.surfaceTempC ?? js.sst ?? null);
							const maybeWave = js && (js.waveM ?? js.significant_wave_height ?? js.wave ?? null);
							if(maybeSst !== undefined || maybeWave !== undefined){
								const s = (maybeSst===null||maybeSst===undefined)? null : Number(maybeSst);
								const w = (maybeWave===null||maybeWave===undefined)? null : Number(maybeWave);
								return { sstC: s, waveM: w };
							}
						} else {
							console.warn('station template prefer fetch failed', r.status, prefUrl);
						}
					}catch(e){ console.warn('station template prefer fetch error', e); }
				}
				if(mj){
					try{
						// allow simple placeholders {lat} and {lon} in the URL
						let url = mj.replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
						const r = await fetch(url, { cache: 'no-store' });
						if(r.ok){
							const js = await r.json();
							// tiny JSON shape
							const maybeSst = js && (js.sstC ?? js.surfaceTempC ?? js.sst ?? js.sea_surface_temperature);
							const maybeWave = js && (js.waveM ?? js.significant_wave_height ?? js.waveM ?? js.wave ?? js.significant_wave_height_meters);
							if(maybeSst !== undefined || maybeWave !== undefined){
								const s = (maybeSst===null||maybeSst===undefined)? null : Number(maybeSst);
								const w = (maybeWave===null||maybeWave===undefined)? null : Number(maybeWave);
								return { sstC: s, waveM: w };
							}
							// try to parse full Open-Meteo marine response
							if(js && js.hourly && Array.isArray(js.hourly.time)){
								const times = js.hourly.time.map(t=>new Date(t).getTime());
								const now = Date.now();
								let bestIdx = 0, bestDiff = Infinity;
								for(let i=0;i<times.length;i++){ const d = Math.abs(times[i]-now); if(d<bestDiff){ bestDiff=d; bestIdx=i; } }
								const sst = (js.hourly.sea_surface_temperature && js.hourly.sea_surface_temperature[bestIdx]!==undefined) ? Number(js.hourly.sea_surface_temperature[bestIdx]) : null;
								const wave = (js.hourly.significant_wave_height && js.hourly.significant_wave_height[bestIdx]!==undefined) ? Number(js.hourly.significant_wave_height[bestIdx]) : null;
								return { sstC: sst, waveM: wave };
							}
							// if we reach here, the JSON didn't match expected shapes
							console.warn('marineJsonUrl returned JSON but no recognizable fields');
						} else {
							console.warn('marineJsonUrl HTTP', r.status);
						}
					}catch(e){ console.warn('Failed to fetch/parse marineJsonUrl', e); }
				}
			}catch(e){ console.warn('marineJsonUrl handling failed', e); }

			// 2) Fallback: Open-Meteo Marine API (public, no key) — returns sea surface temperature and significant wave height (hourly)
			try{
				const m = await fetchOpenMeteoMarine(lat, lon);
				return m; // { sstC, waveM }
			}catch(err){
				console.warn('Marine fallback failed', err);
				return null;
			}
		}

		// Query Open-Meteo's Marine API (no key). Returns { sstC, waveM } or throws.
		async function fetchOpenMeteoMarine(lat, lon){
			// hourly=sea_surface_temperature,significant_wave_height
			// If a proxy is configured (to bypass CORS or add station logic), use it
			const proxy = (window && window.MARINE_PROXY_URL) ? window.MARINE_PROXY_URL.replace(/\/$/, '') : null;
			let res;
			if(proxy){
				const url = `${proxy}/api/marine?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}`;
				res = await fetch(url, { cache: 'no-store' });
			} else {
				const url = `https://marine-api.open-meteo.com/v1/marine?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lon)}&hourly=sea_surface_temperature,significant_wave_height&timezone=auto`;
				res = await fetch(url, { cache: 'no-store' });
			}
			if(!res.ok) throw new Error('Marine API HTTP '+res.status);
			const js = await res.json();
			// pick nearest hourly value
			let sst = null, wave = null;
			if(js && js.hourly && Array.isArray(js.hourly.time)){
				const times = js.hourly.time.map(t=>new Date(t).getTime());
				const now = Date.now();
				let bestIdx = 0, bestDiff = Infinity;
				for(let i=0;i<times.length;i++){ const d = Math.abs(times[i]-now); if(d<bestDiff){ bestDiff=d; bestIdx=i; } }
				if(js.hourly.sea_surface_temperature && js.hourly.sea_surface_temperature[bestIdx] !== undefined) sst = Number(js.hourly.sea_surface_temperature[bestIdx]);
				if(js.hourly.significant_wave_height && js.hourly.significant_wave_height[bestIdx] !== undefined) wave = Number(js.hourly.significant_wave_height[bestIdx]);
			}
			return { sstC: sst, waveM: wave };
		}

		// Marine Snapshot: fuse SST and waves from up to 8 nearby buoys with weighting and fallbacks
		async function runMarineSnapshot(lat, lon){
			const statusEl = document.getElementById('marineSnapStatus');
			const outEl = document.getElementById('marineSnapResult');
			if(statusEl) statusEl.textContent = 'Scanning nearby buoys...';
			if(outEl) outEl.innerHTML = '';
			const t = state.trips[currentTripId()]; if(!t){ if(statusEl) statusEl.textContent='No trip'; return; }
			const tpl = (state.settings && state.settings.stationJsonTemplate) ? String(state.settings.stationJsonTemplate).trim() : '';
			const stations = (window.__stations||[]).slice();
			if(!stations.length){ if(statusEl) statusEl.textContent = 'No station list available'; return; }
			const sel1 = selectStations(lat, lon, stations, 40, 8);
			let fused = null;
			if(statusEl) statusEl.textContent = `Fetching ${sel1.length} stations...`;
			if(tpl && sel1.length){
				const rows = await fetchStationsData(tpl, sel1, lat, lon);
				fused = fuseMarine(rows, {lat, lon});
			}
			// Retry with wider radius if nothing
			if((!fused || fused.sources===0) && tpl){
				if(statusEl) statusEl.textContent = 'Expanding search (60 km)...';
				const sel2 = selectStations(lat, lon, stations, 60, 8);
				const rows2 = await fetchStationsData(tpl, sel2, lat, lon);
				fused = fuseMarine(rows2, {lat, lon});
			}
			// Fallbacks if still nothing
			if(!fused || fused.sources===0){
				if(statusEl) statusEl.textContent = 'Using Open‑Meteo marine (fallback)...';
				try{
					const m = await fetchOpenMeteoMarine(lat, lon);
					if(m){ fused = { sstC: m.sstC ?? null, waveM: m.waveM ?? null, periodS: null, waveDirDeg: null, sources: 0, conf: 0.25, note: 'Open‑Meteo' }; }
				}catch(_){ }
			}
			// Last resort: use last saved snapshot if present
			if((!fused || (fused.sstC==null && fused.waveM==null))){
				const cur = currentTripId(); const t2 = cur && state.trips[cur]; const snap = t2 && t2.header && t2.header.marineSnapshot;
				if(snap){ fused = Object.assign({}, snap, { note: (snap.note? snap.note+'; ' : '') + 'last saved' }); }
			}
			if(!fused){ if(statusEl) statusEl.textContent = 'No marine data available'; return; }
			// Persist to header and auto-fill fields
			try{
				const cur = currentTripId(); if(cur && state.trips[cur]){
					state.trips[cur].header.marineSnapshot = Object.assign({}, fused, { at: Date.now() });
					if(typeof fused.sstC === 'number'){ const f = Math.round((fused.sstC*9/5)+32); state.trips[cur].header.surfaceTemp = String(f); const sEl = document.getElementById('surfaceTemp'); if(sEl) sEl.value = f; }
					if(typeof fused.waveM === 'number'){ const ft = (fused.waveM*3.28084).toFixed(1); state.trips[cur].header.waves = String(ft); const wEl = document.getElementById('waves'); if(wEl) wEl.value = ft; }
					save(); indicateSaved();
				}
			}catch(_){ }
			renderMarineSnapshot(fused, outEl, statusEl);
		}

		function selectStations(lat, lon, list, radiusKm, maxCount){
			const arr = list.map(s=>({ s, d: haversineKm(lat, lon, s.lat, s.lon) }))
				.filter(x=> x.d <= radiusKm)
				.sort((a,b)=> a.d - b.d);
			// ensure at least one more-offshore buoy included if available (heuristic: farthest within radius)
			const chosen = arr.slice(0, Math.min(arr.length, maxCount)).map(x=> x.s);
			if(arr.length > chosen.length){
				const far = arr[arr.length-1].s;
				const hasFar = chosen.some(s=> s.id === far.id);
				if(!hasFar){
					if(chosen.length < maxCount) chosen.push(far);
					else chosen[chosen.length-1] = far; // swap last
				}
			}
			return chosen;
		}

		async function fetchStationsData(tpl, stations, lat, lon){
			const rows = [];
			for(const s of stations){
				try{
					let url = tpl.replace('{station}', encodeURIComponent(s.id)).replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
					const sep = url.includes('?') ? '&' : '?';
					url = `${url}${sep}prefer=ocean-spec&include=wave`;
					const r = await fetch(url, { cache: 'no-store' });
					if(!r.ok) continue;
					const js = await r.json();
					const sst = js && (js.sstC ?? js.surfaceTempC ?? js.sst);
					const wave = js && (js.waveM ?? js.significant_wave_height ?? js.wave);
					const period = js && (js.wavePeriodS ?? js.wave_period_s ?? js.mean_wave_period);
					const dir = js && (js.waveDirDeg ?? js.wave_direction_deg ?? js.dominant_wave_direction);
					const when = Number(js && (js.when || js.ts || js.time));
					rows.push({ id: s.id, name: s.name || s.id, lat: s.lat, lon: s.lon, sstC: (sst==null?null:Number(sst)), waveM: (wave==null?null:Number(wave)), periodS: (period==null?null:Number(period)), waveDirDeg: (dir==null?null:Number(dir)), when: (isFinite(when)? when : Date.now()) });
				}catch(_){ }
			}
			return rows;
		}

		function fuseMarine(rows, ref){
			// Weight by distance and recency, reject outliers per metric
			const now = Date.now();
			const enriched = rows.map(r=>{
				const dKm = haversineKm(ref.lat, ref.lon, r.lat, r.lon);
				const dtH = Math.abs(now - r.when)/3600000;
				const w = Math.exp(-dKm/30) * Math.exp(-dtH/6) * (r.isChain?1.15:1.0) * Math.max(0.1, Math.min(1, r.tc_conf||0.5));
				return Object.assign({ w, dKm, dtH }, r);
			});
			function pruneAndMean(arr, key){
				const vals = arr.filter(x=> isFinite(x[key])).map(x=> [x[key], x.w]);
				if(!vals.length) return { mean: null, kept: [] };
				const mu = wMean(vals);
				const sd = wStd(vals, mu);
				const kept = enriched.filter(x=> isFinite(x[key]) && (Math.abs(x[key]-mu) <= 2.5*(sd||1e-6) || x.w>0.6));
				return { mean: wMean(kept.map(x=> [x[key], x.w])), kept };
			}
			const sst = pruneAndMean(enriched, 'sstC');
			const wav = pruneAndMean(enriched, 'waveM');
			const per = pruneAndMean(enriched, 'periodS');
			const dir = pruneAndMean(enriched, 'waveDirDeg');
			const sources = Math.max(sst.kept.length, wav.kept.length, per.kept.length, dir.kept.length);
			const conf = Math.max(0, Math.min(1, (sst.kept.reduce((s,x)=>s+x.w,0) + wav.kept.reduce((s,x)=>s+x.w,0)) / (sources || 1)));
			// Build a union of stations used in either SST or Wave kept sets
			const usedMap = new Map();
			for(const x of [...sst.kept, ...wav.kept]){ usedMap.set(x.id, x); }
			const sourcesDetail = Array.from(usedMap.values()).map(x=>({
				id: x.id,
				name: x.name || x.id,
				dKm: x.dKm,
				ageH: x.dtH,
				sstC: x.sstC,
				waveM: x.waveM,
				periodS: x.periodS,
				waveDirDeg: x.waveDirDeg,
				w: x.w
			})).sort((a,b)=> a.dKm - b.dKm);
			return { sstC: sst.mean, waveM: wav.mean, periodS: per.mean, waveDirDeg: dir.mean, sources, conf, sourcesDetail };
		}

		function renderMarineSnapshot(data, outEl, statusEl){
			const pills = [];
			if(typeof data.sstC === 'number'){ const f = Math.round((data.sstC*9/5)+32); pills.push(`<span class="pill badge">SST ${f}°F</span>`); }
			if(typeof data.waveM === 'number'){ const ft = (data.waveM*3.28084).toFixed(1); pills.push(`<span class="pill badge">Waves ${ft} ft</span>`); }
			if(typeof data.periodS === 'number'){ pills.push(`<span class="pill badge">Period ${data.periodS.toFixed(0)} s</span>`); }
			if(typeof data.waveDirDeg === 'number'){ const d = Math.round(data.waveDirDeg); pills.push(`<span class="pill badge">Dir ${d}°</span>`); }
			const conf = Math.round(((data.conf||0)*100));
			// Optional sources list
			let sourcesHtml = '';
			if(Array.isArray(data.sourcesDetail) && data.sourcesDetail.length){
				const rows = data.sourcesDetail.map(s=>{
					const f = typeof s.sstC==='number' ? Math.round((s.sstC*9/5)+32)+'°F' : '—';
					const w = typeof s.waveM==='number' ? (s.waveM*3.28084).toFixed(1)+' ft' : '—';
					const per = typeof s.periodS==='number' ? s.periodS.toFixed(0)+' s' : '—';
					const dir = typeof s.waveDirDeg==='number' ? Math.round(s.waveDirDeg)+'°' : '—';
					return `<li style=\"margin:6px 0\"><b>${s.name}</b> <span class=\"muted\">(${s.id})</span> — ${s.dKm.toFixed(1)} km • ${s.ageH.toFixed(1)} h • SST ${f}, Waves ${w}, Period ${per}, Dir ${dir}</li>`;
				}).join('');
				sourcesHtml = `<details style=\"margin-top:6px\"><summary><strong>Sources</strong></summary><ul style=\"padding-left:18px;margin:8px 0 0\">${rows}</ul></details>`;
			}
			const html = `
				<div class=\"grid cols-3\">${pills.map(p=> `<div class=\"chip\">${p}</div>`).join('')}</div>
				<div class=\"muted\" style=\"margin-top:6px\">Sources <b>${data.sources||0}</b> • Confidence <b>${conf}%</b>${data.note? ' • '+data.note: ''}</div>
				${sourcesHtml}`;
			if(outEl) outEl.innerHTML = html;
			if(statusEl) statusEl.textContent = 'Snapshot updated';
		}
	const LS_KEY = 'blfl.state.v2';
	let state = load() || { trips: {}, lists: defaults(), dataVersion:3, settings:{quickMode:false, sticky:true} };
	let pendingMarineUndo = null;
		function defaults(){ return { Platform:["Downrigger","Dipsy","Copper","Leadcore","Planer Board","Flatline"], LineType:["Wire","Braid","Mono","Fluorocarbon","Copper","Leadcore"], LureType:["Spoon","Plug","Flasher/Fly","Meat Rig","Spin-n-Glow","Other"], LureColors:["NBK","Blue Dolphin","UV Blue/Green","Glow Green","Glow White","Orange/Silver","Green Dolphin","UV Stud","Blue Bubble","Chrome/Green","Chrome/Blue","Bloody Nose"], Attractors:["8\" White Crush","8\" UV Stud","11\" Chrome-Green","11\" White Paddle","8\" Blue Bubble","8\" Green Dot"], FlyMeat:["Blue Fly","Green Fly","Blue/Green Fly","Green Meat","Blue Meat","UV Fly"], Species:["Chinook (King)","Coho","Steelhead","Lake Trout","Brown Trout","Other"], TrollDirection:["N","NE","E","SE","S","SW","W","NW"], Clouds:["Clear","Partly","Overcast","Fog"], HookLocation:["Jaw","Corner","Tongue","Outside"] }; }
	function save(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
	// small helper to indicate saved status in the UI
	function indicateSaved(){ try{ const s = document.getElementById('saveStatus'); if(!s) return; s.textContent = 'Saved • ' + new Date().toLocaleTimeString(); s.style.opacity = '1'; setTimeout(()=>{ s.textContent = 'Saved'; }, 2500); }catch(e){} }
		function load(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)); }catch(e){ return null; } }
		const DB_NAME='blfl-db', DB_VER=1;
		function openDB(){ return new Promise((resolve,reject)=>{ const req=indexedDB.open(DB_NAME,DB_VER); req.onupgradeneeded=()=>{ const db=req.result; if(!db.objectStoreNames.contains('photos')) db.createObjectStore('photos',{keyPath:'id'}); }; req.onsuccess=()=>resolve(req.result); req.onerror=()=>reject(req.error); }); }
		async function savePhoto(entryId, dataURL){ const db=await openDB(); await new Promise((res,rej)=>{ const tx=db.transaction('photos','readwrite'); tx.objectStore('photos').put({id:entryId, dataURL, ts:Date.now()}); tx.oncomplete=res; tx.onerror=()=>rej(tx.error); }); }
	async function getPhoto(entryId){ const db=await openDB(); return await new Promise((res,rej)=>{ const tx=db.transaction('photos','readonly'); const req=tx.objectStore('photos').get(entryId); req.onsuccess=()=>res((req.result && req.result.dataURL) || ''); req.onerror=()=>rej(req.error); }); }
		async function deletePhoto(entryId){ const db=await openDB(); await new Promise((res,rej)=>{ const tx=db.transaction('photos','readwrite'); tx.objectStore('photos').delete(entryId); tx.oncomplete=res; tx.onerror=()=>rej(tx.error); }); }
	// (Removed duplicate event listener for .tab-btn)
		function fillSelect(id, arr){ const el=$(id); if(!el) return; const values = (Array.isArray(arr) && arr.length) ? arr : []; el.innerHTML = '<option value="">—</option>' + values.map(v=>`<option>${v}</option>`).join(''); }
		function ensureListsSeeded(){ const d=defaults(); state.lists = state.lists || {}; const keys=["Platform","LineType","LureType","LureColors","Attractors","FlyMeat","Species","TrollDirection","Clouds","HookLocation"]; keys.forEach(k=>{ if(!Array.isArray(state.lists[k]) || !state.lists[k].length){ state.lists[k] = d[k].slice(); } }); }
		function fillAllSelects(){ ensureListsSeeded(); fillSelect('#platform', state.lists.Platform); fillSelect('#lureType', state.lists.LureType); fillSelect('#species', state.lists.Species); fillSelect('#trollDir', state.lists.TrollDirection); fillSelect('#clouds', state.lists.Clouds); fillSelect('#lureColor', state.lists.LureColors); fillSelect('#attractor', state.lists.Attractors); fillSelect('#flyMeat', state.lists.FlyMeat); }
		function listsToTextarea(){ ensureListsSeeded(); $('#listPlatform').value = state.lists.Platform.join('\n'); $('#listLineType').value = state.lists.LineType.join('\n'); $('#listLureType').value = state.lists.LureType.join('\n'); $('#listLureColors').value = state.lists.LureColors.join('\n'); $('#listAttractors').value = state.lists.Attractors.join('\n'); $('#listFlyMeat').value = state.lists.FlyMeat.join('\n'); $('#listSpecies').value = state.lists.Species.join('\n'); $('#listTrollDir').value = state.lists.TrollDirection.join('\n'); $('#listClouds').value = state.lists.Clouds.join('\n'); $('#listHookLoc').value = state.lists.HookLocation.join('\n'); }
		function textareaToLists(){ const split=t=>t.split('\n').map(s=>s.trim()).filter(Boolean); state.lists = state.lists || {}; state.lists.Platform=split($('#listPlatform').value); state.lists.LineType=split($('#listLineType').value); state.lists.LureType=split($('#listLureType').value); state.lists.LureColors=split($('#listLureColors').value); state.lists.Attractors=split($('#listAttractors').value); state.lists.FlyMeat=split($('#listFlyMeat').value); state.lists.Species=split($('#listSpecies').value); state.lists.TrollDirection=split($('#listTrollDir').value); state.lists.Clouds=split($('#listClouds').value); state.lists.HookLocation=split($('#listHookLoc').value); save(); indicateSaved(); fillAllSelects(); }
	// (Removed duplicate event listeners for #saveLists and #restoreDefaults)
		function currentTripId(){ return $('#tripSelect').value || null; }
	function ensureTrip(){ let id=currentTripId(); if(!id){ id=uid(); state.trips[id]={id, header:{}, entries:[], active:false, createdAt:Date.now(), updatedAt:Date.now()}; $('#tripSelect').value=id; save(); indicateSaved(); refreshTripSelect(); } return id; }
	function refreshTripSelect(){ const sel=$('#tripSelect'); const opts=Object.values(state.trips).sort((a,b)=>{ const ad=(b.header && b.header.date) || ''; const bd=(a.header && a.header.date) || ''; return ad.localeCompare(bd); }); sel.innerHTML = opts.map(t=>`<option value="${t.id}">${(t.header && t.header.date)||'(no date)'} • ${ (t.header && t.header.port) || 'Port'}</option>`).join(''); }
	function aggressiveScrollTop(){ try{ window.scrollTo({top:0,left:0,behavior:'auto'}); }catch(_){ window.scrollTo(0,0); } setTimeout(()=>{ try{ window.scrollTo({top:0,left:0,behavior:'auto'}); }catch(_){ } },40); requestAnimationFrame(()=>{ try{ window.scrollTo({top:0,left:0,behavior:'auto'}); }catch(_){ } }); setTimeout(()=>{ try{ window.scrollTo({top:0,left:0,behavior:'auto'}); }catch(_){ } },120); }
	function saveHeader(){
		const id=currentTripId()||uid();
		state.trips[id]=state.trips[id]||{id, header:{}, entries:[], active:false, createdAt:Date.now(), updatedAt:Date.now()};
		// Preserve previously cached GPS & marine snapshot fields
		const existing = state.trips[id].header || {};
		state.trips[id].header = Object.assign({}, existing, {
			date:$('#tripDate').value,
			startTime:$('#startTime').value,
			port:$('#port').value,
			boat:$('#boat').value,
			crew:$('#crew').value,
			hours:$('#hours').value,
			airTemp:$('#airTemp').value,
			surfaceTemp:$('#surfaceTemp').value,
			wind:$('#wind').value,
			waves:$('#waves').value,
			clouds:$('#clouds').value,
			gearNotes:$('#gearNotes')?$('#gearNotes').value:''
		});
		state.trips[id].updatedAt=Date.now();
		state.trips[id].active = true;
		save(); refreshTripSelect(); $('#tripSelect').value=id;
		toast('Trip started'); setTimeout(hideToast, 1200);
		location.hash = '#tab-log';
		aggressiveScrollTop();
		applyActiveTripGating();
		// Attempt plan only if GPS already cached
		const hdr = state.trips[id].header;
		const lat = parseFloat(hdr.lastLat||'');
		const lon = parseFloat(hdr.lastLon||'');
		const planBtn = document.getElementById('genThermoPlan');
		if(isFinite(lat) && isFinite(lon) && planBtn){
			setTimeout(()=>{ try{ planBtn.click(); aggressiveScrollTop(); }catch(_){ } }, 500);
		} else {
			// Show panel with helpful message instead of "No GPS cached" confusion
			const panel = document.getElementById('thermoPlanPanel');
			if(panel){ panel.style.display=''; }
			const status = document.getElementById('thermoStatus');
			if(status) status.textContent='Run Catch Conditions (GPS) to enable thermocline fusion.';
			aggressiveScrollTop();
		}
	}

	// Determine active via explicit flag set on Start Trip and cleared on End/New
	function isTripActive(){ const t=state.trips[currentTripId()]; return !!(t && t.active === true); }
	function applyActiveTripGating(){ const active = isTripActive(); const logSec = document.getElementById('tab-log'); if(logSec){ if(active) logSec.classList.remove('hide'); else logSec.classList.add('hide'); }
		// Title: strictly based on active flag
	try{ const headerTitle = document.querySelector('#tab-setup .section-title'); if(headerTitle){ headerTitle.textContent = active ? 'Edit Setup' : 'New Trip'; headerTitle.style.color = active ? 'var(--accent-2)' : ''; } }catch(e){}
		// Menu: hide Catch Log link when inactive
		try{ const logLink = document.querySelector('#navMenuRR a[href="#tab-log"]'); if(logLink){ logLink.style.display = active ? '' : 'none'; } }catch(e){}
	}

	// End Trip: export/push then reset to fresh trip
	async function endTripFlow(){
		const id = currentTripId(); if(!id) { toast('No trip selected'); return; }
		const t = state.trips[id]; if(!t) { toast('No trip selected'); return; }
		// Attempt push when online and configured, but always export CSV locally
		const url = (state.settings && state.settings.sheetWebAppUrl) ? state.settings.sheetWebAppUrl.trim() : '';
		const secret = (state.settings && state.settings.sheetSecret) ? state.settings.sheetSecret.trim() : '';
		const online = navigator.onLine;
		let pushed = false;
		if(online && url && secret){
			try{ await pushFullTrip(); pushed = true; }catch(e){ console.warn('endTrip push failed', e); }
		}
		try{ await exportCsv(); }catch(e){ console.warn('local export failed', e); }
		// Reset to a fresh trip (keep preferences)
		await resetToFreshTrip();
		location.hash = '#tab-setup';
		toast('Trip ended • exported locally' + (pushed? ' • pushed to Sheet' : ''));
		setTimeout(hideToast, 2200);
	}
	attach('#endTrip','click', ()=>{
		const ok = confirm('End current trip, export locally, and start a new blank trip?\n\nTip: Ensure important notes are saved.');
		if(ok) endTripFlow();
	});

	async function resetToFreshTrip(){
		const id = currentTripId(); if(!id) { ensureTrip(); return; }
		const t = state.trips[id]; if(t){
			try{ for(const e of (t.entries||[])){ if(e.photo){ try{ await deletePhoto(e.id); }catch(_){} } } }catch(_){ }
		}
		// Create new blank trip and select it, keep old trip for history
		try{ if(t) t.active = false; }catch(_){ }
		const newId = uid(); state.trips[newId] = { id:newId, header:{}, entries:[], active:false, createdAt:Date.now(), updatedAt:Date.now() };
		save(); refreshTripSelect();
		const sel = document.getElementById('tripSelect'); if(sel) sel.value = newId;
		loadHeaderIntoForm(); renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge(); applyActiveTripGating();
	}
  
	// (Removed duplicate event listeners for #saveTrip, #newTrip, #tripSelect)
	function loadHeaderIntoForm(){ const t=state.trips[currentTripId()]; if(!t) return; const h=t.header||{}; $('#tripDate').value=h.date||''; $('#startTime').value=h.startTime||''; $('#port').value=h.port||''; $('#boat').value=h.boat||''; $('#crew').value=h.crew||''; $('#hours').value=h.hours||''; $('#airTemp').value=h.airTemp||''; $('#surfaceTemp').value=h.surfaceTemp||''; $('#wind').value=h.wind||''; $('#waves').value=h.waves||''; $('#clouds').value=h.clouds||''; const g=$('#gearNotes'); if(g) g.value=h.gearNotes||''; }
	// (Removed duplicate event listener for #platform)
		function setNow(){ const d=new Date(); $('#time').value=d.toTimeString().slice(0,5); if(!$('#tripDate').value) $('#tripDate').value=d.toISOString().slice(0,10); if(!$('#startTime').value) $('#startTime').value=d.toTimeString().slice(0,5); }
	// (Removed duplicate event listener for #nowBtn)
	setNow();
	const photoInput = $('#photoInput'); const photoPreview = $('#photoPreview'); const clearPhotoBtn = $('#clearPhoto'); let pendingPhotoDataURL='';
	function fileToDataURLResized(file, maxDim=1600, quality=0.82){ return new Promise((resolve,reject)=>{ const fr=new FileReader(); fr.onload=()=>{ const img=new Image(); img.onload=()=>{ const c=document.createElement('canvas'); let w=img.width,h=img.height; const scale=Math.min(1, maxDim/Math.max(w,h)); const nw=Math.max(1,Math.round(w*scale)), nh=Math.max(1,Math.round(h*scale)); c.width=nw; c.height=nh; c.getContext('2d').drawImage(img,0,0,nw,nh); try{ resolve(c.toDataURL('image/jpeg', quality)); }catch(e){ reject(e); } }; img.onerror=reject; img.src=fr.result; }; fr.onerror=reject; fr.readAsDataURL(file); }); }
	function readVal(id){ const el=document.querySelector(id); return (el && el.value || '').trim(); } function num(x){ return x?Number(x):''; }
	function fmt12hFromParts(timeStr){ // expects HH:MM or blank
		if(!timeStr) return '';
		const m = /^(\d{1,2}):(\d{2})$/.exec(timeStr);
		if(!m) return timeStr;
		let h = parseInt(m[1],10); const min=m[2]; const ampm = h>=12? 'PM':'AM'; h = h%12; if(h===0) h=12; return `${h}:${min} ${ampm}`;
	}
	function fmt12hFromDate(d){ try{ let h=d.getHours(), m=d.getMinutes(); const ampm=h>=12?'PM':'AM'; h=h%12; if(h===0) h=12; return `${h}:${String(m).padStart(2,'0')} ${ampm}`; }catch(_){ return ''; }}
	function computeTs(header, timeStr){ if(header && header.date && timeStr){ const ds=header.date+'T'+timeStr+':00'; const d=new Date(ds); if(!isNaN(d)) return d.getTime(); } return Date.now(); }
		let editingEntryId=null; let undoTimer=null; let pendingDelete=null; const UNDO_MS=12000;
		function setEditing(on){ editingEntryId = on?editingEntryId:null; $('#cancelEdit').style.display = on?'inline-block':'none'; $('#addEntry').textContent = on?'Update entry':'Save entry'; }
		function validateEntry(isQuick){ const req=[]; const time=readVal('#time'); const platform=readVal('#platform'); const species=readVal('#species'); const lureType=readVal('#lureType'); const water=readVal('#waterDepth'); const target=readVal('#targetDepth'); if(!time) req.push('#time'); if(!platform) req.push('#platform'); if(!species) req.push('#species'); if(!lureType) req.push('#lureType'); if(!water && !target) { req.push('#waterDepth'); req.push('#targetDepth'); }
			$$('#tab-log input, #tab-log select').forEach(el=> el.classList.remove('invalid')); req.forEach(sel=>{ const el=$(sel); if(el) el.classList.add('invalid'); }); return { ok: req.length===0, missing:req };
		}
			async function addOrUpdateEntry(force=false){ const t=state.trips[ensureTrip()]; const header=t.header; const quick=state.settings.quickMode; const v=validateEntry(quick); if(!v.ok && !force){ $('#forceSave').style.display='inline-block'; toast('Missing required fields. Fill red or tap Force.'); return; } $('#forceSave').style.display='none'; const base={ id: editingEntryId||uid(), time:readVal('#time'), platform:readVal('#platform'), trollDir:readVal('#trollDir'), waterDepth:num(readVal('#waterDepth')), ballDepth:num(readVal('#ballDepth')), ballWeight:num(readVal('#ballWeight')), dipsySize:readVal('#dipsySize'), dipsySetting:readVal('#dipsySetting'), copperLen:num(readVal('#copperLen')), leadcoreColors:readVal('#leadcoreColors'), targetDepth:num(readVal('#targetDepth')), lureType:readVal('#lureType'), lureBrand:readVal('#lureBrand'), lureSize:readVal('#lureSize'), lureColor:readVal('#lureColor'), attractor:readVal('#attractor'), flyMeat:readVal('#flyMeat'), speedBall:num(readVal('#speedBall')), sog:num(readVal('#sog')), strikeDepthSeen:num(readVal('#strikeDepthSeen')), species:readVal('#species'), lengthIn:num(readVal('#lengthIn')), weightLb:num(readVal('#weightLb')), gps:readVal('#gps'), notes:readVal('#notes'), photo:false };
				if(!base.time) setNow(); base.ts = computeTs(header, base.time); if(pendingPhotoDataURL){ try{ await savePhoto(base.id, pendingPhotoDataURL); base.photo=true; }catch(e){ alert('Could not save photo: '+e.message); } }
			if(editingEntryId){ const idx=t.entries.findIndex(e=>e.id===editingEntryId); if(idx>-1){ const existingPhoto=t.entries[idx].photo; if(existingPhoto && !base.photo) base.photo=true; t.entries[idx]=Object.assign({}, t.entries[idx], base); toast('Entry updated'); }
			} else { t.entries.push(base); if(state.settings.sticky){ // keep lure fields
					['lureType','lureBrand','lureSize','lureColor','attractor','flyMeat','lineType','lineStrength'].forEach(id=>{/*sticky implies leave value*/});
				} else { /* will clear below */ }
			}
	t.updatedAt=Date.now(); save(); indicateSaved(); renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge(); clearCatchForm(true); setEditing(false);
		}
	function clearCatchForm(){ $$('#tab-log input, #tab-log textarea, #tab-log select').forEach(el=>{ if(el.id==='time'){ setNow(); return; } el.value=''; }); $$('.cond').forEach(x=>x.classList.add('hide')); pendingPhotoDataURL=''; if(photoInput) photoInput.value=''; if(photoPreview){ photoPreview.classList.add('hide'); photoPreview.src=''; } try{ window.scrollTo({top:0,left:0,behavior:'auto'}); }catch(_){ window.scrollTo(0,0); } setTimeout(()=>{ try{ window.scrollTo({top:0,left:0,behavior:'auto'}); }catch(_){ } },50); }
	// (Removed duplicate event listener for #resetForm)
	async function renderEntries(){ const t=state.trips[currentTripId()]; const tbody=$('#entriesTable tbody'); if(!t){ tbody.innerHTML=''; return; } const rows=await Promise.all(t.entries.map(async e=>{ const lure=[e.lureType,e.lureBrand,e.lureColor].filter(Boolean).join(' • '); const depths=[`W:${e.waterDepth||'-'}`,`T:${e.targetDepth||'-'}`,(e.platform==='Downrigger'?`B:${e.ballDepth||'-'}`:'')].filter(Boolean).join(' / '); const dirSpd=[e.trollDir, e.speedBall?`${e.speedBall} mph`:''].filter(Boolean).join(' • '); let photoCell=''; if(e.photo){ const durl=await getPhoto(e.id); photoCell = durl ? `<img src="${durl}" class="thumb" alt="thumb" data-view="${e.id}"/>` : '📷'; } else { photoCell=''; } const rowClass = e.isBite ? ' class="bite-row"' : ''; const timeCell = `${e.isBite ? '<span class="pill badge bite">🎯 Bite</span> ' : ''}${fmt12hFromParts(e.time||'')}`; return `<tr${rowClass}><td>${timeCell}</td><td><span class=\"pill badge\">${e.platform||''}</span></td><td>${photoCell}</td><td>${lure}</td><td>${depths}</td><td>${dirSpd}</td><td>${e.species||''}</td><td style=\"text-align:right;white-space:nowrap\"><button class=\"btn secondary\" data-edit=\"${e.id}\">Edit</button> <button class=\"btn secondary\" data-viewbtn=\"${e.id}\">View</button> <button class=\"btn secondary\" data-del=\"${e.id}\">Delete</button></td></tr>`; })); tbody.innerHTML = rows.join(''); $$('button[data-del]').forEach(b=> b.onclick = ()=>{ delEntry(b.dataset.del); }); $$('button[data-viewbtn]').forEach(b=> b.onclick = ()=>{ openLightbox(b.dataset.viewbtn); }); $$('button[data-edit]').forEach(b=> b.onclick = ()=>{ startEdit(b.dataset.edit); }); $$('img[data-view]').forEach(img=> img.onclick = ()=>{ openLightbox(img.dataset.view); }); }
	function loadEntryIntoForm(e, duplicate=false){ ['time','platform','trollDir','waterDepth','ballDepth','ballWeight','dipsySize','dipsySetting','copperLen','leadcoreColors','targetDepth','lureType','lureBrand','lureSize','lureColor','attractor','flyMeat','speedBall','sog','strikeDepthSeen','species','lengthIn','weightLb','gps','notes'].forEach(id=>{ const el=$('#'+id); if(el && e[id]) el.value = e[id] ?? ''; }); if(e.platform) $('#platform').dispatchEvent(new Event('change')); if(!duplicate){ editingEntryId=e.id; setEditing(true); pendingPhotoDataURL=''; photoPreview.classList.add('hide'); photoPreview.src=''; } }
	function startEdit(id){ const t=state.trips[currentTripId()]; if(!t) return; const e=t.entries.find(x=>x.id===id); if(!e) return; loadEntryIntoForm(e,false); toast('Editing entry'); }
	async function delEntry(id){ const t=state.trips[currentTripId()]; if(!t) return; const e=t.entries.find(x=>x.id===id); if(!e) return; const photoData = e.photo ? await getPhoto(e.id) : null; t.entries = t.entries.filter(x=>x.id!==id); save(); indicateSaved(); renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge(); scheduleUndo({ entry:e, photo:photoData }); }
	function scheduleUndo(payload){ pendingDelete=payload; showUndo(); if(undoTimer) clearTimeout(undoTimer); undoTimer=setTimeout(()=>{ finalizeDelete(); }, UNDO_MS); }
	function finalizeDelete(){ if(!pendingDelete) return; if(pendingDelete.entry.photo){ deletePhoto(pendingDelete.entry.id).catch(()=>{}); } pendingDelete=null; hideToast(); }
	function undoDelete(){ if(!pendingDelete) return; const t=state.trips[currentTripId()]; if(!t){ pendingDelete=null; return; } t.entries.push(pendingDelete.entry); save(); indicateSaved(); renderEntries(); renderSummary(); renderAnalytics(); updateLogBadge(); pendingDelete=null; hideToast(); toast('Restored'); }
		async function openLightbox(entryId){ const durl = await getPhoto(entryId); if(!durl){ alert('No photo for this entry.'); return; } $('#lightboxImg').src=durl; $('#lightbox').classList.remove('hide'); }
	// lightbox handlers are attached inside DOMContentLoaded above (guarded). Duplicate handlers removed.
		function renderSummary(){ const t=state.trips[currentTripId()]; const box=$('#summary'); if(!t||!t.entries.length){ box.innerHTML='<span class="muted">No entries yet.</span>'; return; } const h=t.header||{}; const n=t.entries.length; const landed=t.entries.filter(e=>e.landed==='Y').length; const kept=t.entries.filter(e=>e.keptRel==='Kept').length; const bestWaterDepth=mode(t.entries.map(e=>e.waterDepth).filter(Number.isFinite)); const bestTargetDepth=mode(t.entries.map(e=>e.targetDepth).filter(Number.isFinite)); const bestLureType=mode(t.entries.map(e=>e.lureType).filter(Boolean)); const bestColor=mode(t.entries.map(e=>e.lureColor).filter(Boolean)); const bestDir=mode(t.entries.map(e=>e.trollDir).filter(Boolean)); const lengths=t.entries.map(e=>e.lengthIn).filter(Number.isFinite); const weights=t.entries.map(e=>e.weightLb).filter(Number.isFinite); const avg=(arr)=> (arr.length? (arr.reduce((a,b)=>a+b,0)/arr.length).toFixed(1):''); const chips=[`Date: <b>${h.date||'-'}</b>`,`Port: <b>${h.port||'-'}</b>`,`Crew: <b>${h.crew||'-'}</b>`,`Entries: <b>${n}</b>`,`Landed: <b>${landed}</b>`,`Kept: <b>${kept}</b>`,`Best water depth: <b>${bestWaterDepth||'-'}</b>`,`Best target depth: <b>${bestTargetDepth||'-'}</b>`,`Best direction: <b>${bestDir||'-'}</b>`,`Best lure: <b>${bestLureType||'-'}</b>`,`Best color: <b>${bestColor||'-'}</b>`]; if(lengths.length>=2) chips.push(`Avg length: <b>${avg(lengths)} in</b>`); if(weights.length>=2) chips.push(`Avg weight: <b>${avg(weights)} lb</b>`); box.innerHTML='<div class="grid cols-3">'+chips.map(c=>`<div class="chip">${c}</div>`).join('')+'</div>'; }
	function updateLogBadge(){ const t=state.trips[currentTripId()]; const badge=$('#logCountBadge'); if(!badge) return; const n=(t && t.entries && t.entries.length) || 0; if(n){ badge.style.display='inline-block'; badge.textContent=n; } else { badge.style.display='none'; } }
		function renderAnalytics(){ const t=state.trips[currentTripId()]; const box=$('#analytics'); if(!box) return; if(!t||!t.entries.length){ box.innerHTML='(No data)'; return; } const entries=t.entries.slice(); const countBy=(k)=>{ const m={}; entries.forEach(e=>{ const v=e[k]; if(!v) return; m[v]=(m[v]||0)+1; }); return Object.entries(m).sort((a,b)=>b[1]-a[1]); }; const top=(arr,n=3)=>arr.slice(0,n).map(([k,v])=>`${k} (${v})`).join(', '); const platforms=countBy('platform'); const species=countBy('species'); const lureTypes=countBy('lureType'); const colors=countBy('lureColor'); // depth buckets 10 ft
			function bucket(arr){ const m={}; arr.filter(Number.isFinite).forEach(v=>{ const b=Math.floor(v/10)*10; const label=`${b}-${b+9}`; m[label]=(m[label]||0)+1; }); return Object.entries(m).sort((a,b)=>{ const na=parseInt(a[0]); const nb=parseInt(b[0]); return na-nb; }); }
			const wdBuckets=bucket(entries.map(e=>e.waterDepth)); const tdBuckets=bucket(entries.map(e=>e.targetDepth)); // timeline 15 min
			const timeline=(()=>{ const pts=entries.filter(e=>e.ts); if(!pts.length) return []; const min=Math.min(...pts.map(e=>e.ts)); const max=Math.max(...pts.map(e=>e.ts)); const span=15*60*1000; const buckets=[]; for(let tms=Math.floor(min/span)*span; tms<=max; tms+=span){ buckets.push({ t:tms, c:0 }); } pts.forEach(e=>{ const idx=Math.floor((e.ts - buckets[0].t)/span); if(buckets[idx]) buckets[idx].c++; }); return buckets; })();
			const spark=timeline.map(b=>{ const tt = fmt12hFromDate(new Date(b.t)); return `<div class="spark" style="width:6px;height:${4+Math.min(30,b.c*6)}px" title="${tt}: ${b.c}"></div>`; }).join('');
			const fmtList=(list)=> list.map(([k,v])=>`${k}: <b>${v}</b>`).join(' • ');
			box.innerHTML=`<h4>Platforms</h4>${fmtList(platforms)||'-'}<h4>Species</h4>${fmtList(species)||'-'}<h4>Lure Types (Top)</h4>${top(lureTypes)||'-'}<h4>Colors (Top)</h4>${top(colors)||'-'}<h4>Water Depth (10s)</h4>${wdBuckets.map(([k,v])=>`${k}: <b>${v}</b>`).join(' • ')||'-'}<h4>Target Depth (10s)</h4>${tdBuckets.map(([k,v])=>`${k}: <b>${v}</b>`).join(' • ')||'-'}<h4>Timeline 15m</h4><div style="display:flex;align-items:flex-end;height:50px;">${spark}</div>`;
		}
		function mode(arr){ if(!arr.length) return ''; const map=new Map(); arr.forEach(v=>map.set(v,(map.get(v)||0)+1)); let m='',c=0; map.forEach((n,k)=>{ if(n>c){c=n;m=k;} }); return m; }
		// Trip slug helpers
		function generateTripSlug(){ try{ const t=state.trips[currentTripId()]; if(!t) return; const hdr=t.header=t.header||{}; const date = hdr.date || new Date().toISOString().slice(0,10); const now=new Date(); const h=now.getHours(); const min=String(now.getMinutes()).padStart(2,'0'); const ampm=h>=12?'pm':'am'; const hour12=(h%12)||12; let near=hdr.port||''; if(near){ near=near.split(/[,\s]/).filter(Boolean)[0]; near=near?('Near '+near):''; } const slug=`${date}-${hour12}.${min}${ampm}${near}`.replace(/\s+/g,''); hdr.slug=slug; save(); }catch(_){ }}
		function updateTripSlugDisplay(){ try{ const el=document.getElementById('tripSlug'); const t=state.trips[currentTripId()]; if(el){ el.textContent='Trip slug: '+(t && t.header && t.header.slug || '—'); } }catch(_){ }}
		// Trip slug helpers
		function generateTripSlug(){ try{ const t=state.trips[currentTripId()]; if(!t) return; const hdr=t.header=t.header||{}; const date = hdr.date || new Date().toISOString().slice(0,10); const now=new Date(); const h=now.getHours(); const min=String(now.getMinutes()).padStart(2,'0'); const ampm=h>=12?'pm':'am'; const h12=(h%12)||12; let near=(hdr.port||'').split(/[,\s]/).filter(Boolean)[0]||''; if(near) near='Near '+near; const slug=`${date}-${h12}.${min}${ampm}${near}`.replace(/\s+/g,''); hdr.slug=slug; save(); }catch(_){ } }
		function updateTripSlugDisplay(){ try{ const el=document.getElementById('tripSlug'); const t=state.trips[currentTripId()]; if(el){ el.textContent='Trip slug: '+ (t && t.header && t.header.slug || '—'); } }catch(_){ } }
		function toCsvRow(fields){ return fields.map(v=>{ if(v===null||v===undefined) v=''; v=String(v); if(/[",\n]/.test(v)) v='"'+v.replace(/"/g,'""')+'"'; return v; }).join(','); }
		async function exportCsv(){ const t=state.trips[currentTripId()]; if(!t) return alert('No trip.'); const h=['TripDate','Time','Timestamp','PortArea','GPS_Lat','GPS_Lon','Waypoint','WaterDepth_ft','SurfaceTemp_F','Platform','DipsySize','DipsySetting','RiggerBallWeight_lb','RiggerBallDepth_ft','TargetDepth_ft','StrikeDepthSeen_ft','SpeedAtBall_mph','SOG_mph','TrollDirection','LureType','LureBrand','LureModel','LureSize','LureColor','Attractor/Flasher','Fly/MeatColor','Species','Length_in','Weight_lb','Notes','HasPhoto']; const lines=[toCsvRow(h)]; const hdr=t.header||{};
		for(const e of t.entries){
			const parts=(e.gps||'').split(',');
			const lat=(parts[0] && parts[0].trim())||'';
			const lon=(parts[1] && parts[1].trim())||'';
				const row=[
				hdr.date||'',             // TripDate
				fmt12hFromParts(e.time||''),               // Time
				e.ts||'',                 // Timestamp
				hdr.port||'',             // PortArea
				lat||'',                  // GPS_Lat
				lon||'',                  // GPS_Lon
				'',                       // Waypoint
				e.waterDepth||'',         // WaterDepth_ft (inserted)
				hdr.surfaceTemp||'',      // SurfaceTemp_F
				e.platform||'',           // Platform
				e.dipsySize||'',          // DipsySize
				e.dipsySetting||'',       // DipsySetting
				e.ballWeight||'',         // RiggerBallWeight_lb
				e.ballDepth||'',          // RiggerBallDepth_ft
				e.targetDepth||'',        // TargetDepth_ft
				e.strikeDepthSeen||'',    // StrikeDepthSeen_ft
				e.speedBall||'',          // SpeedAtBall_mph
				e.sog||'',                // SOG_mph
				e.trollDir||'',           // TrollDirection
				e.lureType||'',           // LureType
				e.lureBrand||'',          // LureBrand
				'',                       // LureModel
				e.lureSize||'',           // LureSize
				e.lureColor||'',          // LureColor
				e.attractor||'',          // Attractor/Flasher
				e.flyMeat||'',            // Fly/MeatColor
				e.species||'',            // Species
				e.lengthIn||'',           // Length_in
				e.weightLb||'',           // Weight_lb
				e.notes||'',              // Notes
				e.photo?'Y':'N'           // HasPhoto
			];
			lines.push(toCsvRow(row));
		}
		download('catches_'+(hdr.date||'trip')+'.csv', lines.join('\n'));
	}
	async function exportJson(){ const id=currentTripId(); if(!id) return alert('No trip.'); const t=state.trips[id]; const photos={}; for(const e of t.entries){ if(e.photo){ photos[e.id]=await getPhoto(e.id); } } const out=Object.assign({}, t, { photos: photos, exportVersion:2 }); const fname='trip_'+(((t.header && t.header.date) || id))+'.json'; download(fname, JSON.stringify(out,null,2)); }
	async function exportAlbum(){ const id=currentTripId(); if(!id) return alert('No trip.'); const t=state.trips[id]; const photos=[]; for(const e of t.entries){ if(e.photo){ photos.push({id:e.id, time:e.time, species:e.species, lure:[e.lureType,e.lureBrand,e.lureColor].filter(Boolean).join(' • '), durl: await getPhoto(e.id)}); } } const tripDate = (t.header && t.header.date) || 'trip'; const html='<!doctype html><meta charset="utf-8"><title>Album '+tripDate+'</title><style>body{font-family:system-ui;background:#0e131b;color:#e8eefb;margin:0;padding:16px}h1{font-size:20px} .g{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px} figure{margin:0;background:#151b26;border:1px solid #243349;border-radius:12px;overflow:hidden} img{width:100%;height:200px;object-fit:cover;display:block} figcaption{padding:8px 10px;font-size:12px;color:#b9c9e3} </style><h1>Trip '+tripDate+'</h1><div class="g">'+photos.map(p=>'<figure><img src="'+p.durl+'"><figcaption>'+ (p.time||'') +' • '+ (p.species||'') +'<br>'+ (p.lure||'') +'</figcaption></figure>').join('')+'</div>'; download('album_'+tripDate+'.html', html); }
	// Push trip summary to Google Sheets Web App (Apps Script). Requires settings: sheetWebAppUrl and sheetSecret
	async function pushTripToSheet(){ const id=currentTripId(); if(!id) return alert('No trip selected'); const t=state.trips[id]; const hdr=t.header||{}; let url = (state.settings && state.settings.sheetWebAppUrl) ? state.settings.sheetWebAppUrl.trim() : ''; let secret = (state.settings && state.settings.sheetSecret) ? state.settings.sheetSecret.trim() : ''; // defensive fallback: read directly from form if state wasn't persisted
		if(!url) url = (readVal('#sheetWebAppUrl') || '').trim(); if(!secret) secret = (readVal('#sheetSecret') || '').trim(); if(!url) return toast('Set Sheet Web App URL in Settings first');
		const payload = {
			secret: secret || '',
			tripDate: hdr.date || '',
			time: hdr.startTime || '',
			port: hdr.port || '',
			gpsLat: hdr.lastLat || '',
			gpsLon: hdr.lastLon || '',
			waterDepth: hdr.bestWaterDepth || '',
			surfaceTemp: hdr.surfaceTemp || '',
			notes: hdr.notes || ''
		};
		try{
			const r = await fetch(url, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
			if(!r.ok) { toast('Push failed: HTTP '+r.status); console.warn('pushTripToSheet failed', r.status); return; }
			const js = await r.json().catch(()=>null);
			if(js && js.ok) { toast('Trip pushed to Google Sheet'); } else { toast('Push completed; server response: '+(js && js.error? js.error : 'unknown')); }
		}catch(e){ console.warn('pushTripToSheet error', e); toast('Network error while pushing trip'); }
	}
	attach('#pushToSheet','click', ()=>{ pushTripToSheet(); });
	// Push full trip: send the entire trip (header + entries) in one POST.
	// Server (Apps Script) should accept payload.trip and append rows server-side.
	async function pushFullTrip(){
		const id = currentTripId(); if(!id) return alert('No trip selected');
		const t = state.trips[id]; const hdr = t.header || {};
		let url = (state.settings && state.settings.sheetWebAppUrl) ? state.settings.sheetWebAppUrl.trim() : '';
		let secret = (state.settings && state.settings.sheetSecret) ? state.settings.sheetSecret.trim() : '';
		// defensive fallback: read directly from form if state wasn't persisted
		if(!url) url = (readVal('#sheetWebAppUrl') || '').trim(); if(!secret) secret = (readVal('#sheetSecret') || '').trim();
		if(!url) return toast('Set Sheet Web App URL in Settings first');
		toast('Pushing full trip (single request)...');
		const payload = { secret: secret || '', trip: t };
		try{
			const r = await fetch(url, { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
			if(!r.ok){ console.warn('pushFullTrip failed HTTP', r.status); // try no-cors fallback
				try{
					await fetch(url, { method:'POST', mode:'no-cors', body: JSON.stringify(payload) });
					toast('Push attempted (no-cors fallback). Check sheet.');
					return;
				}catch(nc){ console.warn('no-cors fallback failed', nc); toast('Push failed: HTTP '+r.status); return; }
			}
			const js = await r.json().catch(()=>null);
			if(js && js.ok){ toast('Full trip pushed (server appended rows)'); }
			else { toast('Push completed; server response: '+(js && js.error? js.error : 'unknown')); }
		}catch(err){
			console.warn('pushFullTrip network error', err);
			// try no-cors fallback as last resort
			try{
				await fetch(url, { method:'POST', mode:'no-cors', body: JSON.stringify(payload) });
				toast('Push attempted (no-cors fallback). Check sheet.');
			}catch(nc){
				console.warn('no-cors fallback failed', nc);
				toast('Network/CORS error while pushing full trip');
			}
		}
	}
	attach('#pushFullTrip','click', ()=>{ pushFullTrip(); });

	// Thermocline & Plan (beta) — lightweight implementation
	attach('#genThermoPlan','click', async ()=>{
    const panel = document.getElementById('thermoPlanPanel'); if(panel) panel.style.display='';
    const statusEl = document.getElementById('thermoStatus'); const outEl = document.getElementById('thermoResult');
    if(statusEl) statusEl.textContent='Gathering sources...'; if(outEl) outEl.textContent='';
    try{ location.hash='#tab-log'; }catch(_){ }
    try{ window.scrollTo({top:0,left:0,behavior:'auto'}); }catch(_){ window.scrollTo(0,0); }
    const btn = document.getElementById('genThermoPlan'); const origTxt = btn? btn.textContent:'';
    if(btn){ btn.disabled=true; btn.textContent='Generating...'; }
    try{
        const t = state.trips[currentTripId()]; if(!t){ if(statusEl) statusEl.textContent='No trip'; return; }
        const hdr = t.header || {}; const lat = parseFloat(hdr.lastLat||''); const lon = parseFloat(hdr.lastLon||'');
        if(!isFinite(lat)||!isFinite(lon)){ if(statusEl) statusEl.textContent='No GPS cached. Tap Catch Conditions (GPS) first.'; return; }
        const stations = (window.__stations||[]).slice();
        // First pass: <=45 km up to 18 stations
        let near = stations.map(s=>({s,d:haversineKm(lat,lon,s.lat,s.lon)}))
            .filter(x=> x.d <=45)
            .sort((a,b)=> a.d - b.d)
            .slice(0,18)
            .map(x=> x.s);
        if(statusEl) statusEl.textContent = `Found ${near.length} nearby (<=45 km)...`;
        const tpl = (state.settings && state.settings.stationJsonTemplate) ? String(state.settings.stationJsonTemplate).trim(): '';
        const profiles=[];
        for(const s of near){
            if(!tpl) continue;
            try{
                const url = tpl.replace('{station}', encodeURIComponent(s.id)).replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
                const u2 = url + (url.includes('?')?'&':'?') + 'prefer=ocean-spec&include=profile';
                const r = await fetch(u2,{cache:'no-store'}); if(r.ok){ const js=await r.json(); const prof=normalizeProfile(js,s,lat,lon); if(prof) profiles.push(prof); }
            }catch(_){ }
        }
        // Fallback expansion if <4 profiles: extend to 65 km up to total 25
        if(profiles.length < 4){
            if(statusEl) statusEl.textContent = `Few profiles (${profiles.length}); expanding search...`;
            const expanded = stations.map(s=>({s,d:haversineKm(lat,lon,s.lat,s.lon)}))
                .filter(x=> x.d <=65)
                .sort((a,b)=> a.d - b.d)
                .slice(0,25)
                .map(x=> x.s)
                .filter(s=> !near.find(n=> n.id===s.id));
            for(const s of expanded){
                if(!tpl) continue;
                try{
                    const url = tpl.replace('{station}', encodeURIComponent(s.id)).replace('{lat}', encodeURIComponent(lat)).replace('{lon}', encodeURIComponent(lon));
                    const u2 = url + (url.includes('?')?'&':'?') + 'prefer=ocean-spec&include=profile';
                    const r = await fetch(u2,{cache:'no-store'}); if(r.ok){ const js=await r.json(); const prof=normalizeProfile(js,s,lat,lon); if(prof) profiles.push(prof); }
                }catch(_){ }
            }
            near = near.concat(expanded);
        }
        if(!profiles.length){ if(statusEl) statusEl.textContent = 'No profile data; estimating from surface and history...';
				// estimate band using surface temp and recent entries
				const surfF = parseFloat(hdr.surfaceTemp||'');
				const est = estimateFromHistory(t, isFinite(surfF)? (surfF-32)*5/9 : null);
				renderPlan(est, outEl, statusEl);
				return;
			}
			if(statusEl) statusEl.textContent = `Analyzing ${profiles.length} station profiles...`;
			const stationResults = profiles.map(p=> perStationThermo(p));
			if(statusEl) statusEl.textContent = 'Fusing corridor...';
			const comp = fuseThermo(stationResults, {lat, lon});
			renderPlan(comp, outEl, statusEl);
			// persist lastPlanAt
			try{ t.header.lastPlanAt = Date.now(); save(); indicateSaved(); }catch(_){ }
		}catch(e){ console.warn('thermo plan error', e); if(statusEl) statusEl.textContent='Failed to generate plan'; }
		finally{ if(btn){ btn.disabled=false; btn.textContent=origTxt; } }
	});

	// Corrected estimateFromHistory implementation
	function estimateFromHistory(trip, sstC){
    const recent = (trip.entries||[]).slice(-6);
    const depths = recent.map(e=> e.targetDepth || e.waterDepth).filter(n=> Number.isFinite(n));
    const avg = depths.length? depths.reduce((a,b)=>a+b,0)/depths.length : null;
    const estCline = avg? Math.max(10, Math.min(120, avg)) : 60;
    return { cline_m: estCline*0.3048, iso10_m: (estCline-15)*0.3048, iso12_m: (estCline-5)*0.3048, sources: 0 };
	}
	</script>
</body>
</html>

